import sys
import io
from io import BytesIO
import csv
import subprocess
import os
import threading
from queue import Queue, Empty as QueueEmpty
import queue as _queue

# Ki·ªÉm tra v√† c√†i ƒë·∫∑t dependencies t·ª± ƒë·ªông (ch·ªâ khi ch·∫°y tr·ª±c ti·∫øp)
def check_and_install_dependencies():
    """Ki·ªÉm tra v√† c√†i ƒë·∫∑t dependencies n·∫øu thi·∫øu"""
    # Tr√°nh v√≤ng l·∫∑p v√¥ h·∫°n
    if os.environ.get('APP_SKIP_CHECK') == '1':
        return
    
    required_packages = {
        'flask': 'flask',
        'openpyxl': 'openpyxl', 
        'flask_login': 'flask-login',
        'flask_wtf': 'flask-wtf',
        'werkzeug': 'werkzeug',
        'sqlalchemy': 'sqlalchemy',
        'flask_migrate': 'flask-migrate',
        'jinja2': 'jinja2',
        'reportlab': 'reportlab',
        'selenium': 'selenium',
        'webdriver_manager': 'webdriver-manager',
        'PIL': 'Pillow',
        'numpy': 'numpy'
    }
    
    missing_packages = []
    for module_name, package_name in required_packages.items():
        try:
            if module_name == 'PIL':
                __import__('PIL')
            else:
                __import__(module_name)
        except ImportError:
            missing_packages.append(package_name)
    
    if missing_packages:
        print("=" * 70)
        print("‚ö†Ô∏è  PH√ÅT HI·ªÜN THI·∫æU C√ÅC TH∆Ø VI·ªÜN C·∫¶N THI·∫æT")
        print("=" * 70)
        print(f"\nC√°c th∆∞ vi·ªán thi·∫øu: {', '.join(missing_packages)}")
        print("\nƒêang t·ª± ƒë·ªông c√†i ƒë·∫∑t...")
        print("-" * 70)
        
        try:
            # C√†i ƒë·∫∑t t·ª´ requirements.txt n·∫øu c√≥
            if os.path.exists('requirements.txt'):
                print("üì¶ ƒêang c√†i ƒë·∫∑t t·ª´ requirements.txt...")
                result = subprocess.run(
                    [sys.executable, '-m', 'pip', 'install', '-r', 'requirements.txt'],
                    check=False
                )
                if result.returncode == 0:
                    print("‚úÖ C√†i ƒë·∫∑t th√†nh c√¥ng!")
                    print("\nüîÑ ƒêang kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng...")
                    os.environ['APP_SKIP_CHECK'] = '1'
                    os.execv(sys.executable, [sys.executable] + sys.argv)
                else:
                    print("‚ö†Ô∏è  C√≥ l·ªói khi c√†i ƒë·∫∑t t·ª´ requirements.txt")
                    print("ƒêang th·ª≠ c√†i ƒë·∫∑t t·ª´ng package...")
                    for pkg in missing_packages:
                        print(f"   ƒêang c√†i ƒë·∫∑t {pkg}...")
                        subprocess.run([sys.executable, '-m', 'pip', 'install', pkg], 
                                     check=False)
            else:
                # C√†i ƒë·∫∑t t·ª´ng package
                print("üì¶ ƒêang c√†i ƒë·∫∑t c√°c package thi·∫øu...")
                for pkg in missing_packages:
                    print(f"   ƒêang c√†i ƒë·∫∑t {pkg}...")
                    subprocess.run([sys.executable, '-m', 'pip', 'install', pkg], 
                                 check=False)
            
            print("\n‚úÖ ƒê√£ c√†i ƒë·∫∑t xong! ƒêang kh·ªüi ƒë·ªông l·∫°i...")
            os.environ['APP_SKIP_CHECK'] = '1'
            os.execv(sys.executable, [sys.executable] + sys.argv)
        except Exception as e:
            print(f"\n‚ùå L·ªói khi c√†i ƒë·∫∑t: {e}")
            print("\n" + "=" * 70)
            print("H∆Ø·ªöNG D·∫™N C√ÄI ƒê·∫∂T TH·ª¶ C√îNG:")
            print("=" * 70)
            print("\n1. C√†i ƒë·∫∑t dependencies:")
            if os.path.exists('requirements.txt'):
                print(f"   {sys.executable} -m pip install -r requirements.txt")
            else:
                print(f"   {sys.executable} -m pip install {' '.join(missing_packages)}")
            print("\n2. Ch·∫°y l·∫°i ·ª©ng d·ª•ng:")
            print("   python app.py")
            print("=" * 70)
            sys.exit(1)
# ============================================================================
# GOOGLE SHEET BACKGROUND UPDATE                                             #
# ============================================================================

# Rate-limited queue cho Google Sheets updates
_google_sheets_update_queue = Queue()
_google_sheets_queue_worker_started = False
_google_sheets_queue_lock = threading.Lock()

# ===== BATCH QUEUE CONSTANTS =====
BATCH_SIZE = 50  # S·ªë records t·ªëi ƒëa trong 1 batch
BATCH_TIMEOUT = 2.0  # Seconds - flush batch n·∫øu kh√¥ng ƒë·ªß size sau kho·∫£ng th·ªùi gian n√†y
MIN_DELAY_BETWEEN_BATCHES = 1.0  # Seconds - delay gi·ªØa c√°c batch ƒë·ªÉ tr√°nh rate limit

def _google_sheets_queue_worker():
    """
    Worker thread x·ª≠ l√Ω queue Google Sheets updates v·ªõi BATCH COLLECTOR
    Gom nhi·ªÅu requests th√†nh batch ƒë·ªÉ gi·∫£m s·ªë API calls
    """
    import time
    from datetime import datetime

    # Delay khi g·∫∑p 429 error
    RETRY_DELAY_ON_429 = 5.0  # gi√¢y

    def _log(msg):
        try:
            print(msg, flush=True, file=sys.stderr)
        except Exception:
            pass

    _log("üîÑ [SHEET_QUEUE_WORKER] Worker thread ƒë√£ kh·ªüi ƒë·ªông (BATCH MODE)")

    batch = []  # Batch collector
    last_batch_time = time.time()

    while True:
        try:
            # Non-blocking get v·ªõi timeout ng·∫Øn ƒë·ªÉ c√≥ th·ªÉ check batch timeout
            try:
                task = _google_sheets_update_queue.get(timeout=0.5)

                if task is None:  # Sentinel ƒë·ªÉ d·ª´ng worker
                    # Flush remaining batch tr∆∞·ªõc khi d·ª´ng
                    if batch:
                        _log(f"üõë [SHEET_QUEUE_WORKER] Flush {len(batch)} records c√≤n l·∫°i tr∆∞·ªõc khi d·ª´ng...")
                        _process_queue_batch(batch, _log)
                    _log("üõë [SHEET_QUEUE_WORKER] Nh·∫≠n t√≠n hi·ªáu d·ª´ng, worker s·∫Ω k·∫øt th√∫c")
                    break

                batch.append(task)
                _google_sheets_update_queue.task_done()

            except _queue.Empty:
                pass  # Queue r·ªóng, ti·∫øp t·ª•c check batch

            # Ki·ªÉm tra ƒëi·ªÅu ki·ªán flush batch
            should_flush = (
                len(batch) >= BATCH_SIZE or
                (batch and time.time() - last_batch_time >= BATCH_TIMEOUT)
            )

            if should_flush and batch:
                _log(f"üöÄ [SHEET_QUEUE_WORKER] Flush batch: {len(batch)} records")

                # Process batch
                success = _process_queue_batch(batch, _log)

                # Reset batch
                batch = []
                last_batch_time = time.time()

                # Delay gi·ªØa c√°c batches
                time.sleep(MIN_DELAY_BETWEEN_BATCHES)

        except Exception as e:
            _log(f"‚ùå [SHEET_QUEUE_WORKER] L·ªói trong worker thread: {e}")
            import traceback
            _log(traceback.format_exc())
            time.sleep(1)  # ƒê·ª£i m·ªôt ch√∫t tr∆∞·ªõc khi ti·∫øp t·ª•c


def _process_queue_batch(batch, _log):
    """
    X·ª≠ l√Ω m·ªôt batch c√°c tasks s·ª≠ d·ª•ng batch update
    """
    import time

    if not batch:
        return True

    try:
        # Chu·∫©n b·ªã d·ªØ li·ªáu cho batch update
        # M·ªói task c√≥ format: (attendance_id, employee_team, employee_id, attendance_data)

        # T·∫°o mock attendance objects cho batch update function
        class MockAttendance:
            def __init__(self, att_id):
                self.id = att_id

        batch_data = []
        for task in batch:
            attendance_id, employee_team, employee_id, attendance_data = task
            mock_att = MockAttendance(attendance_id)
            batch_data.append((mock_att, employee_team, employee_id, attendance_data))

        # G·ªçi batch update
        result = batch_update_multi_attendances_sync(batch_data)

        _log(f"   ‚úÖ Batch result: {len(result['success_ids'])} success, {len(result['failed'])} failed")
        _log(f"   üì° API calls: {result['total_api_calls']}")

        return len(result['failed']) == 0

    except Exception as e:
        _log(f"   ‚ùå Batch processing error: {e}")

        # Fallback: x·ª≠ l√Ω t·ª´ng record ri√™ng l·∫ª
        _log(f"   üîÑ Fallback: x·ª≠ l√Ω {len(batch)} records ri√™ng l·∫ª...")
        for task in batch:
            try:
                attendance_id, employee_team, employee_id, attendance_data = task
                update_google_sheet_background_safe_direct(
                    attendance_id, employee_team, employee_id, attendance_data
                )
                time.sleep(1.2)  # Rate limiting
            except Exception as inner_e:
                _log(f"   ‚ùå Failed for ID {attendance_id}: {inner_e}")

        return False

def _ensure_google_sheets_queue_worker():
    """ƒê·∫£m b·∫£o worker thread ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông"""
    global _google_sheets_queue_worker_started
    
    with _google_sheets_queue_lock:
        if not _google_sheets_queue_worker_started:
            worker_thread = threading.Thread(
                target=_google_sheets_queue_worker,
                daemon=True,
                name="GoogleSheetsQueueWorker"
            )
            worker_thread.start()
            _google_sheets_queue_worker_started = True
            print("üöÄ [SHEET_QUEUE] ƒê√£ kh·ªüi ƒë·ªông worker thread cho Google Sheets update queue", flush=True, file=sys.stderr)

def update_google_sheet_background_safe(attendance_id, employee_team, employee_id, attendance_data):
    """
    Background task an to√†n ƒë·ªÉ c·∫≠p nh·∫≠t Google Sheet v·ªõi rate limiting
    S·ª≠ d·ª•ng queue ƒë·ªÉ x·ª≠ l√Ω tu·∫ßn t·ª±, tr√°nh v∆∞·ª£t quota API
    """
    # ƒê·∫£m b·∫£o worker thread ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông
    _ensure_google_sheets_queue_worker()
    
    # Th√™m task v√†o queue
    try:
        _google_sheets_update_queue.put((attendance_id, employee_team, employee_id, attendance_data), timeout=5)
        print(f"üì• [SHEET_QUEUE] ƒê√£ th√™m attendance ID {attendance_id} v√†o queue (queue size: {_google_sheets_update_queue.qsize()})", flush=True, file=sys.stderr)
    except Exception as e:
        print(f"‚ùå [SHEET_QUEUE] L·ªói khi th√™m v√†o queue: {e}", flush=True, file=sys.stderr)

def update_google_sheet_background_safe_direct(attendance_id, employee_team, employee_id, attendance_data):
    """
    H√†m th·ª±c t·∫ø c·∫≠p nh·∫≠t Google Sheet (ƒë∆∞·ª£c g·ªçi b·ªüi queue worker)
    Kh√¥ng l√†m crash app n·∫øu c√≥ l·ªói
    """
    import sys
    from datetime import datetime
    
    # Log helper - ch·ªâ log v√†o stderr ƒë·ªÉ tr√°nh I/O operation on closed file
    def _log(msg):
        try:
            print(msg, flush=True, file=sys.stderr)
        except Exception:
            pass
    
    try:
        _log(f"üîµ [SHEET_UPDATE] H√ÄM ƒê∆Ø·ª¢C G·ªåI - ID: {attendance_id}")
        _log(f"   Team: {employee_team}, Employee ID: {employee_id}")
        
        # Lazy access to app - app ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a sau trong file n√†y
        # S·ª≠ d·ª•ng globals() ƒë·ªÉ l·∫•y app instance khi function ƒë∆∞·ª£c g·ªçi
        import sys
        current_module = sys.modules[__name__]
        flask_app = getattr(current_module, 'app', None)
        
        if flask_app is None:
            _log(f"‚ùå [SHEET_UPDATE] Flask app ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o")
            return
        
        _log(f"üîµ [SHEET_UPDATE] T·∫°o app context...")
        with flask_app.app_context():
            _log(f"üîµ [SHEET_UPDATE] ƒê√£ v√†o app context")
            
            # Kh·ªüi t·∫°o Google API
            _log(f"üîµ [SHEET_UPDATE] Kh·ªüi t·∫°o GoogleDriveAPI...")
            try:
                google_api = GoogleDriveAPI()
                _log(f"üîµ [SHEET_UPDATE] ƒê√£ kh·ªüi t·∫°o GoogleDriveAPI")
            except Exception as api_init_err:
                _log(f"‚ùå [SHEET_UPDATE] L·ªói kh·ªüi t·∫°o GoogleDriveAPI: {api_init_err}")
                import traceback
                _log(f"   Traceback: {traceback.format_exc()}")
                return
            
            # Ki·ªÉm tra token
            _log(f"üîµ [SHEET_UPDATE] Ki·ªÉm tra token...")
            try:
                token_valid = google_api.ensure_valid_token()
                if not token_valid:
                    _log(f"‚ùå [SHEET_UPDATE] Token kh√¥ng h·ª£p l·ªá")
                    return
                _log(f"‚úÖ [SHEET_UPDATE] Token h·ª£p l·ªá")
            except Exception as token_err:
                _log(f"‚ùå [SHEET_UPDATE] L·ªói ki·ªÉm tra token: {token_err}")
                import traceback
                _log(f"   Traceback: {traceback.format_exc()}")
                return
            
            if not google_api.sheets_service:
                _log(f"‚ùå [SHEET_UPDATE] Google Sheets service kh√¥ng kh·∫£ d·ª•ng")
                return
            
            # T√¨m th√°ng c·ªßa ng√†y ngh·ªâ
            attendance_date_str = attendance_data.get('date')
            attendance_month = None
            if attendance_date_str:
                try:
                    attendance_dt = datetime.strptime(attendance_date_str, "%Y-%m-%d")
                    attendance_month = attendance_dt.strftime("%Y%m")
                    _log(f"üìÖ [SHEET_UPDATE] Ng√†y: {attendance_date_str} -> Th√°ng: {attendance_month}")
                except ValueError as date_err:
                    _log(f"‚ö†Ô∏è [SHEET_UPDATE] L·ªói parse ng√†y: {date_err}")
            
            current_month = attendance_month or datetime.now().strftime("%Y%m")
            _log(f"üîç [SHEET_UPDATE] T√¨m file - Team: {employee_team}, Month: {current_month}, Employee ID: {employee_id}")
            
            # Validation: Ki·ªÉm tra employee_id v√† team tr∆∞·ªõc khi t√¨m file
            if not employee_id:
                _log(f"‚ùå [SHEET_UPDATE] VALIDATION ERROR: Kh√¥ng c√≥ employee_id")
                _log(f"   ‚ö†Ô∏è Vui l√≤ng c·∫≠p nh·∫≠t employee_id cho user trong database")
                return
            
            if not employee_team or employee_team == "Unknown":
                _log(f"‚ùå [SHEET_UPDATE] VALIDATION ERROR: Team/Department kh√¥ng h·ª£p l·ªá: {employee_team}")
                _log(f"   ‚ö†Ô∏è Vui l√≤ng c·∫≠p nh·∫≠t department cho user trong database")
                return
            
            # T√¨m file
            try:
                target_file = google_api.find_team_timesheet(
                    folder_id=GOOGLE_DRIVE_FOLDER_ID,
                    team_name=employee_team,
                    month_year=current_month
                )
            except Exception as find_err:
                _log(f"‚ùå [SHEET_UPDATE] L·ªói khi t√¨m file: {find_err}")
                import traceback
                _log(f"   Traceback: {traceback.format_exc()}")
                return
            
            if not target_file:
                _log(f"‚ùå [SHEET_UPDATE] KH√îNG T√åM TH·∫§Y FILE - Team: {employee_team}, Month: {current_month}")
                _log(f"   ‚ö†Ô∏è Vui l√≤ng ki·ªÉm tra:")
                _log(f"      1. File Google Sheet cho team '{employee_team}' th√°ng {current_month} c√≥ t·ªìn t·∫°i kh√¥ng?")
                _log(f"      2. T√™n file c√≥ ƒë√∫ng format kh√¥ng? (v√≠ d·ª•: Bud_TimeSheet-{current_month})")
                _log(f"      3. File c√≥ trong folder Google Drive ƒë√∫ng kh√¥ng?")
                _log(f"      4. Mapping department -> file name trong database c√≥ ƒë√∫ng kh√¥ng?")
                return
            
            _log(f"‚úÖ [SHEET_UPDATE] T√¨m th·∫•y file: {target_file.get('name', 'N/A')} (ID: {target_file.get('id', 'N/A')})")
            
            # C·∫≠p nh·∫≠t sheet
            _log(f"üöÄ [SHEET_UPDATE] G·ªçi update_timesheet_for_attendance...")
            _log(f"   Spreadsheet ID: {target_file['id']}")
            _log(f"   Sheet Name: {employee_id}")
            _log(f"   Data Keys: {list(attendance_data.keys())}")
            if 'leave_summary' in attendance_data:
                _log(f"   Leave Summary: {attendance_data['leave_summary']}")
            
            try:
                success = google_api.update_timesheet_for_attendance(
                    spreadsheet_id=target_file['id'],
                    sheet_name=str(employee_id),
                    attendance_data=attendance_data
                )
                _log(f"üìä [SHEET_UPDATE] K·∫øt qu·∫£: {success}")
            
                if success:
                    _log(f"‚úÖ [SHEET_UPDATE] C·∫≠p nh·∫≠t th√†nh c√¥ng - File: {target_file['name']}, Sheet: {employee_id}")
                    try:
                        create_backup()
                        _log(f"üõ°Ô∏è [SHEET_UPDATE] ƒê√£ t·∫°o backup")
                    except Exception as backup_error:
                        _log(f"‚ö†Ô∏è [SHEET_UPDATE] L·ªói t·∫°o backup: {backup_error}")
                else:
                    _log(f"‚ùå [SHEET_UPDATE] C·∫≠p nh·∫≠t th·∫•t b·∫°i")
            except Exception as update_err:
                error_str = str(update_err)
                _log(f"‚ùå [SHEET_UPDATE] L·ªói khi g·ªçi update_timesheet_for_attendance: {update_err}")
                import traceback
                _log(f"   Traceback: {traceback.format_exc()}")
                
                # N·∫øu l√† rate limit error (429), raise l·∫°i ƒë·ªÉ queue worker c√≥ th·ªÉ retry
                if '429' in error_str or 'RATE_LIMIT_EXCEEDED' in error_str or 'Quota exceeded' in error_str:
                    _log(f"‚ö†Ô∏è [SHEET_UPDATE] Ph√°t hi·ªán rate limit error (429), s·∫Ω retry...")
                    raise  # Re-raise ƒë·ªÉ queue worker x·ª≠ l√Ω retry
            
    except Exception as e:
        import traceback
        try:
            _log(f"‚ùå [SHEET_UPDATE] L·ªñI T·ªîNG QU√ÅT: {str(e)}")
            _log(f"   Type: {type(e).__name__}")
            _log(f"   Traceback:\n{traceback.format_exc()}")
        except Exception:
            # N·∫øu ngay c·∫£ logging c≈©ng l·ªói, th·ª≠ print tr·ª±c ti·∫øp
            try:
                print(f"‚ùå [SHEET_UPDATE] CRITICAL ERROR: {str(e)}", flush=True, file=sys.stderr)
            except Exception:
                pass

def update_google_sheet_sync(attendance_id, employee_team, employee_id, attendance_data, timeout_seconds=30):
    """
    SYNCHRONOUS Google Sheet update function - KH√îNG D√ôNG BACKGROUND THREAD
    D√πng cho ADMIN approval ƒë·ªÉ ƒë·∫£m b·∫£o upload th√†nh c√¥ng TR∆Ø·ªöC KHI commit database
    
    Returns:
        tuple: (success: bool, error_message: str or None)
        - (True, None) n·∫øu th√†nh c√¥ng
        - (False, "error message") n·∫øu th·∫•t b·∫°i
    """
    import sys
    from datetime import datetime as dt
    import signal
    
    def _log(msg):
        """Helper function for logging"""
        try:
            print(msg, flush=True, file=sys.stderr)
        except Exception:
            pass
    
    # Handler cho timeout
    class TimeoutException(Exception):
        pass
    
    def timeout_handler(signum, frame):
        raise TimeoutException("Google Sheet update timeout")
    
    timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
    _log(f"\n{'='*80}")
    _log(f"üîµ [SYNC_SHEET_UPDATE] {timestamp} - B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t ƒê·ªíNG B·ªò")
    _log(f"   Attendance ID: {attendance_id}")
    _log(f"   Employee: {attendance_data.get('user_name', 'Unknown')}")
    _log(f"   Team: {employee_team}")
    _log(f"   Employee ID: {employee_id}")
    _log(f"   Date: {attendance_data.get('date', 'Unknown')}")
    _log(f"{'='*80}")
    
    try:
        # VALIDATION 1: Ki·ªÉm tra employee_id
        if not employee_id:
            error_msg = f"‚ùå Kh√¥ng c√≥ employee_id cho user"
            _log(f"[VALIDATION_ERROR] {error_msg}")
            _log(f"   ‚ö†Ô∏è Vui l√≤ng c·∫≠p nh·∫≠t employee_id trong database tr∆∞·ªõc khi ph√™ duy·ªát")
            return (False, error_msg)
        
        # VALIDATION 2: Ki·ªÉm tra team/department
        if not employee_team or employee_team == "Unknown":
            error_msg = f"‚ùå Department kh√¥ng h·ª£p l·ªá: '{employee_team}'"
            _log(f"[VALIDATION_ERROR] {error_msg}")
            _log(f"   ‚ö†Ô∏è Vui l√≤ng c·∫≠p nh·∫≠t department trong database tr∆∞·ªõc khi ph√™ duy·ªát")
            return (False, error_msg)
        
        # VALIDATION 3: Ki·ªÉm tra attendance_data
        if not attendance_data or not isinstance(attendance_data, dict):
            error_msg = "‚ùå D·ªØ li·ªáu attendance kh√¥ng h·ª£p l·ªá"
            _log(f"[VALIDATION_ERROR] {error_msg}")
            return (False, error_msg)
        
        date_str = attendance_data.get('date')
        if not date_str:
            error_msg = "‚ùå Thi·∫øu th√¥ng tin ng√†y trong attendance_data"
            _log(f"[VALIDATION_ERROR] {error_msg}")
            return (False, error_msg)
        
        _log(f"‚úÖ [VALIDATION_PASS] T·∫•t c·∫£ validations ƒë√£ pass")
        
        # L·∫•y app context - c·∫ßn thi·∫øt v√¨ h√†m n√†y c√≥ th·ªÉ ƒë∆∞·ª£c g·ªçi t·ª´ request context
        import sys
        current_module = sys.modules[__name__]
        flask_app = getattr(current_module, 'app', None)
        
        if flask_app is None:
            error_msg = "‚ùå Flask app ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o"
            _log(f"[APP_ERROR] {error_msg}")
            return (False, error_msg)
        
        _log(f"üîµ [APP_CONTEXT] S·ª≠ d·ª•ng Flask app context")
        
        # Kh·ªüi t·∫°o Google API
        _log(f"üîµ [GOOGLE_API] Kh·ªüi t·∫°o GoogleDriveAPI...")
        try:
            google_api = GoogleDriveAPI()
            _log(f"‚úÖ [GOOGLE_API] ƒê√£ kh·ªüi t·∫°o GoogleDriveAPI")
        except Exception as api_init_err:
            error_msg = f"‚ùå L·ªói kh·ªüi t·∫°o GoogleDriveAPI: {str(api_init_err)}"
            _log(f"[API_ERROR] {error_msg}")
            import traceback
            _log(f"   Traceback: {traceback.format_exc()}")
            return (False, error_msg)
        
        # Ki·ªÉm tra token
        _log(f"üîµ [TOKEN_CHECK] Ki·ªÉm tra token...")
        try:
            token_valid = google_api.ensure_valid_token()
            if not token_valid:
                error_msg = "‚ùå Token Google API kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n"
                _log(f"[TOKEN_ERROR] {error_msg}")
                _log(f"   üí° Vui l√≤ng ch·∫°y: python refresh_token.py ƒë·ªÉ l√†m m·ªõi token")
                return (False, error_msg)
            _log(f"‚úÖ [TOKEN_VALID] Token h·ª£p l·ªá")
        except Exception as token_err:
            error_msg = f"‚ùå L·ªói ki·ªÉm tra token: {str(token_err)}"
            _log(f"[TOKEN_ERROR] {error_msg}")
            import traceback
            _log(f"   Traceback: {traceback.format_exc()}")
            return (False, error_msg)
        
        if not google_api.sheets_service:
            error_msg = "‚ùå Google Sheets service kh√¥ng kh·∫£ d·ª•ng"
            _log(f"[SERVICE_ERROR] {error_msg}")
            return (False, error_msg)
        
        # T√¨m th√°ng c·ªßa ng√†y attendance
        attendance_date_str = attendance_data.get('date')
        attendance_month = None
        if attendance_date_str:
            try:
                attendance_dt = dt.strptime(attendance_date_str, "%Y-%m-%d")
                attendance_month = attendance_dt.strftime("%Y%m")
                _log(f"üìÖ [MONTH_DETECT] Ng√†y: {attendance_date_str} ‚Üí Th√°ng: {attendance_month}")
            except ValueError as date_err:
                error_msg = f"‚ùå L·ªói parse ng√†y: {str(date_err)}"
                _log(f"[DATE_ERROR] {error_msg}")
                return (False, error_msg)
        
        current_month = attendance_month or dt.now().strftime("%Y%m")
        _log(f"üîç [FILE_SEARCH] T√¨m file - Team: {employee_team}, Month: {current_month}")
        
        # T√¨m file Google Sheet
        try:
            target_file = google_api.find_team_timesheet(
                folder_id=GOOGLE_DRIVE_FOLDER_ID,
                team_name=employee_team,
                month_year=current_month
            )
        except Exception as find_err:
            error_msg = f"‚ùå L·ªói khi t√¨m file: {str(find_err)}"
            _log(f"[FILE_SEARCH_ERROR] {error_msg}")
            import traceback
            _log(f"   Traceback: {traceback.format_exc()}")
            return (False, error_msg)
        
        if not target_file:
            error_msg = f"‚ùå Kh√¥ng t√¨m th·∫•y file Google Sheet cho team '{employee_team}' th√°ng {current_month}"
            _log(f"[FILE_NOT_FOUND] {error_msg}")
            _log(f"   ‚ö†Ô∏è Ki·ªÉm tra:")
            _log(f"      1. File c√≥ t·ªìn t·∫°i trong Google Drive kh√¥ng?")
            _log(f"      2. T√™n file c√≥ ƒë√∫ng format kh√¥ng? (v√≠ d·ª•: {employee_team}_TimeSheet-{current_month})")
            _log(f"      3. Department mapping trong database c√≥ ƒë√∫ng kh√¥ng?")
            return (False, error_msg)
        
        _log(f"‚úÖ [FILE_FOUND] T√¨m th·∫•y file: {target_file.get('name', 'N/A')} (ID: {target_file.get('id', 'N/A')})")
        
        # C·∫≠p nh·∫≠t Google Sheet
        _log(f"üöÄ [SHEET_UPDATE] ƒêang c·∫≠p nh·∫≠t sheet '{employee_id}' trong file...")
        _log(f"   Spreadsheet ID: {target_file['id']}")
        _log(f"   Sheet Name: {employee_id}")
        
        try:
            success = google_api.update_timesheet_for_attendance(
                spreadsheet_id=target_file['id'],
                sheet_name=str(employee_id),
                attendance_data=attendance_data
            )
            
            if success:
                _log(f"‚úÖ [SHEET_UPDATE_SUCCESS] C·∫≠p nh·∫≠t th√†nh c√¥ng!")
                _log(f"   File: {target_file['name']}")
                _log(f"   Sheet: {employee_id}")
                _log(f"   Date: {attendance_data.get('date')}")
                _log(f"{'='*80}\n")
                
                # T·∫°o backup
                try:
                    create_backup()
                    _log(f"üõ°Ô∏è [BACKUP] ƒê√£ t·∫°o backup")
                except Exception as backup_error:
                    _log(f"‚ö†Ô∏è [BACKUP_WARNING] L·ªói t·∫°o backup: {backup_error}")
                
                return (True, None)
            else:
                error_msg = "‚ùå C·∫≠p nh·∫≠t Google Sheet th·∫•t b·∫°i (kh√¥ng r√µ l√Ω do)"
                _log(f"[SHEET_UPDATE_FAIL] {error_msg}")
                _log(f"{'='*80}\n")
                return (False, error_msg)
                
        except Exception as update_err:
            error_str = str(update_err)
            error_msg = f"‚ùå L·ªói khi c·∫≠p nh·∫≠t sheet: {error_str}"
            _log(f"[SHEET_UPDATE_ERROR] {error_msg}")
            import traceback
            _log(f"   Traceback: {traceback.format_exc()}")
            _log(f"{'='*80}\n")
            
            # Ki·ªÉm tra c√°c l·ªói ph·ªï bi·∫øn
            if 'not found' in error_str.lower() or '404' in error_str:
                error_msg = f"‚ùå Sheet '{employee_id}' kh√¥ng t·ªìn t·∫°i trong file '{target_file.get('name')}'"
                _log(f"   üí° Vui l√≤ng t·∫°o sheet c√≥ t√™n '{employee_id}' trong file Google Sheet")
            elif '429' in error_str or 'quota' in error_str.lower():
                error_msg = "‚ùå V∆∞·ª£t quota API Google Sheets (rate limit)"
                _log(f"   üí° Vui l√≤ng ƒë·ª£i v√†i ph√∫t r·ªìi th·ª≠ l·∫°i")
            elif 'permission' in error_str.lower() or '403' in error_str:
                error_msg = "‚ùå Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p file Google Sheet"
                _log(f"   üí° Ki·ªÉm tra quy·ªÅn c·ªßa token v·ªõi file n√†y")
            
            return (False, error_msg)
    
    except TimeoutException:
        error_msg = f"‚ùå Timeout sau {timeout_seconds} gi√¢y khi c·∫≠p nh·∫≠t Google Sheet"
        _log(f"[TIMEOUT_ERROR] {error_msg}")
        _log(f"{'='*80}\n")
        return (False, error_msg)
    
    except Exception as e:
        error_msg = f"‚ùå L·ªói t·ªïng qu√°t: {str(e)}"
        import traceback
        try:
            _log(f"[CRITICAL_ERROR] {error_msg}")
            _log(f"   Type: {type(e).__name__}")
            _log(f"   Traceback:\n{traceback.format_exc()}")
            _log(f"{'='*80}\n")
        except Exception:
            try:
                print(f"‚ùå [CRITICAL_ERROR] {error_msg}", flush=True, file=sys.stderr)
            except Exception:
                pass
        return (False, error_msg)

# ============================================================================
# BATCH UPDATE FOR BULK APPROVAL - PERFORMANCE OPTIMIZATION
# ============================================================================

def batch_update_multi_attendances_sync(attendances_with_data, timeout_seconds=120):
    """
    BATCH UPDATE nhi·ªÅu attendance records trong 1 l·∫ßn g·ªçi API.
    Gom c√°c records theo spreadsheet (department + month) ƒë·ªÉ gi·∫£m s·ªë l·∫ßn g·ªçi API.

    Args:
        attendances_with_data: List of tuples (attendance, employee_team, employee_id, attendance_data)
        timeout_seconds: Timeout cho to√†n b·ªô qu√° tr√¨nh

    Returns:
        dict: {
            'success_ids': list of attendance IDs ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng,
            'failed': list of {'id': id, 'error': error_message},
            'total_api_calls': s·ªë l·∫ßn g·ªçi Google Sheets API
        }
    """
    import sys
    from datetime import datetime as dt

    def _log(msg):
        try:
            print(msg, flush=True, file=sys.stderr)
        except Exception:
            pass

    timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
    _log(f"\n{'='*80}")
    _log(f"üöÄ [BATCH_MULTI_SYNC] {timestamp} - B·∫Øt ƒë·∫ßu BATCH UPDATE cho {len(attendances_with_data)} records")
    _log(f"{'='*80}")

    result = {
        'success_ids': [],
        'failed': [],
        'total_api_calls': 0
    }

    if not attendances_with_data:
        _log("‚ö†Ô∏è [BATCH_MULTI_SYNC] Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ x·ª≠ l√Ω")
        return result

    try:
        # Kh·ªüi t·∫°o Google API m·ªôt l·∫ßn
        google_api = GoogleDriveAPI()
        if not google_api.ensure_valid_token():
            _log("‚ùå [BATCH_MULTI_SYNC] Token kh√¥ng h·ª£p l·ªá")
            for att, _, _, _ in attendances_with_data:
                result['failed'].append({'id': att.id, 'error': 'Token kh√¥ng h·ª£p l·ªá'})
            return result

        if not google_api.sheets_service:
            _log("‚ùå [BATCH_MULTI_SYNC] Sheets service kh√¥ng kh·∫£ d·ª•ng")
            for att, _, _, _ in attendances_with_data:
                result['failed'].append({'id': att.id, 'error': 'Sheets service kh√¥ng kh·∫£ d·ª•ng'})
            return result

        # STEP 1: Gom records theo (department, month) -> c√πng spreadsheet
        spreadsheet_groups = {}  # key: (team, month) -> list of records

        for attendance, employee_team, employee_id, attendance_data in attendances_with_data:
            date_str = attendance_data.get('date', '')
            if not date_str:
                result['failed'].append({'id': attendance.id, 'error': 'Thi·∫øu ng√†y'})
                continue

            try:
                attendance_dt = dt.strptime(date_str, "%Y-%m-%d")
                month_year = attendance_dt.strftime("%Y%m")
            except ValueError:
                result['failed'].append({'id': attendance.id, 'error': f'Ng√†y kh√¥ng h·ª£p l·ªá: {date_str}'})
                continue

            if not employee_team or employee_team == "Unknown":
                result['failed'].append({'id': attendance.id, 'error': 'Department kh√¥ng h·ª£p l·ªá'})
                continue

            if not employee_id:
                result['failed'].append({'id': attendance.id, 'error': 'Thi·∫øu employee_id'})
                continue

            key = (employee_team, month_year)
            if key not in spreadsheet_groups:
                spreadsheet_groups[key] = []

            spreadsheet_groups[key].append({
                'attendance': attendance,
                'employee_id': employee_id,
                'attendance_data': attendance_data
            })

        _log(f"üìä [BATCH_MULTI_SYNC] ƒê√£ gom th√†nh {len(spreadsheet_groups)} spreadsheet groups")
        for key, records in spreadsheet_groups.items():
            _log(f"   - {key[0]} ({key[1]}): {len(records)} records")

        # STEP 2: X·ª≠ l√Ω t·ª´ng spreadsheet group
        for (team, month), records in spreadsheet_groups.items():
            _log(f"\nüìÅ [BATCH_MULTI_SYNC] X·ª≠ l√Ω: {team} - {month} ({len(records)} records)")

            # T√¨m file spreadsheet
            try:
                target_file = google_api.find_team_timesheet(
                    folder_id=GOOGLE_DRIVE_FOLDER_ID,
                    team_name=team,
                    month_year=month
                )
            except Exception as e:
                _log(f"‚ùå [BATCH_MULTI_SYNC] L·ªói t√¨m file: {e}")
                for record in records:
                    result['failed'].append({'id': record['attendance'].id, 'error': f'L·ªói t√¨m file: {str(e)}'})
                continue

            if not target_file:
                _log(f"‚ùå [BATCH_MULTI_SYNC] Kh√¥ng t√¨m th·∫•y file cho {team} - {month}")
                for record in records:
                    result['failed'].append({'id': record['attendance'].id, 'error': f'Kh√¥ng t√¨m th·∫•y file cho {team}-{month}'})
                continue

            spreadsheet_id = target_file['id']
            _log(f"‚úÖ [BATCH_MULTI_SYNC] T√¨m th·∫•y file: {target_file.get('name')} (ID: {spreadsheet_id})")

            # L·∫•y danh s√°ch c√°c sheet c√≥ trong spreadsheet v√† populate cache
            available_sheets_set = set()
            try:
                spreadsheet_info = google_api.sheets_service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
                sheets_data = spreadsheet_info.get('sheets', [])
                available_sheets = [sheet['properties']['title'] for sheet in sheets_data]
                available_sheets_set = set(available_sheets)
                _log(f"   üìã C√°c sheet c√≥ trong file: {', '.join(available_sheets[:10])}{'...' if len(available_sheets) > 10 else ''}")

                # Populate cache ƒë·ªÉ tr√°nh g·ªçi API l·∫°i trong _read_sheet_values
                for sheet in sheets_data:
                    title = sheet['properties']['title']
                    sheet_id = sheet['properties']['sheetId']
                    cache_key = f"{spreadsheet_id}:{title}"
                    google_api._sheet_id_cache[cache_key] = sheet_id
            except Exception as sheet_err:
                _log(f"   ‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y danh s√°ch sheet: {sheet_err}")

            # STEP 3: Gom records theo employee (sheet) trong spreadsheet
            employee_groups = {}  # key: employee_id -> list of records
            for record in records:
                emp_id = str(record['employee_id'])
                if emp_id not in employee_groups:
                    employee_groups[emp_id] = []
                employee_groups[emp_id].append(record)

            # STEP 4: X·ª≠ l√Ω t·ª´ng employee sheet
            for employee_id, emp_records in employee_groups.items():
                _log(f"\n   üë§ Employee: {employee_id} ({len(emp_records)} records)")

                # Ki·ªÉm tra sheet c√≥ t·ªìn t·∫°i kh√¥ng tr∆∞·ªõc khi ƒë·ªçc
                if available_sheets_set and employee_id not in available_sheets_set:
                    _log(f"   ‚ö†Ô∏è Sheet '{employee_id}' kh√¥ng t·ªìn t·∫°i trong file. C·∫ßn t·∫°o sheet cho nh√¢n vi√™n n√†y.")
                    for record in emp_records:
                        result['failed'].append({'id': record['attendance'].id, 'error': f"Sheet '{employee_id}' kh√¥ng t·ªìn t·∫°i - c·∫ßn t·∫°o sheet"})
                    continue

                # ƒê·ªçc sheet m·ªôt l·∫ßn
                try:
                    rows = google_api._read_sheet_values(spreadsheet_id, employee_id)
                    if not rows:
                        _log(f"   ‚ö†Ô∏è Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c d·ªØ li·ªáu sheet {employee_id}")
                        for record in emp_records:
                            result['failed'].append({'id': record['attendance'].id, 'error': f'Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c sheet {employee_id}'})
                        continue
                except Exception as e:
                    _log(f"   ‚ùå L·ªói ƒë·ªçc sheet: {e}")
                    for record in emp_records:
                        result['failed'].append({'id': record['attendance'].id, 'error': f'L·ªói ƒë·ªçc sheet: {str(e)}'})
                    continue

                # Chu·∫©n b·ªã batch updates cho t·∫•t c·∫£ records c·ªßa employee n√†y
                all_updates = []
                records_for_update = []

                for record in emp_records:
                    att_data = record['attendance_data']
                    date_str = att_data.get('date', '')

                    # T√¨m row theo ng√†y
                    target_row = google_api._find_row_by_date(rows, date_str, 0)
                    if not target_row:
                        _log(f"      ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y row cho ng√†y {date_str}")
                        result['failed'].append({'id': record['attendance'].id, 'error': f'Kh√¥ng t√¨m th·∫•y row cho ng√†y {date_str}'})
                        continue

                    # Chu·∫©n b·ªã updates cho record n√†y
                    updates = _prepare_batch_updates_for_attendance(
                        employee_id, target_row, att_data
                    )

                    if updates:
                        all_updates.extend(updates)
                        records_for_update.append(record)
                        _log(f"      ‚úÖ Ng√†y {date_str} -> Row {target_row}: {len(updates)} updates")

                if not all_updates:
                    _log(f"   ‚ö†Ô∏è Kh√¥ng c√≥ updates cho employee {employee_id}")
                    continue

                # STEP 5: Th·ª±c hi·ªán batch update cho employee n√†y
                _log(f"   üöÄ Batch update {len(all_updates)} cells cho {employee_id}...")

                try:
                    success = google_api.batch_update_values_with_formatting(
                        spreadsheet_id, str(employee_id), all_updates
                    )
                    result['total_api_calls'] += 1

                    if success:
                        _log(f"   ‚úÖ Batch update th√†nh c√¥ng!")
                        for record in records_for_update:
                            result['success_ids'].append(record['attendance'].id)
                    else:
                        _log(f"   ‚ùå Batch update th·∫•t b·∫°i")
                        for record in records_for_update:
                            result['failed'].append({'id': record['attendance'].id, 'error': 'Batch update th·∫•t b·∫°i'})

                except Exception as e:
                    _log(f"   ‚ùå L·ªói batch update: {e}")
                    for record in records_for_update:
                        result['failed'].append({'id': record['attendance'].id, 'error': f'L·ªói batch update: {str(e)}'})

                # Th√™m delay nh·ªè gi·ªØa c√°c employee ƒë·ªÉ gi·∫£m t·∫£i API
                import time
                time.sleep(0.3)  # 300ms delay gi·ªØa m·ªói employee

        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        _log(f"\n{'='*80}")
        _log(f"üìä [BATCH_MULTI_SYNC_COMPLETE] {timestamp}")
        _log(f"   ‚úÖ Th√†nh c√¥ng: {len(result['success_ids'])} records")
        _log(f"   ‚ùå Th·∫•t b·∫°i: {len(result['failed'])} records")
        _log(f"   üì° T·ªïng API calls: {result['total_api_calls']}")
        _log(f"{'='*80}\n")

        return result

    except Exception as e:
        _log(f"‚ùå [BATCH_MULTI_SYNC] L·ªói t·ªïng qu√°t: {e}")
        import traceback
        _log(f"   Traceback: {traceback.format_exc()}")
        for att, _, _, _ in attendances_with_data:
            if att.id not in result['success_ids'] and not any(f['id'] == att.id for f in result['failed']):
                result['failed'].append({'id': att.id, 'error': f'L·ªói t·ªïng qu√°t: {str(e)}'})
        return result


def _prepare_batch_updates_for_attendance(sheet_name, row_index, attendance_data):
    """
    Chu·∫©n b·ªã danh s√°ch updates cho m·ªôt attendance record.
    Tr·∫£ v·ªÅ list of {'range': 'Sheet!A1', 'values': [[value]]}
    """
    updates = []

    # Column mapping c·ªë ƒë·ªãnh
    column_mapping = {
        'check_in': 'G',
        'check_out': 'K',
        'break_comp_total': 'E',
        'regular_work_hours': 'M',
        'overtime_before_22': 'N',
        'overtime_after_22': 'O',
        'leave_summary': 'P'
    }

    def hhmm_to_minutes(hhmm_str):
        try:
            if not hhmm_str or hhmm_str == '0:00':
                return 0
            if ':' in str(hhmm_str):
                h, m = str(hhmm_str).split(':')
                return int(h) * 60 + int(m)
            return 0
        except:
            return 0

    def minutes_to_hhmm(total_minutes):
        hours = total_minutes // 60
        minutes = total_minutes % 60
        return f"{hours}:{minutes:02d}"

    def add_update(field_key, value):
        # C√°c c·ªôt c·∫ßn ghi c·∫£ khi = 0:00
        always_write = {'regular_work_hours', 'overtime_before_22', 'overtime_after_22', 'break_comp_total'}

        if field_key not in always_write:
            if value is None or str(value).strip() in ['', '0', '0:00', '00:00']:
                return

        col_letter = column_mapping.get(field_key)
        if col_letter:
            a1 = f"{sheet_name}!{col_letter}{row_index}"
            updates.append({'range': a1, 'values': [[str(value or '0:00')]]})

    # Ki·ªÉm tra holiday type
    holiday_type = attendance_data.get('holiday_type')
    is_weekend = holiday_type == 'weekend'

    if is_weekend:
        attendance_data['regular_work_hours'] = '0:00'

    # T√≠nh t·ªïng ngh·ªâ + ƒë·ªëi ·ª©ng cho c·ªôt E
    break_time = attendance_data.get('break_time', '0:00')
    doi_ung_total = attendance_data.get('doi_ung_total', '0:00')
    break_minutes = hhmm_to_minutes(break_time)
    doi_ung_minutes = hhmm_to_minutes(doi_ung_total)
    total_break_comp = minutes_to_hhmm(break_minutes + doi_ung_minutes)

    # Th√™m c√°c updates
    add_update('check_in', attendance_data.get('check_in'))
    add_update('check_out', attendance_data.get('check_out'))
    add_update('break_comp_total', total_break_comp)
    add_update('regular_work_hours', attendance_data.get('regular_work_hours'))
    add_update('overtime_before_22', attendance_data.get('overtime_before_22'))
    add_update('overtime_after_22', attendance_data.get('overtime_after_22'))

    # Leave summary n·∫øu c√≥
    leave_summary = attendance_data.get('leave_summary')
    if leave_summary:
        add_update('leave_summary', leave_summary)

    return updates


# ============================================================================
# BATCH UPDATE FOR LEAVE REQUESTS - T·ªëi ∆∞u h√≥a ph√™ duy·ªát h√†ng lo·∫°t ƒë∆°n ngh·ªâ ph√©p
# ============================================================================

def batch_update_multi_leave_requests_sync(leave_requests_with_data, timeout_seconds=120):
    """
    BATCH UPDATE nhi·ªÅu leave request records trong 1 l·∫ßn g·ªçi API.
    Gom c√°c records theo spreadsheet (department + month) ƒë·ªÉ gi·∫£m s·ªë l·∫ßn g·ªçi API.

    Args:
        leave_requests_with_data: List of dicts with keys:
            - leave_request: LeaveRequest object
            - employee_team: department name
            - employee_id: employee ID string
            - leave_data: dict with date, leave_summary, etc.
            - original_status: status before approval attempt
        timeout_seconds: Timeout cho to√†n b·ªô qu√° tr√¨nh

    Returns:
        dict: {
            'success_ids': list of leave_request IDs ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng,
            'failed': list of {'id': id, 'error': error_message},
            'total_api_calls': s·ªë l·∫ßn g·ªçi Google Sheets API
        }
    """
    import sys
    from datetime import datetime as dt

    def _log(msg):
        try:
            print(msg, flush=True, file=sys.stderr)
        except Exception:
            pass

    timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
    _log(f"\n{'='*80}")
    _log(f"üöÄ [BATCH_LEAVE_SYNC] {timestamp} - B·∫Øt ƒë·∫ßu BATCH UPDATE cho {len(leave_requests_with_data)} leave requests")
    _log(f"{'='*80}")

    result = {
        'success_ids': [],
        'failed': [],
        'total_api_calls': 0
    }

    if not leave_requests_with_data:
        _log("‚ö†Ô∏è [BATCH_LEAVE_SYNC] Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ x·ª≠ l√Ω")
        return result

    try:
        # Kh·ªüi t·∫°o Google API m·ªôt l·∫ßn
        google_api = GoogleDriveAPI()
        if not google_api.ensure_valid_token():
            _log("‚ùå [BATCH_LEAVE_SYNC] Token kh√¥ng h·ª£p l·ªá")
            for record in leave_requests_with_data:
                result['failed'].append({'id': record['leave_request'].id, 'error': 'Token kh√¥ng h·ª£p l·ªá'})
            return result

        if not google_api.sheets_service:
            _log("‚ùå [BATCH_LEAVE_SYNC] Sheets service kh√¥ng kh·∫£ d·ª•ng")
            for record in leave_requests_with_data:
                result['failed'].append({'id': record['leave_request'].id, 'error': 'Sheets service kh√¥ng kh·∫£ d·ª•ng'})
            return result

        # Import process_leave_requests_for_excel ƒë·ªÉ ph√¢n b·ªï ng√†y ngh·ªâ
        from utils.excel_leave_processor import process_leave_requests_for_excel

        # STEP 1: X·ª≠ l√Ω t·ª´ng leave request v√† gom theo (department, month, employee)
        # Key: (team, month, employee_id) -> list of daily updates
        spreadsheet_groups = {}  # key: (team, month) -> {employee_id: list of updates}

        for record in leave_requests_with_data:
            leave_request = record['leave_request']
            employee_team = record['employee_team']
            employee_id = record['employee_id']

            if not employee_team or employee_team == "Unknown":
                result['failed'].append({'id': leave_request.id, 'error': 'Department kh√¥ng h·ª£p l·ªá'})
                continue

            if not employee_id:
                result['failed'].append({'id': leave_request.id, 'error': 'Thi·∫øu employee_id'})
                continue

            # Ph√¢n b·ªï ng√†y ngh·ªâ cho leave request n√†y
            try:
                daily_leaves = process_leave_requests_for_excel([leave_request])
            except Exception as e:
                _log(f"   ‚ö†Ô∏è L·ªói ph√¢n b·ªï ng√†y ngh·ªâ cho ƒë∆°n #{leave_request.id}: {e}")
                result['failed'].append({'id': leave_request.id, 'error': f'L·ªói ph√¢n b·ªï ng√†y ngh·ªâ: {str(e)}'})
                continue

            if not daily_leaves:
                result['failed'].append({'id': leave_request.id, 'error': 'Kh√¥ng th·ªÉ ph√¢n b·ªï ng√†y ngh·ªâ'})
                continue

            # Gom t·ª´ng ng√†y v√†o groups
            for day_data in daily_leaves:
                date_obj = day_data['date']
                date_str = date_obj.strftime('%Y-%m-%d')
                month_year = date_obj.strftime("%Y%m")

                # T·∫°o leave_summary cho ng√†y n√†y
                leave_type_info = day_data.get('leave_type', {})
                days_value = day_data.get('fractional_days', 1.0)

                # Format s·ªë ng√†y
                if days_value <= 0:
                    day_text = "0"
                elif abs(days_value - round(days_value)) < 1e-9:
                    day_text = str(int(round(days_value)))
                else:
                    day_text = f"{days_value:.1f}".rstrip('0').rstrip('.')

                type_name = str(leave_type_info.get('name') or '').strip() or "Ngh·ªâ"
                special_type = leave_type_info.get('special_type')
                if special_type:
                    type_name += f" ({special_type})"

                summary_text = f"{type_name}: {day_text} ng√†y"
                is_full_day = abs(days_value - 1.0) < 1e-9

                # Detect memo-only leave types
                type_name_lower = type_name.lower()
                is_memo_leave = "ngh·ªâ l·ªÖ nh·∫≠t" in type_name_lower or "scope" in type_name_lower

                # L·∫•y th√¥ng tin th·ªùi gian
                leave_start_time_str = None
                leave_end_time_str = None
                if day_data.get('start_time'):
                    leave_start_time_str = day_data.get('start_time').strftime('%H:%M')
                if day_data.get('end_time'):
                    leave_end_time_str = day_data.get('end_time').strftime('%H:%M')

                # L·∫•y shift_code
                effective_shift_code = leave_request.shift_code
                if not effective_shift_code:
                    user = leave_request.user
                    if user:
                        effective_shift_code = getattr(user, 'shift_code', None)
                if not effective_shift_code:
                    effective_shift_code = '1'

                leave_data = {
                    'date': date_str,
                    'leave_summary': summary_text,
                    'is_leave': True,
                    'full_leave_day': is_full_day,
                    'leave_fraction_days': days_value,
                    'leave_start_time': leave_start_time_str,
                    'leave_end_time': leave_end_time_str,
                    'shift_code': effective_shift_code,
                    'memo_only': is_memo_leave,
                    'leave_request_id': leave_request.id  # ƒê·ªÉ track success/fail
                }

                key = (employee_team, month_year)
                if key not in spreadsheet_groups:
                    spreadsheet_groups[key] = {}

                if employee_id not in spreadsheet_groups[key]:
                    spreadsheet_groups[key][employee_id] = []

                spreadsheet_groups[key][employee_id].append(leave_data)

        _log(f"üìä [BATCH_LEAVE_SYNC] ƒê√£ gom th√†nh {len(spreadsheet_groups)} spreadsheet groups")
        for key, employees in spreadsheet_groups.items():
            total_updates = sum(len(updates) for updates in employees.values())
            _log(f"   - {key[0]} ({key[1]}): {len(employees)} employees, {total_updates} updates")

        # Track which leave_request_ids have been processed successfully
        successful_leave_ids = set()
        failed_leave_ids = {}  # id -> error_msg

        # STEP 2: X·ª≠ l√Ω t·ª´ng spreadsheet group
        for (team, month), employee_groups in spreadsheet_groups.items():
            _log(f"\nüìÅ [BATCH_LEAVE_SYNC] X·ª≠ l√Ω: {team} - {month}")

            # T√¨m file spreadsheet
            try:
                target_file = google_api.find_team_timesheet(
                    folder_id=GOOGLE_DRIVE_FOLDER_ID,
                    team_name=team,
                    month_year=month
                )
            except Exception as e:
                _log(f"‚ùå [BATCH_LEAVE_SYNC] L·ªói t√¨m file: {e}")
                for emp_id, updates in employee_groups.items():
                    for upd in updates:
                        failed_leave_ids[upd['leave_request_id']] = f'L·ªói t√¨m file: {str(e)}'
                continue

            if not target_file:
                _log(f"‚ùå [BATCH_LEAVE_SYNC] Kh√¥ng t√¨m th·∫•y file cho {team} - {month}")
                for emp_id, updates in employee_groups.items():
                    for upd in updates:
                        failed_leave_ids[upd['leave_request_id']] = f'Kh√¥ng t√¨m th·∫•y file cho {team}-{month}'
                continue

            spreadsheet_id = target_file['id']
            _log(f"‚úÖ [BATCH_LEAVE_SYNC] T√¨m th·∫•y file: {target_file.get('name')} (ID: {spreadsheet_id})")

            # L·∫•y danh s√°ch c√°c sheet c√≥ trong spreadsheet ƒë·ªÉ debug v√† populate cache
            available_sheets = []
            available_sheets_set = set()
            try:
                spreadsheet_info = google_api.sheets_service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
                sheets_data = spreadsheet_info.get('sheets', [])
                available_sheets = [sheet['properties']['title'] for sheet in sheets_data]
                available_sheets_set = set(available_sheets)
                _log(f"   üìã C√°c sheet c√≥ trong file: {', '.join(available_sheets[:10])}{'...' if len(available_sheets) > 10 else ''}")

                # Populate cache ƒë·ªÉ tr√°nh g·ªçi API l·∫°i trong _read_sheet_values
                for sheet in sheets_data:
                    title = sheet['properties']['title']
                    sheet_id = sheet['properties']['sheetId']
                    cache_key = f"{spreadsheet_id}:{title}"
                    google_api._sheet_id_cache[cache_key] = sheet_id
            except Exception as sheet_err:
                _log(f"   ‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y danh s√°ch sheet: {sheet_err}")

            # STEP 3: X·ª≠ l√Ω t·ª´ng employee sheet
            for employee_id, emp_updates in employee_groups.items():
                _log(f"\n   üë§ Employee: {employee_id} ({len(emp_updates)} updates)")

                # Ki·ªÉm tra sheet c√≥ t·ªìn t·∫°i kh√¥ng tr∆∞·ªõc khi ƒë·ªçc
                employee_id_str = str(employee_id)
                if available_sheets_set and employee_id_str not in available_sheets_set:
                    _log(f"   ‚ö†Ô∏è Sheet '{employee_id_str}' kh√¥ng t·ªìn t·∫°i trong file. C·∫ßn t·∫°o sheet cho nh√¢n vi√™n n√†y.")
                    for upd in emp_updates:
                        failed_leave_ids[upd['leave_request_id']] = f"Sheet '{employee_id_str}' kh√¥ng t·ªìn t·∫°i - c·∫ßn t·∫°o sheet"
                    continue

                # ƒê·ªçc sheet m·ªôt l·∫ßn
                try:
                    rows = google_api._read_sheet_values(spreadsheet_id, employee_id_str)
                    if not rows:
                        _log(f"   ‚ö†Ô∏è Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c d·ªØ li·ªáu sheet {employee_id}")
                        for upd in emp_updates:
                            failed_leave_ids[upd['leave_request_id']] = f'Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c sheet {employee_id}'
                        continue
                except Exception as e:
                    _log(f"   ‚ùå L·ªói ƒë·ªçc sheet: {e}")
                    for upd in emp_updates:
                        failed_leave_ids[upd['leave_request_id']] = f'L·ªói ƒë·ªçc sheet: {str(e)}'
                    continue

                # Chu·∫©n b·ªã batch updates
                all_updates = []
                updates_mapping = []  # Track which leave_request_id each update belongs to

                for leave_data in emp_updates:
                    date_str = leave_data.get('date', '')

                    # T√¨m row theo ng√†y
                    target_row = google_api._find_row_by_date(rows, date_str, 0)
                    if not target_row:
                        _log(f"      ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y row cho ng√†y {date_str}")
                        failed_leave_ids[leave_data['leave_request_id']] = f'Kh√¥ng t√¨m th·∫•y row cho ng√†y {date_str}'
                        continue

                    # Chu·∫©n b·ªã updates cho leave n√†y
                    updates = _prepare_batch_updates_for_leave(
                        employee_id, target_row, leave_data
                    )

                    if updates:
                        all_updates.extend(updates)
                        updates_mapping.append({
                            'leave_request_id': leave_data['leave_request_id'],
                            'update_count': len(updates)
                        })
                        _log(f"      ‚úÖ Ng√†y {date_str} -> Row {target_row}: {len(updates)} updates")

                if not all_updates:
                    _log(f"   ‚ö†Ô∏è Kh√¥ng c√≥ updates cho employee {employee_id}")
                    continue

                # STEP 4: Th·ª±c hi·ªán batch update cho employee n√†y
                _log(f"   üöÄ Batch update {len(all_updates)} cells cho {employee_id}...")

                try:
                    success = google_api.batch_update_values_with_formatting(
                        spreadsheet_id, str(employee_id), all_updates
                    )
                    result['total_api_calls'] += 1

                    if success:
                        _log(f"   ‚úÖ Batch update th√†nh c√¥ng!")
                        for mapping in updates_mapping:
                            successful_leave_ids.add(mapping['leave_request_id'])
                    else:
                        _log(f"   ‚ùå Batch update th·∫•t b·∫°i")
                        for mapping in updates_mapping:
                            failed_leave_ids[mapping['leave_request_id']] = 'Batch update th·∫•t b·∫°i'

                except Exception as e:
                    _log(f"   ‚ùå L·ªói batch update: {e}")
                    for mapping in updates_mapping:
                        failed_leave_ids[mapping['leave_request_id']] = f'L·ªói batch update: {str(e)}'

        # Build final result
        for record in leave_requests_with_data:
            lr_id = record['leave_request'].id
            if lr_id in successful_leave_ids and lr_id not in failed_leave_ids:
                result['success_ids'].append(lr_id)
            elif lr_id in failed_leave_ids:
                result['failed'].append({'id': lr_id, 'error': failed_leave_ids[lr_id]})
            else:
                # Not processed at all (shouldn't happen, but just in case)
                result['failed'].append({'id': lr_id, 'error': 'Kh√¥ng ƒë∆∞·ª£c x·ª≠ l√Ω'})

        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        _log(f"\n{'='*80}")
        _log(f"üìä [BATCH_LEAVE_SYNC_COMPLETE] {timestamp}")
        _log(f"   ‚úÖ Th√†nh c√¥ng: {len(result['success_ids'])} leave requests")
        _log(f"   ‚ùå Th·∫•t b·∫°i: {len(result['failed'])} leave requests")
        _log(f"   üì° T·ªïng API calls: {result['total_api_calls']}")
        _log(f"{'='*80}\n")

        return result

    except Exception as e:
        _log(f"‚ùå [BATCH_LEAVE_SYNC] L·ªói t·ªïng qu√°t: {e}")
        import traceback
        _log(f"   Traceback: {traceback.format_exc()}")
        for record in leave_requests_with_data:
            lr_id = record['leave_request'].id
            if lr_id not in result['success_ids'] and not any(f['id'] == lr_id for f in result['failed']):
                result['failed'].append({'id': lr_id, 'error': f'L·ªói t·ªïng qu√°t: {str(e)}'})
        return result


def _prepare_batch_updates_for_leave(sheet_name, row_index, leave_data):
    """
    Chu·∫©n b·ªã danh s√°ch updates cho m·ªôt leave request record (1 ng√†y).
    Tr·∫£ v·ªÅ list of {'range': 'Sheet!P5', 'values': [['value']]}

    Args:
        sheet_name: Employee ID (t√™n sheet)
        row_index: S·ªë d√≤ng trong sheet (1-based)
        leave_data: Dict ch·ª©a th√¥ng tin ng√†y ngh·ªâ

    Returns:
        list: Danh s√°ch updates cho Google Sheets batchUpdate
    """
    updates = []

    # Column mapping
    # P = Leave summary/memo
    # G = Check-in time (n·∫øu ngh·ªâ c·∫£ ng√†y th√¨ clear ho·∫∑c set gi√° tr·ªã ƒë·∫∑c bi·ªát)
    # K = Check-out time
    # M = Regular work hours
    # E = Break + Comp time total

    leave_summary = leave_data.get('leave_summary', '')
    is_full_day = leave_data.get('full_leave_day', False)
    is_memo_only = leave_data.get('memo_only', False)

    # Lu√¥n c·∫≠p nh·∫≠t c·ªôt P v·ªõi leave summary
    if leave_summary:
        a1 = f"{sheet_name}!P{row_index}"
        updates.append({'range': a1, 'values': [[leave_summary]]})

    # N·∫øu l√† memo_only (ngh·ªâ l·ªÖ Nh·∫≠t, Scope...), ch·ªâ c·∫≠p nh·∫≠t c·ªôt P
    if is_memo_only:
        return updates

    # N·∫øu ngh·ªâ c·∫£ ng√†y, clear c√°c c·ªôt th·ªùi gian
    if is_full_day:
        # Clear check-in (G)
        updates.append({'range': f"{sheet_name}!G{row_index}", 'values': [['']]})
        # Clear check-out (K)
        updates.append({'range': f"{sheet_name}!K{row_index}", 'values': [['']]})
        # Clear regular work hours (M)
        updates.append({'range': f"{sheet_name}!M{row_index}", 'values': [['0:00']]})
        # Clear overtime before 22h (N)
        updates.append({'range': f"{sheet_name}!N{row_index}", 'values': [['0:00']]})
        # Clear overtime after 22h (O)
        updates.append({'range': f"{sheet_name}!O{row_index}", 'values': [['0:00']]})

    return updates


def update_leave_sheet_sync(leave_request, timeout_seconds=60):
    """
    SYNCHRONOUS Google Sheet update function for LEAVE REQUESTS
    D√πng cho ADMIN approval ƒë·ªÉ ƒë·∫£m b·∫£o upload th√†nh c√¥ng TR∆Ø·ªöC KHI commit database
    
    Returns:
        tuple: (success: bool, error_message: str or None)
    """
    import sys
    from datetime import datetime as dt, timedelta
    import signal
    
    def _log(msg):
        """Helper function for logging"""
        try:
            print(msg, flush=True, file=sys.stderr)
        except Exception:
            pass
    
    # Handler cho timeout
    class TimeoutException(Exception):
        pass
    
    def timeout_handler(signum, frame):
        raise TimeoutException("Google Sheet update timeout")
    
    timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
    _log(f"\n{'='*80}")
    _log(f"üîµ [SYNC_LEAVE_SHEET_UPDATE] {timestamp} - B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t ƒê·ªíNG B·ªò ƒê∆°n Ngh·ªâ Ph√©p")
    _log(f"   Leave Request ID: {leave_request.id}")
    _log(f"   Employee: {leave_request.employee_name}")
    _log(f"{'='*80}")
    
    try:
        # L·∫•y app context
        import sys
        current_module = sys.modules[__name__]
        flask_app = getattr(current_module, 'app', None)
        
        if flask_app is None:
            error_msg = "‚ùå Flask app ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o"
            _log(f"[APP_ERROR] {error_msg}")
            return (False, error_msg)
        
        with flask_app.app_context():
            # Kh·ªüi t·∫°o Google API
            try:
                google_api = GoogleDriveAPI()
            except Exception as api_init_err:
                error_msg = f"‚ùå L·ªói kh·ªüi t·∫°o GoogleDriveAPI: {str(api_init_err)}"
                _log(f"[API_ERROR] {error_msg}")
                return (False, error_msg)
            
            # Ki·ªÉm tra token
            try:
                token_valid = google_api.ensure_valid_token()
                if not token_valid:
                    error_msg = "‚ùå Token Google API kh√¥ng h·ª£p l·ªá"
                    _log(f"[TOKEN_ERROR] {error_msg}")
                    return (False, error_msg)
            except Exception as token_err:
                error_msg = f"‚ùå L·ªói ki·ªÉm tra token: {str(token_err)}"
                _log(f"[TOKEN_ERROR] {error_msg}")
                return (False, error_msg)
            
            # L·∫•y th√¥ng tin user ƒë·ªÉ bi·∫øt team/department
            user = leave_request.user
            if not user:
                 # Fallback logic n·∫øu user relationship ch∆∞a load ho·∫∑c l·ªói
                 user = db.session.get(User, leave_request.user_id)
            
            if not user:
                error_msg = f"‚ùå Kh√¥ng t√¨m th·∫•y user ID {leave_request.user_id}"
                _log(f"[USER_ERROR] {error_msg}")
                return (False, error_msg)
                
            employee_id = user.employee_id
            employee_team = user.department
            
            if not employee_id:
                error_msg = f"‚ùå User {user.name} kh√¥ng c√≥ employee_id"
                _log(f"[VALIDATION_ERROR] {error_msg}")
                return (False, error_msg)
            
            if not employee_team or employee_team == "Unknown":
                error_msg = f"‚ùå User {user.name} ch∆∞a c·∫≠p nh·∫≠t Department (Team)"
                _log(f"[VALIDATION_ERROR] {error_msg}")
                return (False, error_msg)
                
            # X√°c ƒë·ªãnh kho·∫£ng th·ªùi gian ngh·ªâ
            start_date = leave_request.get_leave_from_datetime().date()
            end_date = leave_request.get_leave_to_datetime().date()
            
            # --- REFACTORED LOGIC START ---
            # S·ª≠ d·ª•ng logic ph√¢n b·ªï th√¥ng minh t·ª´ utils.excel_leave_processor
            # ƒë·ªÉ ƒë·∫£m b·∫£o chia ƒë√∫ng lo·∫°i ngh·ªâ cho t·ª´ng ng√†y (v√≠ d·ª•: ng√†y 1 ngh·ªâ KL, ng√†y 2 ngh·ªâ ƒêB...)
            from utils.excel_leave_processor import process_leave_requests_for_excel
            
            # L·∫•y danh s√°ch ph√¢n b·ªï chi ti·∫øt cho t·ª´ng ng√†y
            daily_leaves = process_leave_requests_for_excel([leave_request])
            
            if not daily_leaves:
                _log(f"‚ö†Ô∏è Kh√¥ng th·ªÉ ph√¢n b·ªï ng√†y ngh·ªâ cho ƒë∆°n #{leave_request.id}")
                return (False, "L·ªói ph√¢n b·ªï ng√†y ngh·ªâ")

            total_days = len(daily_leaves)
            processed_count = 0
            success_count = 0

            for day_data in daily_leaves:
                processed_count += 1
                date_obj = day_data['date'] # date object
                date_str = date_obj.strftime('%Y-%m-%d')
                
                _log(f"üëâ [DATE_PROCESS] X·ª≠ l√Ω ng√†y {date_str} ({processed_count}/{total_days})")

                # Format text hi·ªÉn th·ªã cho ng√†y n√†y
                leave_type_info = day_data.get('leave_type', {})
                days_value = day_data.get('fractional_days', 1.0)
                
                # Format s·ªë ng√†y (1, 0.5...)
                if days_value <= 0:
                    day_text = "0"
                elif abs(days_value - round(days_value)) < 1e-9:
                    day_text = str(int(round(days_value)))
                else:
                    day_text = f"{days_value:.1f}".rstrip('0').rstrip('.')

                type_name = str(leave_type_info.get('name') or '').strip() or "Ngh·ªâ"
                special_type = leave_type_info.get('special_type')
                if special_type:
                    type_name += f" ({special_type})"

                summary_text = f"{type_name}: {day_text} ng√†y"
                
                # X√°c ƒë·ªãnh full day
                is_full_day = abs(days_value - 1.0) < 1e-9
                
                # L·∫•y shift_code: ∆∞u ti√™n t·ª´ leave_request, fallback v·ªÅ user.shift_code
                effective_shift_code = leave_request.shift_code
                if not effective_shift_code:
                    effective_shift_code = getattr(user, 'shift_code', None)
                if not effective_shift_code:
                    effective_shift_code = '1'  # Default fallback
                
                # L·∫•y leave_start_time: ∆∞u ti√™n t·ª´ day_data, fallback v·ªÅ leave_request
                leave_start_time_str = None
                if day_data.get('start_time'):
                    leave_start_time_str = day_data.get('start_time').strftime('%H:%M')
                else:
                    # Fallback: l·∫•y t·ª´ leave_request
                    try:
                        leave_start_time_str = leave_request.get_leave_from_datetime().strftime('%H:%M')
                    except Exception:
                        pass
                
                # L·∫•y leave_end_time t∆∞∆°ng t·ª±
                leave_end_time_str = None
                if day_data.get('end_time'):
                    leave_end_time_str = day_data.get('end_time').strftime('%H:%M')
                else:
                    try:
                        leave_end_time_str = leave_request.get_leave_to_datetime().strftime('%H:%M')
                    except Exception:
                        pass
                
                _log(f"   üìä [HALF_DAY_INFO] shift_code={effective_shift_code}, leave_start={leave_start_time_str}, leave_end={leave_end_time_str}")
                
                # Detect Japanese/Scope Holiday to avoid clearing columns
                type_name_lower = type_name.lower()
                is_memo_leave = False
                if "ngh·ªâ l·ªÖ nh·∫≠t" in type_name_lower or "scope" in type_name_lower:
                    is_memo_leave = True
                    _log(f"   ‚ÑπÔ∏è Ph√°t hi·ªán ngh·ªâ ƒë·∫∑c bi·ªát (L·ªÖ Nh·∫≠t/Scope) -> Ch·∫ø ƒë·ªô Memo Only (Kh√¥ng x√≥a/ghi ƒë√® c·ªôt th·ªùi gian)")

                # Chu·∫©n b·ªã data cho ng√†y n√†y
                sheet_data = {
                    'date': date_str,
                    'user_name': user.name,
                    'leave_summary': summary_text,
                    'approved_by': leave_request.admin_signer.name if leave_request.admin_signer else 'ADMIN',
                    'approved_at': dt.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'is_leave': True,
                    'full_leave_day': is_full_day,
                    'leave_fraction_days': days_value,
                    # Truy·ªÅn th√™m th√¥ng tin th·ªùi gian ngh·ªâ ƒë·ªÉ Google Sheet ph√¢n bi·ªát ngh·ªâ s√°ng/chi·ªÅu
                    'leave_start_time': leave_start_time_str,
                    'leave_end_time': leave_end_time_str,
                    'shift_code': effective_shift_code,
                    'memo_only': is_memo_leave
                }
                
                attendance_month = date_obj.strftime("%Y%m")
                
                try:
                    target_file = google_api.find_team_timesheet(
                        folder_id=GOOGLE_DRIVE_FOLDER_ID,
                        team_name=employee_team,
                        month_year=attendance_month
                    )
                    
                    if not target_file:
                        _log(f"   ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file sheet cho team {employee_team} th√°ng {attendance_month}")
                        error_msg = f"Kh√¥ng t√¨m th·∫•y file Sheet th√°ng {attendance_month}"
                        continue 

                    # G·ªçi update
                    success = google_api.update_timesheet_for_attendance(
                        spreadsheet_id=target_file['id'],
                        sheet_name=str(employee_id),
                        attendance_data=sheet_data
                    )
                    
                    if success:
                        success_count += 1
                    else:
                        _log(f"   ‚ùå Update th·∫•t b·∫°i cho ng√†y {date_str}")
                        
                except Exception as loop_err:
                    _log(f"   ‚ùå L·ªói x·ª≠ l√Ω ng√†y {date_str}: {loop_err}")
                
            _log(f"‚úÖ [SYNC_LEAVE_FINISH] Ho√†n t·∫•t. Th√†nh c√¥ng {success_count}/{total_days} ng√†y.")
            
            if success_count > 0:
                return (True, None) # Coi nh∆∞ th√†nh c√¥ng n·∫øu update ƒë∆∞·ª£c √≠t nh·∫•t 1 ng√†y
            else:
                return (False, "Kh√¥ng c·∫≠p nh·∫≠t ƒë∆∞·ª£c ng√†y n√†o v√†o Google Sheet")

    except Exception as e:
        error_msg = f"‚ùå L·ªói t·ªïng qu√°t Sync Leave: {str(e)}"
        import traceback
        _log(f"[CRITICAL_ERROR] {error_msg}\n{traceback.format_exc()}")
        return (False, error_msg)


# Ch·ªâ ki·ªÉm tra khi ch·∫°y tr·ª±c ti·∫øp file n√†y
if __name__ == '__main__':
    check_and_install_dependencies()

# B·ªçc stdout/stderr ch·ªâ khi c√≥ thu·ªôc t√≠nh buffer (tr√°nh l·ªói trong IDLE, m·ªôt s·ªë IDE)
try:
    if hasattr(sys.stdout, "buffer"):
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    if hasattr(sys.stderr, "buffer"):
        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')
except Exception:
    # N·∫øu c√≥ l·ªói th√¨ gi·ªØ nguy√™n stdout/stderr m·∫∑c ƒë·ªãnh
    pass

# M·ªôt s·ªë m√¥i tr∆∞·ªùng (v√≠ d·ª• Werkzeug reloader) c√≥ th·ªÉ ƒë√≥ng stdout/stderr t·∫°m th·ªùi.
# C√°c l·ªánh print trong app c√≥ th·ªÉ n√©m ValueError: I/O operation on closed file.
# ƒê·ªÉ tr√°nh crash 500, b·ªçc print b·∫±ng h√†m an to√†n.

# Pre-cache references ƒë·ªÉ tr√°nh import/access g√¢y l·ªói
import builtins as _builtins
_sys_module = sys

def _safe_print(*args, **kwargs):
    """Ultra-safe print wrapper. Silently ignores ALL errors to prevent 500."""
    try:
        # Ki·ªÉm tra stream validity
        def is_valid(stream):
            try:
                return (stream is not None and 
                        hasattr(stream, 'write') and 
                        hasattr(stream, 'flush') and
                        not stream.closed)
            except:
                return False
        
        # T√¨m stream h·ª£p l·ªá
        target = kwargs.get('file', _sys_module.stdout)
        stream = None
        
        if is_valid(target):
            stream = target
        elif is_valid(_sys_module.stdout):
            stream = _sys_module.stdout
        elif is_valid(_sys_module.stderr):
            stream = _sys_module.stderr
        
        # Kh√¥ng c√≥ stream h·ª£p l·ªá -> b·ªè qua
        if stream is None:
            return
        
        # Update kwargs
        kwargs['file'] = stream
        
        # Test flush tr∆∞·ªõc khi d√πng
        if kwargs.get('flush', False):
            try:
                stream.flush()
            except:
                kwargs['flush'] = False
        
        # G·ªçi print
        _builtins.print(*args, **kwargs)
    except:
        # B·∫§T K·ª≤ L·ªñI N√ÄO -> im l·∫∑ng ho√†n to√†n
        pass

print = _safe_print

# Import c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt
try:
    from flask import Flask, render_template, request, jsonify, redirect, url_for, flash, session, get_flashed_messages, abort, send_file, make_response
    from openpyxl import Workbook, load_workbook
    from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
    from openpyxl.utils import get_column_letter
    from flask_login import LoginManager, login_user, login_required, logout_user, current_user
    from flask_wtf import CSRFProtect
    from flask_wtf.csrf import generate_csrf
    from werkzeug.security import generate_password_hash, check_password_hash
except ImportError as e:
    if __name__ == '__main__':
        print(f"\n‚ùå L·ªói: Kh√¥ng th·ªÉ import th∆∞ vi·ªán. {e}")
        print("\nVui l√≤ng c√†i ƒë·∫∑t dependencies:")
        if os.path.exists('requirements.txt'):
            print(f"   {sys.executable} -m pip install -r requirements.txt")
        else:
            print(f"   {sys.executable} -m pip install flask openpyxl flask-login flask-wtf werkzeug sqlalchemy flask-migrate")
        print("\nHo·∫∑c ch·∫°y l·∫°i app.py ƒë·ªÉ t·ª± ƒë·ªông c√†i ƒë·∫∑t.")
        sys.exit(1)
    else:
        raise
from datetime import datetime, timedelta, time, date
import os
import json
import uuid
from functools import wraps
from config import config
from sqlalchemy.orm import joinedload, selectinload
from sqlalchemy import func, text
import re
# import pickle  # Security improvement: Removed pickle
import time as time_module

# Import Google API libraries
try:
    from google.oauth2.credentials import Credentials
    from google_auth_oauthlib.flow import InstalledAppFlow
    from google.auth.transport.requests import Request as GoogleRequest
    from googleapiclient.discovery import build
    from googleapiclient.http import MediaFileUpload, MediaIoBaseDownload
    GOOGLE_API_AVAILABLE = True
except ImportError:
    GOOGLE_API_AVAILABLE = False
    print("Google API libraries not available. Running in demo mode.")

# Ph·∫°m vi quy·ªÅn truy c·∫≠p Google API
GOOGLE_SCOPES = [
    'https://www.googleapis.com/auth/drive',
    'https://www.googleapis.com/auth/spreadsheets'
]

# ID folder Google Drive
GOOGLE_DRIVE_FOLDER_ID = '1dHF_x6fCJEs9krtmaZPabBIWiTr5xpB3'

# Ch√≠nh s√°ch: m·∫π c√≥ con < 12 th√°ng ƒë∆∞·ª£c t√≠nh ƒë·ªß c√¥ng khi l√†m 7h/ng√†y (ch·ªâ √°p d·ª•ng ng√†y th∆∞·ªùng, kh√¥ng √°p d·ª•ng cu·ªëi tu·∫ßn/l·ªÖ)
def is_user_on_maternity_flex(user, target_date=None):
    """Check if user is in maternity flex window (7h required instead of 8h)."""
    if not user:
        return False
    if not getattr(user, 'is_maternity_flex', False):
        return False
    if target_date is None:
        target_date = datetime.utcnow().date()
    # Ki·ªÉm tra ng√†y b·∫Øt ƒë·∫ßu (n·∫øu c√≥)
    flex_from = getattr(user, 'maternity_flex_from', None)
    if flex_from:
        try:
            from_date = flex_from if hasattr(flex_from, 'isoformat') and not isinstance(flex_from, str) else None
            if not from_date and isinstance(flex_from, date):
                from_date = flex_from
            if from_date and target_date < from_date:
                return False
        except Exception:
            pass  # n·∫øu l·ªói parse, b·ªè qua from_date ƒë·ªÉ kh√¥ng ch·∫∑n quy·ªÅn l·ª£i
    until = getattr(user, 'maternity_flex_until', None)
    if until:
        try:
            until_date = until if hasattr(until, 'isoformat') and not isinstance(until, str) else None
            if not until_date and isinstance(until, date):
                until_date = until
            if until_date:
                return target_date <= until_date
        except Exception:
            return True  # N·∫øu c√≥ l·ªói parse th√¨ v·∫´n ∆∞u ti√™n cho user
    return True


def get_required_daily_hours(user, target_date=None, holiday_type=None, shift_code=None):
    """
    Return required working hours for a given user/date.
    - Default: 8h
    - Maternity flex: hi·ªÉn th·ªã ƒë·ªß 8h (ch·ªâ √°p d·ª•ng ca 1-4, ng√†y th∆∞·ªùng)
    - Holidays gi·ªØ nguy√™n 8h
    """
    base_hours = 8.0
    # Kh√¥ng gi·∫£m gi·ªù n·∫øu kh√¥ng ph·∫£i ng√†y th∆∞·ªùng
    if holiday_type in ('vietnamese_holiday', 'weekend', 'japanese_holiday'):
        return base_hours
    # V·ªõi ch√≠nh s√°ch m·∫π <12 th√°ng: ch·ªâ √°p d·ª•ng cho ca 1-4 ng√†y th∆∞·ªùng
    if shift_code in ('1', '2', '3', '4') and is_user_on_maternity_flex(user, target_date):
        return 8.0
    return base_hours

from collections import defaultdict
import secrets
from flask_migrate import Migrate
from jinja2 import Template
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.utils import ImageReader
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.lib import colors
import base64
import traceback
from reportlab.platypus import Table, TableStyle, Paragraph
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import mm
from reportlab.pdfbase.pdfmetrics import registerFont
import zipfile
import webbrowser
import subprocess
import platform
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException
from webdriver_manager.chrome import ChromeDriverManager


# License / activation
APP_LICENSE_KEY = os.environ.get('APP_LICENSE_KEY', 'LIC-W8B61JUL-F7OD')
# Endpoint verify license online (License Manager Pro)
# C√≥ th·ªÉ override b·∫±ng bi·∫øn m√¥i tr∆∞·ªùng LICENSE_VERIFY_ENDPOINT n·∫øu c·∫ßn
LICENSE_VERIFY_ENDPOINT = os.environ.get(
    'LICENSE_VERIFY_ENDPOINT',
    'https://management-license.vercel.app/'
)

def _infer_license_data_from_text(text: str, license_key: str = "") -> dict:
    """
    Suy lu·∫≠n tr·∫°ng th√°i license t·ª´ n·ªôi dung text/HTML khi server license kh√¥ng tr·∫£ JSON.
    Tr√°nh false-positive ki·ªÉu: trang HTML c√≥ ch·ªØ "ƒë√£ h·∫øt h·∫°n" ·ªü ph·∫ßn th·ªëng k√™/label nh∆∞ng key th·ª±c t·∫ø v·∫´n c√≤n h·∫°n.
    Tr·∫£ v·ªÅ dict gi·ªëng format JSON mong ƒë·ª£i (c√≥ th·ªÉ r·ªóng n·∫øu kh√¥ng suy ra ƒë∆∞·ª£c).
    """
    import re
    from datetime import datetime as _dt_mod

    raw_text = text or ""
    lower_text = raw_text.lower()

    key = (license_key or "").strip()
    key_lower = key.lower()

    # ∆Øu ti√™n parse trong v√πng g·∫ßn license key (n·∫øu xu·∫•t hi·ªán trong response)
    candidate_raw = raw_text
    candidate_lower = lower_text
    key_pos = None
    if key_lower and key_lower in lower_text:
        idx = lower_text.find(key_lower)
        key_pos = idx
        start = max(0, idx - 1500)
        end = min(len(lower_text), idx + 1500)
        candidate_raw = raw_text[start:end]
        candidate_lower = lower_text[start:end]
        key_pos = idx - start

    data: dict = {}

    # 1) C·ªë g·∫Øng b·∫Øt ƒë√∫ng d√≤ng "Tr·∫°ng th√°i: ..."
    active_pat = re.compile(
        r"tr·∫°ng\s*th√°i\s*[:\-]\s*(ƒëang\s*ho·∫°t\s*ƒë·ªông|c√≤n\s*h·∫°n|active|valid|h·ª£p\s*l·ªá)",
        re.IGNORECASE
    )
    expired_pat = re.compile(
        r"tr·∫°ng\s*th√°i\s*[:\-]\s*(ƒë√£\s*h·∫øt\s*h·∫°n|h·∫øt\s*h·∫°n|expired|invalid|kh√¥ng\s*h·ª£p\s*l·ªá)",
        re.IGNORECASE
    )

    matches: list[tuple[str, int]] = []
    for m in active_pat.finditer(candidate_raw):
        matches.append(("active", m.start()))
    for m in expired_pat.finditer(candidate_raw):
        matches.append(("expired", m.start()))

    chosen: str | None = None
    if matches:
        if key_pos is not None:
            # Ch·ªçn match g·∫ßn key nh·∫•t
            matches.sort(key=lambda t: abs(t[1] - key_pos))
            chosen = matches[0][0]
        else:
            # N·∫øu kh√¥ng th·∫•y key trong response m√† l·∫°i c√≥ nhi·ªÅu tr·∫°ng th√°i -> kh√¥ng ƒëo√°n b·ª´a
            unique = {m[0] for m in matches}
            if len(unique) == 1:
                chosen = next(iter(unique))

    if chosen == "expired":
        data["valid"] = False
        data["status"] = "expired"
        data["message"] = "License ƒë√£ h·∫øt h·∫°n (theo n·ªôi dung server license)."
    elif chosen == "active":
        data["valid"] = True
        data["status"] = "active"

    # 2) N·∫øu ch∆∞a x√°c ƒë·ªãnh ƒë∆∞·ª£c b·∫±ng "Tr·∫°ng th√°i", fallback theo c·ª•m t·ª´ kho√° trong v√πng candidate (ƒë·∫∑c bi·ªát khi response l√† HTML hi·ªÉn th·ªã chi ti·∫øt license)
    if not data:
        if "license h·ª£p l·ªá" in candidate_lower:
            data["valid"] = True
            data["status"] = "active"
        elif "kh√¥ng h·ª£p l·ªá" in candidate_lower:
            data["valid"] = False
            data["status"] = "expired"
            data["message"] = "License kh√¥ng h·ª£p l·ªá (theo n·ªôi dung server license)."
        elif "ƒë√£ h·∫øt h·∫°n" in candidate_lower:
            data["valid"] = False
            data["status"] = "expired"
            data["message"] = "License ƒë√£ h·∫øt h·∫°n (theo n·ªôi dung server license)."

    # N·∫øu v·∫´n ch∆∞a ƒëo√°n ƒë∆∞·ª£c -> tr·∫£ r·ªóng ƒë·ªÉ caller quy·∫øt ƒë·ªãnh
    if not data:
        return {}

    # B√≥c t√°ch days_remaining / expiry n·∫øu c√≥
    try:
        m = re.search(r"(\d+)\s*ng√†y", candidate_raw, re.IGNORECASE)
        if m:
            data["days_remaining"] = int(m.group(1))
    except Exception:
        pass

    try:
        m2 = re.search(r"H·∫øt\s*h·∫°n[: ]+([0-9: ]+\d{2}/\d{2}/\d{4})", candidate_raw, re.IGNORECASE)
        if m2:
            raw_expiry = m2.group(1).strip()
            try:
                expiry_dt = _dt_mod.strptime(raw_expiry, "%H:%M:%S %d/%m/%Y")
                data["expiry"] = expiry_dt.isoformat()
            except Exception:
                data["expiry"] = raw_expiry
    except Exception:
        pass

    return data


# Import database models
from database.models import (
    db,
    User,
    Attendance,
    Request,
    Department,
    AuditLog,
    PasswordResetToken,
    LeaveRequest,
    Holiday,
    Activation,
)
import smtplib
from email.mime.text import MIMEText
from email.utils import formataddr
from email.header import Header
from utils.email_utils import send_leave_request_email, send_leave_request_email_async
from state.email_state import email_status
from queue import Queue
from sqlalchemy.exc import SQLAlchemyError

# Import utility functions
from utils.validators import (
    validate_input_sanitize,
    validate_employee_id,
    validate_str,
    validate_date,
    validate_time,
    validate_float,
    validate_int,
    validate_note,
    validate_reason,
    validate_holiday_type,
    validate_role_value,
    ValidationError,
)
from utils.session import check_session_timeout, update_session_activity, log_audit_action
from utils.signature_manager import signature_manager
from utils.logger import logger, security_logger, audit_logger, database_logger, api_logger
from utils.security import security_manager, require_security_check
from utils.database_utils import safe_db_commit, safe_db_rollback, retry_db_operation

def has_role(user_id, required_role):
    """Check if user has a specific role"""
    user = db.session.get(User, user_id)
    if not user:
        return False
    return required_role in user.roles.split(',')

def check_approval_permission(user_id, attendance_id, current_role):
    """Check if user has permission to approve specific attendance"""
    user = db.session.get(User, user_id)
    if not user:
        return False, "‚ùå KH√îNG T√åM TH·∫§Y NG∆Ø·ªúI D√ôNG"
    
    attendance = db.session.get(Attendance, attendance_id)
    if not attendance:
        return False, "‚ùå KH√îNG T√åM TH·∫§Y B·∫¢N GHI CH·∫§M C√îNG"
    
    # ADMIN v√† MANAGER c√≥ th·ªÉ duy·ªát t·∫•t c·∫£
    if current_role in ['ADMIN', 'MANAGER']:
        return True, ""
    
    # TEAM_LEADER c√≥ th·ªÉ duy·ªát nh√¢n vi√™n c√πng ph√≤ng ban (bao g·ªìm c·∫£ b·∫£n th√¢n)
    if current_role == 'TEAM_LEADER':
        if not attendance.user or attendance.user.department != user.department:
            return False, "‚ùå KH√îNG C√ôNG PH√íNG BAN: Ch·ªâ duy·ªát ƒë∆∞·ª£c nh√¢n vi√™n c√πng ph√≤ng"
        return True, ""
    
    return False, "‚ùå KH√îNG C√ì QUY·ªÄN DUY·ªÜT CH·∫§M C√îNG"

def check_leave_approval_permission(user_id, request_id, current_role):
    """Check if user has permission to approve specific leave request"""
    user = db.session.get(User, user_id)
    if not user:
        return False, "‚ùå KH√îNG T√åM TH·∫§Y NG∆Ø·ªúI D√ôNG"
    
    leave_request = db.session.get(LeaveRequest, request_id)
    if not leave_request:
        return False, "‚ùå KH√îNG T√åM TH·∫§Y ƒê∆†N NGH·ªà PH√âP"
    
    # ADMIN v√† MANAGER c√≥ th·ªÉ duy·ªát t·∫•t c·∫£
    if current_role in ['ADMIN', 'MANAGER']:
        return True, ""
    
    # TEAM_LEADER c√≥ th·ªÉ duy·ªát nh√¢n vi√™n c√πng ph√≤ng ban (bao g·ªìm c·∫£ b·∫£n th√¢n)
    if current_role == 'TEAM_LEADER':
        if not leave_request.user or leave_request.user.department != user.department:
            return False, "‚ùå KH√îNG C√ôNG PH√íNG BAN: Ch·ªâ duy·ªát ƒë∆∞·ª£c nh√¢n vi√™n c√πng ph√≤ng"
        return True, ""
    
    return False, "‚ùå KH√îNG C√ì QUY·ªÄN DUY·ªÜT ƒê∆†N NGH·ªà PH√âP"

def validate_overtime_comp_time(
    check_in,
    check_out,
    shift_start,
    shift_end,
    break_time,
    comp_time_regular,
    comp_time_overtime,
    comp_time_ot_before_22,
    comp_time_ot_after_22,
    date,
    checkout_date=None,
    holiday_type='normal',
    shift_code=None,
):
    """
    Backend validation for compensation (ƒë·ªëi ·ª©ng) times.

    Rules (per user requirement):
    - Total compensation (regular + OT before 22 + OT after 22 [+ legacy overtime]) must NOT exceed total worked time.
    - OT compensation before/after 22h must NOT exceed actual OT before/after 22h.
    - For weekend / Vietnamese holiday: regular compensation in-shift is not applicable (must be 0).
    """
    from datetime import datetime, time as _time, timedelta

    def hours_to_minutes(v) -> int:
        try:
            return int(round(float(v or 0) * 60))
        except Exception:
            return 0

    def hhmm_to_minutes(s: str) -> int:
        if not s:
            return 0
        try:
            s = str(s).strip()
            if ':' not in s:
                return hours_to_minutes(float(s))
            h, m = s.split(':', 1)
            return int(h) * 60 + int(m)
        except Exception:
            return 0

    # If we cannot validate (missing required pieces), do not block here; other validations will handle.
    if not date or not check_in or not check_out:
        return True, None

    # Build full datetimes (supports multi-day via explicit checkout_date; fallback to overnight inference)
    ci_dt = datetime.combine(date, check_in)
    if checkout_date:
        co_dt = datetime.combine(checkout_date, check_out)
    else:
        # Fallback: infer overnight if time goes backwards or equal
        if (check_out.hour < check_in.hour) or (check_out.hour == check_in.hour and check_out.minute <= check_in.minute):
            co_dt = datetime.combine(date + timedelta(days=1), check_out)
        else:
            co_dt = datetime.combine(date, check_out)

    if co_dt <= ci_dt:
        return False, "Gi·ªù ra ph·∫£i sau gi·ªù v√†o (ho·∫∑c ch·ªçn ƒë√∫ng ng√†y ra cho ca qua ƒë√™m)."

    break_minutes = hours_to_minutes(break_time)
    total_work_minutes = max(0, int(round((co_dt - ci_dt).total_seconds() / 60)) - break_minutes)

    comp_regular_minutes = hours_to_minutes(comp_time_regular)
    comp_overtime_legacy_minutes = hours_to_minutes(comp_time_overtime)
    comp_before22_minutes = hours_to_minutes(comp_time_ot_before_22)
    comp_after22_minutes = hours_to_minutes(comp_time_ot_after_22)

    # Rule: weekend / Vietnamese holiday shouldn't accept in-shift (regular) compensation
    if holiday_type in ['weekend', 'vietnamese_holiday'] and comp_regular_minutes > 0:
        return False, "Ng√†y ngh·ªâ/l·ªÖ kh√¥ng √°p d·ª•ng 'ƒë·ªëi ·ª©ng trong ca'. Vui l√≤ng ƒë·ªÉ 0:00."

    total_comp_minutes = comp_regular_minutes + comp_overtime_legacy_minutes + comp_before22_minutes + comp_after22_minutes
    if total_comp_minutes > total_work_minutes:
        return False, "T·ªïng ƒë·ªëi ·ª©ng kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° t·ªïng gi·ªù l√†m."

    # Compute available overtime before/after 22h using existing business logic in Attendance.update_work_hours(),
    # but with compensation minutes set to 0 so we get raw available OT.
    try:
        tmp = Attendance(
            user_id=session.get('user_id') or 0,
            date=date,
            break_time=break_time or 0.0,
            is_holiday=(holiday_type != 'normal'),
            holiday_type=holiday_type,
            status='pending',
            shift_code=shift_code,
            shift_start=shift_start,
            shift_end=shift_end,
            comp_time_regular_minutes=0,
            comp_time_overtime_minutes=0,
            comp_time_ot_before_22_minutes=0,
            comp_time_ot_after_22_minutes=0,
            overtime_comp_time_minutes=0,
            required_hours=8.0,
        )
        tmp.check_in = ci_dt
        tmp.check_out = co_dt
        tmp.update_work_hours()

        # Gi·ªù c√¥ng th∆∞·ªùng (regular_work_hours) ƒë∆∞·ª£c Attendance t√≠nh theo ch√≠nh s√°ch hi·ªán t·∫°i
        regular_minutes = hhmm_to_minutes(
            tmp._Attendance__dict__.get('regular_work_hours_hhmm')  # not present, fallback below
        ) if False else int(round((tmp.regular_work_hours or 0.0) * 60))

        # Ca 5: kh√¥ng c√≥ gi·ªù c√¥ng => ƒë·ªëi ·ª©ng trong ca ph·∫£i = 0
        if shift_code == '5' and comp_regular_minutes > 0 and holiday_type != 'vietnamese_holiday':
            return False, "Ca 5 kh√¥ng c√≥ gi·ªù c√¥ng, vui l√≤ng ƒë·ªÉ 'ƒë·ªëi ·ª©ng trong ca' = 0:00."
        if comp_regular_minutes > regular_minutes and holiday_type not in ['weekend', 'vietnamese_holiday']:
            return False, "ƒê·ªëi ·ª©ng trong ca kh√¥ng ƒë∆∞·ª£c l·ªõn h∆°n gi·ªù c√¥ng."

        ot_before_raw = hhmm_to_minutes(tmp.overtime_before_22 or "0:00")
        ot_after_raw = hhmm_to_minutes(tmp.overtime_after_22 or "0:00")

        if comp_before22_minutes > ot_before_raw:
            return False, "ƒê·ªëi ·ª©ng tƒÉng ca tr∆∞·ªõc 22h kh√¥ng ƒë∆∞·ª£c l·ªõn h∆°n gi·ªù tƒÉng ca tr∆∞·ªõc 22h."
        if comp_after22_minutes > ot_after_raw:
            return False, "ƒê·ªëi ·ª©ng tƒÉng ca sau 22h kh√¥ng ƒë∆∞·ª£c l·ªõn h∆°n gi·ªù tƒÉng ca sau 22h."
    except Exception:
        # If OT computation fails for any reason, don't hard-block creation; total-comp rule still applies above.
        pass

    return True, None

def convert_overtime_to_hhmm():
    """Convert overtime values to HH:MM format using optimized bulk processing"""
    from utils.query_optimizer import bulk_convert_overtime_optimized
    total_converted = bulk_convert_overtime_optimized()
    # print(f"ƒê√£ l√†m s·∫°ch l·∫°i overtime v·ªÅ d·∫°ng H:MM cho {total_converted} b·∫£n ghi.")

app = Flask(__name__)

# Force template auto-reload (disable Jinja cache)
app.config['TEMPLATES_AUTO_RELOAD'] = True
app.jinja_env.auto_reload = True

# G3: CORS Configuration
try:
    from flask_cors import CORS
    from config import Config
    if getattr(Config, 'CORS_ENABLED', False):
        cors_origins = getattr(Config, 'CORS_ORIGINS', [])
        if cors_origins:
            CORS(app,
                 origins=cors_origins,
                 supports_credentials=getattr(Config, 'CORS_SUPPORTS_CREDENTIALS', True),
                 allow_headers=getattr(Config, 'CORS_ALLOW_HEADERS', ['Content-Type']),
                 methods=getattr(Config, 'CORS_METHODS', ['GET', 'POST']))
except ImportError:
    pass  # flask-cors not installed, skip CORS setup

# ----- Jinja filter: convert UTC datetime to Vietnam time (Asia/Ho_Chi_Minh) -----
from datetime import datetime
try:
    from zoneinfo import ZoneInfo  # Python 3.9+
    _VN_TZ = ZoneInfo('Asia/Ho_Chi_Minh')
    _UTC_TZ = ZoneInfo('UTC')
except Exception:  # Fallback if zoneinfo not available
    _VN_TZ = None
    _UTC_TZ = None

def _to_vn_datetime(dt: datetime) -> datetime | None:
    if not dt:
        return None
    # If tz-aware, convert; if naive, assume UTC and convert
    try:
        if _VN_TZ is None:
            return dt  # best-effort fallback
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=_UTC_TZ)
        return dt.astimezone(_VN_TZ)
    except Exception:
        return dt

def _vn_datetime_format(dt: datetime, fmt: str = '%d/%m/%Y %H:%M') -> str:
    local_dt = _to_vn_datetime(dt)
    return local_dt.strftime(fmt) if local_dt else ''

app.jinja_env.filters['vn_datetime'] = _vn_datetime_format

# Filter ƒë·ªÉ l·ªçc notes - ch·ªâ hi·ªÉn th·ªã ph·∫ßn text ghi ch√∫, ·∫©n use_lunch_break
def _filter_leave_notes(notes_str):
    """
    L·ªçc notes ƒë·ªÉ ch·ªâ hi·ªÉn th·ªã ph·∫ßn text ghi ch√∫ th·ª±c s·ª±, ·∫©n use_lunch_break
    N·∫øu notes l√† JSON ch·ª©a use_lunch_break, ch·ªâ tr·∫£ v·ªÅ _original_notes (n·∫øu c√≥)
    N·∫øu notes l√† text th∆∞·ªùng, tr·∫£ v·ªÅ nh∆∞ c≈©
    """
    if not notes_str:
        return ''
    
    try:
        import json
        # Th·ª≠ parse JSON
        notes_data = json.loads(notes_str)
        if isinstance(notes_data, dict):
            # N·∫øu c√≥ _original_notes, tr·∫£ v·ªÅ ph·∫ßn text ghi ch√∫ th·ª±c s·ª±
            if '_original_notes' in notes_data:
                return notes_data['_original_notes']
            # N·∫øu ch·ªâ c√≥ use_lunch_break v√† kh√¥ng c√≥ text ghi ch√∫, tr·∫£ v·ªÅ r·ªóng
            if 'use_lunch_break' in notes_data and len(notes_data) == 1:
                return ''
            # N·∫øu c√≥ c√°c key kh√°c, c√≥ th·ªÉ l√† JSON h·ª£p l·ªá nh∆∞ng kh√¥ng ph·∫£i format c·ªßa ch√∫ng ta
            # Tr·∫£ v·ªÅ r·ªóng ƒë·ªÉ tr√°nh hi·ªÉn th·ªã JSON
            return ''
    except (json.JSONDecodeError, TypeError, ValueError):
        # Kh√¥ng ph·∫£i JSON, tr·∫£ v·ªÅ nh∆∞ c≈© (text th∆∞·ªùng)
        return notes_str
    
    return notes_str

app.jinja_env.filters['filter_leave_notes'] = _filter_leave_notes

# Dictionary ƒë·ªÉ l∆∞u tr·∫°ng th√°i email g·ª≠i
# in-memory state moved to state/email_state.py for a single source of import

# --- Persistent email status model ---
class EmailStatusRecord(db.Model):
    __tablename__ = 'email_status_records'
    __table_args__ = {
        'extend_existing': True
    }
    id = db.Column(db.Integer, primary_key=True)
    request_id = db.Column(db.Integer, index=True, nullable=False, unique=True)
    status = db.Column(db.String(50), nullable=False)
    message = db.Column(db.Text, nullable=True)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

def _ensure_email_status_table():
    try:
        # Create table if it does not exist without affecting others
        EmailStatusRecord.__table__.create(bind=db.engine, checkfirst=True)
    except Exception as e:
        pass

def upsert_email_status(request_id: int, status: str, message: str):
    try:
        _ensure_email_status_table()
        record = EmailStatusRecord.query.filter_by(request_id=request_id).first()
        if record is None:
            record = EmailStatusRecord(request_id=request_id, status=status, message=message)
            db.session.add(record)
        else:
            record.status = status
            record.message = message
        db.session.commit()
        # print(f"[EmailStatus] upsert request_id={request_id} -> {status}")
    except Exception as e:
        db.session.rollback()
        # print(f"[EmailStatus] upsert error: {e}")

def get_email_status_record(request_id: int):
    try:
        _ensure_email_status_table()
        return EmailStatusRecord.query.filter_by(request_id=request_id).first()
    except Exception as e:
        # print(f"[EmailStatus] get error: {e}")
        return None

# --- Google Drive API Integration ---

# ===== CONNECTION POOLING - SINGLETON PATTERN =====
# T√°i s·ª≠ d·ª•ng Google API connection ƒë·ªÉ gi·∫£m overhead TLS handshake
_google_api_instance = None
_google_api_lock = threading.Lock()

def get_google_api_singleton():
    """
    L·∫•y singleton instance c·ªßa GoogleDriveAPI.
    Thread-safe v·ªõi double-checked locking.

    Returns:
        GoogleDriveAPI: Singleton instance
    """
    global _google_api_instance

    if _google_api_instance is None:
        with _google_api_lock:
            if _google_api_instance is None:
                _google_api_instance = GoogleDriveAPI(auto_authenticate=True)
                print("üîå [CONNECTION_POOL] ƒê√£ t·∫°o Google API singleton instance", flush=True, file=sys.stderr)

    # ƒê·∫£m b·∫£o token v·∫´n valid
    if _google_api_instance and _google_api_instance.creds:
        if not _google_api_instance.creds.valid:
            with _google_api_lock:
                try:
                    _google_api_instance.ensure_valid_token()
                    print("üîÑ [CONNECTION_POOL] ƒê√£ refresh token cho singleton", flush=True, file=sys.stderr)
                except Exception as e:
                    print(f"‚ö†Ô∏è [CONNECTION_POOL] L·ªói refresh token: {e}", flush=True, file=sys.stderr)

    return _google_api_instance


def reset_google_api_singleton():
    """
    Reset singleton instance (d√πng khi c·∫ßn re-authenticate).
    """
    global _google_api_instance
    with _google_api_lock:
        _google_api_instance = None
        print("üîÑ [CONNECTION_POOL] ƒê√£ reset Google API singleton", flush=True, file=sys.stderr)


class GoogleDriveAPI:
    """Class ƒë·ªÉ qu·∫£n l√Ω Google Drive API"""
    
    def __init__(self, auto_authenticate=True):
        """Kh·ªüi t·∫°o Google Drive API client
        
        Args:
            auto_authenticate: N·∫øu True, t·ª± ƒë·ªông authenticate khi kh·ªüi t·∫°o. 
                              N·∫øu False, ch·ªâ load token t·ª´ file m√† kh√¥ng authenticate.
        """
        self.creds = None
        self.drive_service = None
        self.sheets_service = None
        self.token_file = 'token.json'
        self.last_refresh_file = 'last_token_refresh.txt'
        
        if not GOOGLE_API_AVAILABLE:
            print("L·ªói: Google API libraries kh√¥ng c√≥ s·∫µn!")
            print("H√£y c√†i ƒë·∫∑t: pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client")
            return
        
        if not os.path.exists('credentials.json'):
            print("L·ªói: Kh√¥ng t√¨m th·∫•y file credentials.json!")
            print("H√£y t·∫°o file credentials.json trong th∆∞ m·ª•c hi·ªán t·∫°i.")
            return
        
        # Ch·ªâ load token t·ª´ file n·∫øu kh√¥ng auto-authenticate
        if not auto_authenticate:
            if os.path.exists('token.json'):
                try:
                    with open('token.json', 'r') as token:
                        token_data = json.load(token)
                        self.creds = Credentials.from_authorized_user_info(token_data, GOOGLE_SCOPES)
                except Exception as e:
                    print(f"L·ªói khi load token.json: {e}")
            # Removed pickle migration code for security - only JSON is supported now
            return
        
        # Ch·ªâ authenticate n·∫øu ƒë∆∞·ª£c ph√©p v√† c·∫ßn thi·∫øt
        if auto_authenticate:
            print("Ph√°t hi·ªán file credentials.json - B·∫Øt ƒë·∫ßu x√°c th·ª±c...")
            self.authenticate(allow_browser_auth=False)  # Kh√¥ng t·ª± ƒë·ªông m·ªü browser
            
            # T·ª± ƒë·ªông gia h·∫°n token n·∫øu c·∫ßn
            self.auto_refresh_token_if_needed()
        
        # Cache cho file ID ƒë·ªÉ tr√°nh t√¨m ki·∫øm nhi·ªÅu l·∫ßn
        self._file_cache = {}
        # Cache cho sheet ID ƒë·ªÉ tr√°nh g·ªçi API l·∫∑p l·∫°i (gi·∫£m rate limit)
        self._sheet_id_cache = {}
        # Rate limit tracking
        self._api_call_timestamps = []
        self._rate_limit_window = 60  # 60 gi√¢y
        self._rate_limit_max_calls = 55  # Gi·ªõi h·∫°n 55 (d∆∞·ªõi ng∆∞·ª°ng 60 c·ªßa Google)
    
    def authenticate(self, allow_browser_auth=False):
        """X√°c th·ª±c v·ªõi Google API
        
        Args:
            allow_browser_auth: N·∫øu True, cho ph√©p m·ªü browser ƒë·ªÉ authenticate.
                               N·∫øu False, ch·ªâ th·ª≠ refresh token, kh√¥ng m·ªü browser.
        """
        if not GOOGLE_API_AVAILABLE:
            print("Google API libraries not available")
            return
            
        try:
            # Ki·ªÉm tra token ƒë√£ l∆∞u
            if os.path.exists('token.json'):
                with open('token.json', 'r') as token:
                    token_data = json.load(token)
                    self.creds = Credentials.from_authorized_user_info(token_data, GOOGLE_SCOPES)
            # Removed pickle migration - only JSON is supported for security
            
            # N·∫øu kh√¥ng c√≥ credentials h·ª£p l·ªá
            if not self.creds or not self.creds.valid:
                # Th·ª≠ refresh n·∫øu c√≥ refresh_token
                if self.creds and self.creds.expired and self.creds.refresh_token:
                    try:
                        self.creds.refresh(GoogleRequest())
                        # L∆∞u credentials sau khi refresh
                        with open('token.json', 'w') as token:
                            token.write(self.creds.to_json())
                    except Exception as refresh_err:
                        # Refresh th·∫•t b·∫°i
                        if allow_browser_auth:
                            # Ch·ªâ m·ªü browser n·∫øu ƒë∆∞·ª£c ph√©p
                            flow = InstalledAppFlow.from_client_secrets_file(
                                'credentials.json', GOOGLE_SCOPES)
                            self.creds = flow.run_local_server(port=0)
                            # L∆∞u credentials
                            with open('token.json', 'w') as token:
                                token.write(self.creds.to_json())
                        else:
                            # Kh√¥ng m·ªü browser, ch·ªâ b√°o l·ªói
                            print(f"‚ö†Ô∏è Token h·∫øt h·∫°n v√† kh√¥ng th·ªÉ refresh t·ª± ƒë·ªông. C·∫ßn authenticate th·ªß c√¥ng.")
                            return  # Kh√¥ng raise exception ƒë·ªÉ kh√¥ng l√†m crash app
                elif allow_browser_auth:
                    # Ch·ªâ m·ªü browser n·∫øu ƒë∆∞·ª£c ph√©p v√† kh√¥ng c√≥ token
                    flow = InstalledAppFlow.from_client_secrets_file(
                        'credentials.json', GOOGLE_SCOPES)
                    self.creds = flow.run_local_server(port=0)
                    # L∆∞u credentials
                    with open('token.json', 'w') as token:
                        token.write(self.creds.to_json())
                else:
                    # Kh√¥ng c√≥ token v√† kh√¥ng ƒë∆∞·ª£c ph√©p m·ªü browser
                    print("‚ö†Ô∏è Kh√¥ng c√≥ token v√† kh√¥ng ƒë∆∞·ª£c ph√©p m·ªü browser ƒë·ªÉ authenticate.")
                    return  # Kh√¥ng raise exception ƒë·ªÉ kh√¥ng l√†m crash app
            
            # Kh·ªüi t·∫°o services n·∫øu c√≥ credentials
            if self.creds and self.creds.valid:
                self.drive_service = build('drive', 'v3', credentials=self.creds)
                self.sheets_service = build('sheets', 'v4', credentials=self.creds)
                print("‚úÖ X√°c th·ª±c th√†nh c√¥ng!")
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói x√°c th·ª±c: {e}")
            # Kh√¥ng crash app, ch·ªâ log l·ªói
    
    def auto_refresh_token_if_needed(self):
        """T·ª± ƒë·ªông gia h·∫°n token n·∫øu c·∫ßn thi·∫øt"""
        try:
            # Ki·ªÉm tra xem c√≥ c·∫ßn gia h·∫°n kh√¥ng
            if self.should_refresh_token():
                print("üîÑ T·ª± ƒë·ªông gia h·∫°n token...")
                if self.refresh_token():
                    self.save_last_refresh_time()
                    print("‚úÖ Token ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√†nh c√¥ng!")
                else:
                    print("‚ö†Ô∏è Kh√¥ng th·ªÉ gia h·∫°n token, c·∫ßn x√°c th·ª±c l·∫°i")
            else:
                print("‚úÖ Token v·∫´n c√≤n hi·ªáu l·ª±c, kh√¥ng c·∫ßn gia h·∫°n")
        except Exception as e:
            print(f"‚ö†Ô∏è  L·ªói khi gia h·∫°n token: {e}")
    
    def ensure_valid_token(self):
        """ƒê·∫£m b·∫£o token lu√¥n h·ª£p l·ªá tr∆∞·ªõc khi s·ª≠ d·ª•ng API"""
        try:
            # Ki·ªÉm tra xem c√≥ credentials kh√¥ng
            if not self.creds:
                print("‚ùå Kh√¥ng c√≥ credentials, c·∫ßn x√°c th·ª±c l·∫°i")
                return False
            
            # Ki·ªÉm tra xem token c√≥ h·∫øt h·∫°n kh√¥ng
            if self.creds.expired:
                print("üîÑ Token ƒë√£ h·∫øt h·∫°n, ƒëang gia h·∫°n...")
                if self.creds.refresh_token:
                    try:
                        self.creds.refresh(GoogleRequest())
                        # L∆∞u token m·ªõi
                        with open(self.token_file, 'w') as token:
                            token.write(self.creds.to_json())
                        # C·∫≠p nh·∫≠t services
                        self.drive_service = build('drive', 'v3', credentials=self.creds)
                        self.sheets_service = build('sheets', 'v4', credentials=self.creds)
                        print("‚úÖ Token ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√†nh c√¥ng!")
                        return True
                    except Exception as refresh_error:
                        error_str = str(refresh_error)
                        if 'invalid_grant' in error_str.lower():
                            print("‚ùå L·ªói invalid_grant: Refresh token kh√¥ng h·ª£p l·ªá")
                            print("üí° C·∫ßn t·∫°o token m·ªõi b·∫±ng c√°ch ch·∫°y: python refresh_token.py")
                            # X√≥a token c≈© ƒë·ªÉ tr√°nh l·ªói l·∫∑p l·∫°i
                            try:
                                if os.path.exists(self.token_file):
                                    backup_name = f"token_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
                                    shutil.copy2(self.token_file, backup_name)
                                    os.remove(self.token_file)
                                    print(f"üíæ ƒê√£ backup v√† x√≥a token c≈©: {backup_name}")
                            except Exception:
                                pass
                        else:
                            print(f"‚ùå L·ªói khi refresh token: {refresh_error}")
                        return False
                else:
                    print("‚ùå Kh√¥ng c√≥ refresh_token, c·∫ßn x√°c th·ª±c l·∫°i")
                    return False
            
            # Ki·ªÉm tra xem services c√≥ ho·∫°t ƒë·ªông kh√¥ng
            if not self.drive_service or not self.sheets_service:
                print("üîÑ Kh·ªüi t·∫°o l·∫°i services...")
                self.drive_service = build('drive', 'v3', credentials=self.creds)
                self.sheets_service = build('sheets', 'v4', credentials=self.creds)
                print("‚úÖ Services ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o l·∫°i!")
            
            return True
        except Exception as e:
            print(f"‚ùå L·ªói khi ƒë·∫£m b·∫£o token h·ª£p l·ªá: {e}")
            return False
    
    def should_refresh_token(self):
        """Ki·ªÉm tra xem c√≥ c·∫ßn gia h·∫°n token kh√¥ng"""
        try:
            # Ki·ªÉm tra xem c√≥ credentials kh√¥ng
            if not self.creds:
                return True  # Kh√¥ng c√≥ credentials, c·∫ßn x√°c th·ª±c
            
            # Ki·ªÉm tra xem token c√≥ h·∫øt h·∫°n kh√¥ng
            if self.creds.expired:
                print("‚ö†Ô∏è Token ƒë√£ h·∫øt h·∫°n!")
                return True  # Token ƒë√£ h·∫øt h·∫°n, c·∫ßn gia h·∫°n
            
            # Ki·ªÉm tra file l·∫ßn gia h·∫°n cu·ªëi
            if not os.path.exists(self.last_refresh_file):
                print("‚ö†Ô∏è Ch∆∞a c√≥ file l∆∞u th·ªùi gian gia h·∫°n, c·∫ßn gia h·∫°n")
                return True  # Ch∆∞a c√≥ file, c·∫ßn gia h·∫°n
            
            # ƒê·ªçc th·ªùi gian gia h·∫°n cu·ªëi
            with open(self.last_refresh_file, 'r') as f:
                last_refresh_str = f.read().strip()
            
            last_refresh = datetime.fromisoformat(last_refresh_str)
            now = datetime.now()
            time_diff = (now - last_refresh).total_seconds()
            
            # N·∫øu ƒë√£ qua 45 ph√∫t th√¨ c·∫ßn gia h·∫°n (Google tokens th∆∞·ªùng h·∫øt h·∫°n sau 1 gi·ªù)
            # Gia h·∫°n s·ªõm 15 ph√∫t ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng bao gi·ªù h·∫øt h·∫°n
            if time_diff >= 45 * 60:  # 45 ph√∫t
                print(f"‚ö†Ô∏è Token s·∫Øp h·∫øt h·∫°n (ƒë√£ {time_diff/60:.1f} ph√∫t), c·∫ßn gia h·∫°n")
                return True
            
            # C·∫£nh b√°o khi c√≤n 10 ph√∫t n·ªØa s·∫Ω gia h·∫°n
            if time_diff >= 35 * 60:  # 35 ph√∫t
                print(f"‚ÑπÔ∏è Token s·∫Ω ƒë∆∞·ª£c gia h·∫°n trong {45 - time_diff/60:.1f} ph√∫t n·ªØa")
            
            return False
        except Exception as e:
            print(f"‚ùå L·ªói khi ki·ªÉm tra th·ªùi gian gia h·∫°n: {e}")
            return True  # N·∫øu c√≥ l·ªói th√¨ gia h·∫°n ƒë·ªÉ an to√†n
    
    def refresh_token(self):
        """Gia h·∫°n token"""
        try:
            if not self.creds:
                print("Kh√¥ng c√≥ credentials ƒë·ªÉ gia h·∫°n")
                return False
            
            # Lu√¥n th·ª≠ gia h·∫°n token n·∫øu c√≥ refresh_token
            if self.creds.refresh_token:
                print("ƒêang gia h·∫°n token...")
                self.creds.refresh(GoogleRequest())

                # L∆∞u token m·ªõi d·∫°ng JSON (th·ªëng nh·∫•t v·ªõi ensure_valid_token)
                with open(self.token_file, 'w') as token:
                    token.write(self.creds.to_json())
                
                # C·∫≠p nh·∫≠t services
                self.drive_service = build('drive', 'v3', credentials=self.creds)
                self.sheets_service = build('sheets', 'v4', credentials=self.creds)
                
                print("‚úÖ Token ƒë√£ ƒë∆∞·ª£c gia h·∫°n th√†nh c√¥ng!")
                return True
            else:
                print("Kh√¥ng c√≥ refresh_token, c·∫ßn x√°c th·ª±c l·∫°i")
                return False
        except Exception as e:
            print(f"L·ªói khi gia h·∫°n token: {e}")
            return False
    
    def save_last_refresh_time(self):
        """L∆∞u th·ªùi gian gia h·∫°n cu·ªëi"""
        try:
            with open(self.last_refresh_file, 'w') as f:
                f.write(datetime.now().isoformat())
        except Exception as e:
            print(f"L·ªói khi l∆∞u th·ªùi gian gia h·∫°n: {e}")
    
    def update_sheet_value(self, spreadsheet_id, sheet_name, row, column, new_value):
        """
        C·∫≠p nh·∫≠t gi√° tr·ªã trong Google Sheet v·ªõi c√°c tham s·ªë c·ª• th·ªÉ
        
        Args:
            spreadsheet_id (str): ID c·ªßa spreadsheet
            sheet_name (str): T√™n sheet
            row (int): S·ªë d√≤ng (b·∫Øt ƒë·∫ßu t·ª´ 1)
            column (str): T√™n c·ªôt (A, B, C, ..., M, N, O, ...)
            new_value (str): Gi√° tr·ªã m·ªõi
        
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i
        """
        import time
        from datetime import datetime as dt
        
        # Validation ƒë·∫ßu v√†o
        if not spreadsheet_id or not isinstance(spreadsheet_id, str) or not spreadsheet_id.strip():
            print(f"‚ùå [UPDATE_SHEET_VALUE] Spreadsheet ID kh√¥ng h·ª£p l·ªá: {spreadsheet_id}")
            return False
        
        if not sheet_name or not isinstance(sheet_name, str) or not sheet_name.strip():
            print(f"‚ùå [UPDATE_SHEET_VALUE] Sheet name kh√¥ng h·ª£p l·ªá: {sheet_name}")
            return False
        
        if not isinstance(row, int) or row < 1:
            print(f"‚ùå [UPDATE_SHEET_VALUE] Row kh√¥ng h·ª£p l·ªá: {row}")
            return False
        
        if not column or not isinstance(column, str) or not column.strip():
            print(f"‚ùå [UPDATE_SHEET_VALUE] Column kh√¥ng h·ª£p l·ªá: {column}")
            return False
        
        # Sanitize gi√° tr·ªã
        if new_value is None:
            new_value = ''
        else:
            new_value = str(new_value).strip()
        
        # Retry logic v·ªõi exponential backoff
        max_retries = 3
        retry_delay = 1  # gi√¢y
        
        for attempt in range(max_retries):
            try:
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                if attempt > 0:
                    print(f"üîÑ [UPDATE_SHEET_VALUE] L·∫ßn th·ª≠ {attempt + 1}/{max_retries} - {timestamp}")
                
                # ƒê·∫£m b·∫£o token lu√¥n h·ª£p l·ªá tr∆∞·ªõc khi s·ª≠ d·ª•ng API
                if not self.ensure_valid_token():
                    print("‚ùå [UPDATE_SHEET_VALUE] Kh√¥ng th·ªÉ ƒë·∫£m b·∫£o token h·ª£p l·ªá")
                    return False
                
                if not self.sheets_service:
                    print("‚ùå [UPDATE_SHEET_VALUE] Sheets service kh√¥ng kh·∫£ d·ª•ng")
                    return False
                
                # T·∫°o range t·ª´ c√°c tham s·ªë
                range_name = f"{sheet_name}!{column}{row}"
                
                print(f"\nüîß [UPDATE_SHEET_VALUE] C·∫¨P NH·∫¨T GI√Å TR·ªä TRONG SHEET:")
                print(f"   Sheet: {sheet_name}")
                print(f"   √î: {column}{row}")
                print(f"   Gi√° tr·ªã m·ªõi: {new_value}")
                print(f"   Range: {range_name}")
                
                # C·∫≠p nh·∫≠t gi√° tr·ªã
                body = {
                    'values': [[new_value]]
                }
                
                result = self.sheets_service.spreadsheets().values().update(
                    spreadsheetId=spreadsheet_id,
                    range=range_name,
                    valueInputOption='USER_ENTERED',
                    body=body
                ).execute()
                
                updated_cells = result.get('updatedCells', 0)
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                print(f"‚úÖ [UPDATE_SHEET_VALUE_SUCCESS] {timestamp} - C·∫≠p nh·∫≠t th√†nh c√¥ng! S·ªë √¥ ƒë√£ c·∫≠p nh·∫≠t: {updated_cells}")
                
                # CƒÉn gi·ªØa cell sau khi c·∫≠p nh·∫≠t (kh√¥ng b·∫Øt bu·ªôc, n·∫øu l·ªói v·∫´n coi l√† th√†nh c√¥ng)
                try:
                    self.center_align_cells(spreadsheet_id, sheet_name, [range_name])
                except Exception as e:
                    print(f"‚ö†Ô∏è [UPDATE_SHEET_VALUE] Kh√¥ng th·ªÉ cƒÉn gi·ªØa cell (kh√¥ng ·∫£nh h∆∞·ªüng k·∫øt qu·∫£): {e}")
                
                return True
                
            except Exception as e:
                error_str = str(e)
                error_type = type(e).__name__
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                
                # Ph√¢n lo·∫°i l·ªói
                is_retryable = False
                if '429' in error_str or 'quota' in error_str.lower() or 'rate limit' in error_str.lower():
                    is_retryable = True
                    print(f"‚ö†Ô∏è [UPDATE_SHEET_VALUE] {timestamp} - Rate limit/quota error (c√≥ th·ªÉ retry): {error_str}")
                elif '503' in error_str or '500' in error_str or 'timeout' in error_str.lower():
                    is_retryable = True
                    print(f"‚ö†Ô∏è [UPDATE_SHEET_VALUE] {timestamp} - Server error (c√≥ th·ªÉ retry): {error_str}")
                elif 'PERMISSION_DENIED' in error_str or 'permission' in error_str.lower():
                    print(f"‚ùå [UPDATE_SHEET_VALUE] {timestamp} - L·ªói quy·ªÅn truy c·∫≠p: {error_str}")
                    return False  # Kh√¥ng retry l·ªói quy·ªÅn
                elif 'NOT_FOUND' in error_str or 'not found' in error_str.lower():
                    print(f"‚ùå [UPDATE_SHEET_VALUE] {timestamp} - Spreadsheet ho·∫∑c sheet kh√¥ng t·ªìn t·∫°i: {error_str}")
                    return False  # Kh√¥ng retry l·ªói kh√¥ng t√¨m th·∫•y
                else:
                    print(f"‚ùå [UPDATE_SHEET_VALUE] {timestamp} - L·ªói kh√¥ng x√°c ƒë·ªãnh: {error_type} - {error_str}")
                
                # Retry n·∫øu c√≥ th·ªÉ
                if is_retryable and attempt < max_retries - 1:
                    wait_time = retry_delay * (2 ** attempt)  # Exponential backoff
                    print(f"‚è≥ [UPDATE_SHEET_VALUE] ƒê·ª£i {wait_time} gi√¢y tr∆∞·ªõc khi retry...")
                    time.sleep(wait_time)
                else:
                    # Kh√¥ng th·ªÉ retry ho·∫∑c ƒë√£ h·∫øt s·ªë l·∫ßn th·ª≠
                    import traceback
                    print(f"‚ùå [UPDATE_SHEET_VALUE_FAILED] {timestamp} - C·∫≠p nh·∫≠t th·∫•t b·∫°i sau {attempt + 1} l·∫ßn th·ª≠")
                    print(f"   Error Type: {error_type}")
                    print(f"   Error Message: {error_str}")
                    print(f"   Traceback:\n{traceback.format_exc()}")
                    return False
        
        return False
    
    def batch_update_values(self, spreadsheet_id, data_ranges):
        """C·∫≠p nh·∫≠t nhi·ªÅu √¥ theo l√¥ b·∫±ng A1 notation.

        Args:
            spreadsheet_id (str): ID c·ªßa spreadsheet
            data_ranges (list[dict]): M·ªói ph·∫ßn t·ª≠ c√≥ d·∫°ng {'range': 'Sheet!A1', 'values': [[value]]}

        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i
        """
        import time
        from datetime import datetime as dt
        
        # Validation ƒë·∫ßu v√†o
        if not spreadsheet_id or not isinstance(spreadsheet_id, str) or not spreadsheet_id.strip():
            print(f"‚ùå [BATCH_UPDATE] Spreadsheet ID kh√¥ng h·ª£p l·ªá: {spreadsheet_id}")
            return False
        
        if not data_ranges or not isinstance(data_ranges, list) or len(data_ranges) == 0:
            print(f"‚ùå [BATCH_UPDATE] Data ranges kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng")
            return False
        
        # Validate v√† sanitize t·ª´ng range
        sanitized_ranges = []
        for idx, range_data in enumerate(data_ranges):
            if not isinstance(range_data, dict):
                print(f"‚ö†Ô∏è [BATCH_UPDATE] Range {idx} kh√¥ng ph·∫£i dict, b·ªè qua")
                continue
            
            if 'range' not in range_data or 'values' not in range_data:
                print(f"‚ö†Ô∏è [BATCH_UPDATE] Range {idx} thi·∫øu 'range' ho·∫∑c 'values', b·ªè qua")
                continue
            
            range_name = str(range_data['range']).strip()
            values = range_data['values']
            
            if not range_name:
                print(f"‚ö†Ô∏è [BATCH_UPDATE] Range {idx} c√≥ t√™n r·ªóng, b·ªè qua")
                continue
            
            if not isinstance(values, list) or len(values) == 0:
                print(f"‚ö†Ô∏è [BATCH_UPDATE] Range {idx} c√≥ values r·ªóng, b·ªè qua")
                continue
            
            # Sanitize values - ƒë·∫£m b·∫£o t·∫•t c·∫£ l√† string v√† kh√¥ng c√≥ None
            sanitized_values = []
            for row in values:
                if not isinstance(row, list):
                    row = [row]
                sanitized_row = []
                for cell_value in row:
                    if cell_value is None:
                        sanitized_row.append('')
                    else:
                        # Chuy·ªÉn t·∫•t c·∫£ th√†nh string, x·ª≠ l√Ω ƒë·∫∑c bi·ªát cho c√°c gi√° tr·ªã ƒë·∫∑c bi·ªát
                        cell_str = str(cell_value).strip()
                        sanitized_row.append(cell_str)
                sanitized_values.append(sanitized_row)
            
            sanitized_ranges.append({
                'range': range_name,
                'values': sanitized_values
            })
        
        if len(sanitized_ranges) == 0:
            print(f"‚ùå [BATCH_UPDATE] Kh√¥ng c√≥ range h·ª£p l·ªá n√†o sau khi sanitize")
            return False
        
        # Retry logic v·ªõi exponential backoff
        max_retries = 3
        retry_delay = 1  # gi√¢y
        
        for attempt in range(max_retries):
            try:
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                if attempt > 0:
                    print(f"üîÑ [BATCH_UPDATE] L·∫ßn th·ª≠ {attempt + 1}/{max_retries} - {timestamp}")
                
                if not self.ensure_valid_token():
                    print("‚ùå [BATCH_UPDATE] Kh√¥ng th·ªÉ ƒë·∫£m b·∫£o token h·ª£p l·ªá")
                    return False
                
                if not self.sheets_service:
                    print("‚ùå [BATCH_UPDATE] Sheets service kh√¥ng kh·∫£ d·ª•ng")
                    return False
                
                body = {
                    'valueInputOption': 'USER_ENTERED',
                    'data': sanitized_ranges
                }
                
                result = self.sheets_service.spreadsheets().values().batchUpdate(
                    spreadsheetId=spreadsheet_id,
                    body=body
                ).execute()
                
                updated = result.get('totalUpdatedCells', 0)
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                print(f"‚úÖ [BATCH_UPDATE_SUCCESS] {timestamp} - Batch update th√†nh c√¥ng, s·ªë √¥ c·∫≠p nh·∫≠t: {updated}")
                return True
                
            except Exception as e:
                error_str = str(e)
                error_type = type(e).__name__
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                
                # Ph√¢n lo·∫°i l·ªói
                is_retryable = False
                if '429' in error_str or 'quota' in error_str.lower() or 'rate limit' in error_str.lower():
                    is_retryable = True
                    print(f"‚ö†Ô∏è [BATCH_UPDATE] {timestamp} - Rate limit/quota error (c√≥ th·ªÉ retry): {error_str}")
                elif '503' in error_str or '500' in error_str or 'timeout' in error_str.lower():
                    is_retryable = True
                    print(f"‚ö†Ô∏è [BATCH_UPDATE] {timestamp} - Server error (c√≥ th·ªÉ retry): {error_str}")
                elif 'PERMISSION_DENIED' in error_str or 'permission' in error_str.lower():
                    print(f"‚ùå [BATCH_UPDATE] {timestamp} - L·ªói quy·ªÅn truy c·∫≠p: {error_str}")
                    return False  # Kh√¥ng retry l·ªói quy·ªÅn
                elif 'NOT_FOUND' in error_str or 'not found' in error_str.lower():
                    print(f"‚ùå [BATCH_UPDATE] {timestamp} - Spreadsheet ho·∫∑c sheet kh√¥ng t·ªìn t·∫°i: {error_str}")
                    return False  # Kh√¥ng retry l·ªói kh√¥ng t√¨m th·∫•y
                else:
                    print(f"‚ùå [BATCH_UPDATE] {timestamp} - L·ªói kh√¥ng x√°c ƒë·ªãnh: {error_type} - {error_str}")
                
                # Retry n·∫øu c√≥ th·ªÉ
                if is_retryable and attempt < max_retries - 1:
                    wait_time = retry_delay * (2 ** attempt)  # Exponential backoff
                    print(f"‚è≥ [BATCH_UPDATE] ƒê·ª£i {wait_time} gi√¢y tr∆∞·ªõc khi retry...")
                    time.sleep(wait_time)
                else:
                    # Kh√¥ng th·ªÉ retry ho·∫∑c ƒë√£ h·∫øt s·ªë l·∫ßn th·ª≠
                    import traceback
                    print(f"‚ùå [BATCH_UPDATE_FAILED] {timestamp} - Batch update th·∫•t b·∫°i sau {attempt + 1} l·∫ßn th·ª≠")
                    print(f"   Error Type: {error_type}")
                    print(f"   Error Message: {error_str}")
                    print(f"   Traceback:\n{traceback.format_exc()}")
                    return False
        
        return False
    
    def batch_update_values_with_formatting(self, spreadsheet_id, sheet_name, data_ranges):
        """C·∫≠p nh·∫≠t nhi·ªÅu √¥ theo l√¥ v√† √°p d·ª•ng ƒë·ªãnh d·∫°ng (font Google Sans, c·ª° ch·ªØ 9, cƒÉn gi·ªØa) trong m·ªôt l·∫ßn g·ªçi.
        
        Args:
            spreadsheet_id (str): ID c·ªßa spreadsheet
            sheet_name (str): T√™n sheet
            data_ranges (list[dict]): M·ªói ph·∫ßn t·ª≠ c√≥ d·∫°ng {'range': 'Sheet!A1', 'values': [[value]]}
        
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i
        """
        import time
        from datetime import datetime as dt
        
        # Validation ƒë·∫ßu v√†o
        if not spreadsheet_id or not isinstance(spreadsheet_id, str) or not spreadsheet_id.strip():
            print(f"‚ùå [BATCH_UPDATE_FORMAT] Spreadsheet ID kh√¥ng h·ª£p l·ªá: {spreadsheet_id}")
            return False
        
        if not sheet_name or not isinstance(sheet_name, str) or not sheet_name.strip():
            print(f"‚ùå [BATCH_UPDATE_FORMAT] Sheet name kh√¥ng h·ª£p l·ªá: {sheet_name}")
            return False
        
        if not data_ranges or not isinstance(data_ranges, list) or len(data_ranges) == 0:
            print(f"‚ùå [BATCH_UPDATE_FORMAT] Data ranges kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng")
            return False
        
        # L·∫•y sheet ID
        sheet_id = self._get_sheet_id(spreadsheet_id, sheet_name)
        if sheet_id is None:
            print(f"‚ùå [BATCH_UPDATE_FORMAT] Kh√¥ng th·ªÉ l·∫•y sheet ID cho sheet '{sheet_name}'")
            return False
        
        # Validate v√† sanitize t·ª´ng range, ƒë·ªìng th·ªùi t·∫°o formatting requests
        sanitized_ranges = []
        format_requests = []
        
        for idx, range_data in enumerate(data_ranges):
            if not isinstance(range_data, dict):
                print(f"‚ö†Ô∏è [BATCH_UPDATE_FORMAT] Range {idx} kh√¥ng ph·∫£i dict, b·ªè qua")
                continue
            
            if 'range' not in range_data or 'values' not in range_data:
                print(f"‚ö†Ô∏è [BATCH_UPDATE_FORMAT] Range {idx} thi·∫øu 'range' ho·∫∑c 'values', b·ªè qua")
                continue
            
            range_name = str(range_data['range']).strip()
            values = range_data['values']
            
            if not range_name:
                print(f"‚ö†Ô∏è [BATCH_UPDATE_FORMAT] Range {idx} c√≥ t√™n r·ªóng, b·ªè qua")
                continue
            
            if not isinstance(values, list) or len(values) == 0:
                print(f"‚ö†Ô∏è [BATCH_UPDATE_FORMAT] Range {idx} c√≥ values r·ªóng, b·ªè qua")
                continue
            
            # Sanitize values
            sanitized_values = []
            for row in values:
                if not isinstance(row, list):
                    row = [row]
                sanitized_row = []
                for cell_value in row:
                    if cell_value is None:
                        sanitized_row.append('')
                    else:
                        cell_str = str(cell_value).strip()
                        sanitized_row.append(cell_str)
                sanitized_values.append(sanitized_row)
            
            sanitized_ranges.append({
                'range': range_name,
                'values': sanitized_values
            })
            
            # T·∫°o formatting request cho t·ª´ng cell trong range n√†y
            # Parse A1 notation ƒë·ªÉ l·∫•y GridRange
            try:
                # T√°ch ph·∫ßn range (b·ªè ph·∫ßn sheet name)
                if '!' in range_name:
                    range_part = range_name.split('!')[1]
                else:
                    range_part = range_name
                
                # Parse c·ªôt v√† d√≤ng (v√≠ d·ª•: G5 -> column=6, row=4 (0-based))
                import re
                match = re.match(r'([A-Z]+)(\d+)', range_part)
                if match:
                    col_str = match.group(1)
                    row_str = match.group(2)
                    
                    # Chuy·ªÉn c·ªôt sang index (A=0, B=1, ..., G=6, ...)
                    col_index = 0
                    for char in col_str:
                        col_index = col_index * 26 + (ord(char) - ord('A') + 1)
                    col_index -= 1  # 0-based
                    
                    # Chuy·ªÉn d√≤ng sang index (1-based -> 0-based)
                    start_row_index = int(row_str) - 1
                    
                    # T√≠nh s·ªë d√≤ng v√† s·ªë c·ªôt th·ª±c t·∫ø t·ª´ d·ªØ li·ªáu
                    num_rows = len(sanitized_values)
                    # T√¨m s·ªë c·ªôt t·ªëi ƒëa trong t·∫•t c·∫£ c√°c d√≤ng
                    num_cols = 1
                    if sanitized_values:
                        num_cols = max(len(row) for row in sanitized_values) if sanitized_values else 1
                    
                    # Format cho to√†n b·ªô range (t·∫•t c·∫£ c√°c cells ƒë∆∞·ª£c c·∫≠p nh·∫≠t)
                    # M·ªói range c√≥ th·ªÉ l√† m·ªôt cell ƒë∆°n ho·∫∑c m·ªôt v√πng cells
                    format_requests.append({
                        'repeatCell': {
                            'range': {
                                'sheetId': sheet_id,
                                'startRowIndex': start_row_index,
                                'endRowIndex': start_row_index + num_rows,
                                'startColumnIndex': col_index,
                                'endColumnIndex': col_index + num_cols
                            },
                            'cell': {
                                'userEnteredFormat': {
                                    'horizontalAlignment': 'CENTER',
                                    'verticalAlignment': 'MIDDLE',
                                    'textFormat': {
                                        'fontFamily': 'Google Sans',
                                        'fontSize': 9
                                    }
                                }
                            },
                            'fields': 'userEnteredFormat.horizontalAlignment,userEnteredFormat.verticalAlignment,userEnteredFormat.textFormat.fontFamily,userEnteredFormat.textFormat.fontSize'
                        }
                    })
            except Exception as e:
                print(f"‚ö†Ô∏è [BATCH_UPDATE_FORMAT] Kh√¥ng th·ªÉ parse range {range_name} ƒë·ªÉ format: {e}")
        
        if len(sanitized_ranges) == 0:
            print(f"‚ùå [BATCH_UPDATE_FORMAT] Kh√¥ng c√≥ range h·ª£p l·ªá n√†o sau khi sanitize")
            return False

        # Retry logic v·ªõi exponential backoff - TƒÇNG S·ªê L·∫¶N V√Ä DELAY
        max_retries = 5  # TƒÉng t·ª´ 3 l√™n 5
        base_retry_delay = 2  # TƒÉng t·ª´ 1 l√™n 2
        rate_limit_delay = 30  # Delay ƒë·∫∑c bi·ªát cho rate limit errors

        for attempt in range(max_retries):
            try:
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                if attempt > 0:
                    print(f"üîÑ [BATCH_UPDATE_FORMAT] L·∫ßn th·ª≠ {attempt + 1}/{max_retries} - {timestamp}")

                if not self.ensure_valid_token():
                    print("‚ùå [BATCH_UPDATE_FORMAT] Kh√¥ng th·ªÉ ƒë·∫£m b·∫£o token h·ª£p l·ªá")
                    return False

                if not self.sheets_service:
                    print("‚ùå [BATCH_UPDATE_FORMAT] Sheets service kh√¥ng kh·∫£ d·ª•ng")
                    return False

                # Ki·ªÉm tra rate limit tr∆∞·ªõc khi g·ªçi API
                self._check_and_wait_rate_limit()

                # B∆∞·ªõc 1: C·∫≠p nh·∫≠t values
                values_body = {
                    'valueInputOption': 'USER_ENTERED',
                    'data': sanitized_ranges
                }

                values_result = self.sheets_service.spreadsheets().values().batchUpdate(
                    spreadsheetId=spreadsheet_id,
                    body=values_body
                ).execute()

                updated = values_result.get('totalUpdatedCells', 0)
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                print(f"‚úÖ [BATCH_UPDATE_FORMAT] {timestamp} - C·∫≠p nh·∫≠t values th√†nh c√¥ng, s·ªë √¥: {updated}")

                # Ki·ªÉm tra rate limit tr∆∞·ªõc khi format
                self._check_and_wait_rate_limit()

                # B∆∞·ªõc 2: √Åp d·ª•ng formatting ngay sau ƒë√≥
                if format_requests:
                    format_body = {
                        'requests': format_requests
                    }

                    format_result = self.sheets_service.spreadsheets().batchUpdate(
                        spreadsheetId=spreadsheet_id,
                        body=format_body
                    ).execute()

                    timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                    print(f"‚úÖ [BATCH_UPDATE_FORMAT] {timestamp} - √Åp d·ª•ng formatting th√†nh c√¥ng cho {len(format_requests)} ranges")

                return True

            except Exception as e:
                error_str = str(e)
                error_type = type(e).__name__
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]

                # Ph√¢n lo·∫°i l·ªói
                is_retryable = False
                is_rate_limit = False
                if '429' in error_str or 'quota' in error_str.lower() or 'rate limit' in error_str.lower():
                    is_retryable = True
                    is_rate_limit = True
                    print(f"‚ö†Ô∏è [BATCH_UPDATE_FORMAT] {timestamp} - Rate limit/quota error (s·∫Ω ƒë·ª£i l√¢u h∆°n): {error_str}")
                elif '503' in error_str or '500' in error_str or 'timeout' in error_str.lower():
                    is_retryable = True
                    print(f"‚ö†Ô∏è [BATCH_UPDATE_FORMAT] {timestamp} - Server error (c√≥ th·ªÉ retry): {error_str}")
                elif 'PERMISSION_DENIED' in error_str or 'permission' in error_str.lower():
                    print(f"‚ùå [BATCH_UPDATE_FORMAT] {timestamp} - L·ªói quy·ªÅn truy c·∫≠p: {error_str}")
                    return False
                elif 'NOT_FOUND' in error_str or 'not found' in error_str.lower():
                    print(f"‚ùå [BATCH_UPDATE_FORMAT] {timestamp} - Spreadsheet ho·∫∑c sheet kh√¥ng t·ªìn t·∫°i: {error_str}")
                    return False
                else:
                    print(f"‚ùå [BATCH_UPDATE_FORMAT] {timestamp} - L·ªói kh√¥ng x√°c ƒë·ªãnh: {error_type} - {error_str}")

                # Retry n·∫øu c√≥ th·ªÉ
                if is_retryable and attempt < max_retries - 1:
                    # ƒê·ª£i l√¢u h∆°n n·∫øu l√† rate limit error
                    if is_rate_limit:
                        wait_time = rate_limit_delay + (attempt * 10)  # 30, 40, 50, 60 gi√¢y
                    else:
                        wait_time = base_retry_delay * (2 ** attempt)  # 2, 4, 8, 16 gi√¢y
                    print(f"‚è≥ [BATCH_UPDATE_FORMAT] ƒê·ª£i {wait_time} gi√¢y tr∆∞·ªõc khi retry...")
                    time.sleep(wait_time)
                else:
                    import traceback
                    print(f"‚ùå [BATCH_UPDATE_FORMAT_FAILED] {timestamp} - Batch update th·∫•t b·∫°i sau {attempt + 1} l·∫ßn th·ª≠")
                    print(f"   Error Type: {error_type}")
                    print(f"   Error Message: {error_str}")
                    print(f"   Traceback:\n{traceback.format_exc()}")
                    return False

        return False

    def center_align_cells(self, spreadsheet_id, sheet_name, ranges):
        """CƒÉn gi·ªØa c√°c cells trong Google Sheet.
        
        Args:
            spreadsheet_id (str): ID c·ªßa spreadsheet
            sheet_name (str): T√™n sheet
            ranges (list[str]): Danh s√°ch c√°c range c·∫ßn cƒÉn gi·ªØa (v√≠ d·ª•: ['Sheet!G5', 'Sheet!K5'])
        
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i
        """
        from datetime import datetime as dt
        
        # Validation ƒë·∫ßu v√†o
        if not spreadsheet_id or not isinstance(spreadsheet_id, str) or not spreadsheet_id.strip():
            print(f"‚ùå [CENTER_ALIGN] Spreadsheet ID kh√¥ng h·ª£p l·ªá: {spreadsheet_id}")
            return False
        
        if not sheet_name or not isinstance(sheet_name, str) or not sheet_name.strip():
            print(f"‚ùå [CENTER_ALIGN] Sheet name kh√¥ng h·ª£p l·ªá: {sheet_name}")
            return False
        
        if not ranges or not isinstance(ranges, list) or len(ranges) == 0:
            return True  # Kh√¥ng c√≥ g√¨ ƒë·ªÉ cƒÉn gi·ªØa, coi nh∆∞ th√†nh c√¥ng
        
        try:
            if not self.ensure_valid_token():
                print("‚ùå [CENTER_ALIGN] Kh√¥ng th·ªÉ ƒë·∫£m b·∫£o token h·ª£p l·ªá")
                return False
            
            if not self.sheets_service:
                print("‚ùå [CENTER_ALIGN] Sheets service kh√¥ng kh·∫£ d·ª•ng")
                return False
            
            # L·∫•y sheet ID
            sheet_id = self._get_sheet_id(spreadsheet_id, sheet_name)
            if sheet_id is None:
                print("‚ö†Ô∏è [CENTER_ALIGN] Kh√¥ng th·ªÉ l·∫•y sheet ID")
                return False
            
            # Chuy·ªÉn ƒë·ªïi A1 notation sang GridRange
            def a1_to_grid_range(a1_range, sheet_id):
                """Chuy·ªÉn ƒë·ªïi A1 notation (Sheet!G5) sang GridRange format."""
                try:
                    # T√°ch ph·∫ßn range (b·ªè ph·∫ßn sheet name)
                    if '!' in a1_range:
                        range_part = a1_range.split('!')[1]
                    else:
                        range_part = a1_range
                    
                    # Parse c·ªôt v√† d√≤ng (v√≠ d·ª•: G5 -> column=6, row=4 (0-based))
                    import re
                    match = re.match(r'([A-Z]+)(\d+)', range_part)
                    if not match:
                        return None
                    
                    col_str = match.group(1)
                    row_str = match.group(2)
                    
                    # Chuy·ªÉn c·ªôt sang index (A=0, B=1, ..., G=6, ...)
                    col_index = 0
                    for char in col_str:
                        col_index = col_index * 26 + (ord(char) - ord('A') + 1)
                    col_index -= 1  # 0-based
                    
                    # Chuy·ªÉn d√≤ng sang index (1-based -> 0-based)
                    row_index = int(row_str) - 1
                    
                    return {
                        'sheetId': sheet_id,
                        'startRowIndex': row_index,
                        'endRowIndex': row_index + 1,
                        'startColumnIndex': col_index,
                        'endColumnIndex': col_index + 1
                    }
                except Exception as e:
                    print(f"‚ö†Ô∏è L·ªói parse range {a1_range}: {e}")
                    return None
            
            # T·∫°o requests ƒë·ªÉ cƒÉn gi·ªØa c√°c cells
            requests = []
            for range_str in ranges:
                grid_range = a1_to_grid_range(range_str, sheet_id)
                if grid_range:
                    requests.append({
                        'repeatCell': {
                            'range': grid_range,
                            'cell': {
                                'userEnteredFormat': {
                                    'horizontalAlignment': 'CENTER',
                                    'verticalAlignment': 'MIDDLE',
                                    'textFormat': {
                                        'fontFamily': 'Google Sans',
                                        'fontSize': 9
                                    }
                                }
                            },
                            'fields': 'userEnteredFormat.horizontalAlignment,userEnteredFormat.verticalAlignment,userEnteredFormat.textFormat.fontFamily,userEnteredFormat.textFormat.fontSize'
                        }
                    })
            
            if not requests:
                print("‚ö†Ô∏è [CENTER_ALIGN] Kh√¥ng c√≥ requests h·ª£p l·ªá ƒë·ªÉ cƒÉn gi·ªØa")
                return False
            
            body = {
                'requests': requests
            }
            
            result = self.sheets_service.spreadsheets().batchUpdate(
                spreadsheetId=spreadsheet_id,
                body=body
            ).execute()
            
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            print(f"‚úÖ [CENTER_ALIGN_SUCCESS] {timestamp} - CƒÉn gi·ªØa th√†nh c√¥ng cho {len(requests)} cells")
            return True
        except Exception as e:
            error_str = str(e)
            error_type = type(e).__name__
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            
            # CƒÉn gi·ªØa kh√¥ng ph·∫£i l√† ch·ª©c nƒÉng b·∫Øt bu·ªôc, n·∫øu l·ªói ch·ªâ log warning
            if 'PERMISSION_DENIED' in error_str or 'NOT_FOUND' in error_str:
                print(f"‚ö†Ô∏è [CENTER_ALIGN] {timestamp} - Kh√¥ng th·ªÉ cƒÉn gi·ªØa (l·ªói quy·ªÅn/t√¨m th·∫•y): {error_str}")
            else:
                print(f"‚ö†Ô∏è [CENTER_ALIGN] {timestamp} - Kh√¥ng th·ªÉ cƒÉn gi·ªØa cells: {error_type} - {error_str}")
                import traceback
                print(traceback.format_exc())
            
            # V·∫´n return False nh∆∞ng kh√¥ng crash app
            return False

    def _check_and_wait_rate_limit(self):
        """Ki·ªÉm tra v√† ƒë·ª£i n·∫øu s·∫Øp v∆∞·ª£t rate limit."""
        import time
        current_time = time.time()

        # X√≥a c√°c timestamps qu√° 60 gi√¢y
        self._api_call_timestamps = [
            t for t in self._api_call_timestamps
            if current_time - t < self._rate_limit_window
        ]

        # N·∫øu s·∫Øp v∆∞·ª£t ng∆∞·ª°ng, ƒë·ª£i
        if len(self._api_call_timestamps) >= self._rate_limit_max_calls:
            oldest_call = min(self._api_call_timestamps)
            wait_time = self._rate_limit_window - (current_time - oldest_call) + 1
            if wait_time > 0:
                print(f"‚è≥ [RATE_LIMIT] ƒê·ª£i {wait_time:.1f}s ƒë·ªÉ tr√°nh v∆∞·ª£t quota (ƒë√£ c√≥ {len(self._api_call_timestamps)} calls trong 60s)...")
                time.sleep(wait_time)
                # X√≥a l·∫°i sau khi ƒë·ª£i
                current_time = time.time()
                self._api_call_timestamps = [
                    t for t in self._api_call_timestamps
                    if current_time - t < self._rate_limit_window
                ]

        # Ghi nh·∫≠n call m·ªõi
        self._api_call_timestamps.append(time.time())

    def _get_sheet_id(self, spreadsheet_id, sheet_name):
        """L·∫•y sheet ID t·ª´ t√™n sheet - C√ì CACHE ƒë·ªÉ gi·∫£m API calls."""
        # Ki·ªÉm tra cache tr∆∞·ªõc
        cache_key = f"{spreadsheet_id}:{sheet_name}"
        if cache_key in self._sheet_id_cache:
            return self._sheet_id_cache[cache_key]

        try:
            if not self.ensure_valid_token():
                return None

            # Ki·ªÉm tra rate limit tr∆∞·ªõc khi g·ªçi API
            self._check_and_wait_rate_limit()

            spreadsheet = self.sheets_service.spreadsheets().get(
                spreadsheetId=spreadsheet_id
            ).execute()

            sheets = spreadsheet.get('sheets', [])

            # Cache t·∫•t c·∫£ sheet IDs trong spreadsheet n√†y
            for sheet in sheets:
                title = sheet['properties']['title']
                sheet_id = sheet['properties']['sheetId']
                key = f"{spreadsheet_id}:{title}"
                self._sheet_id_cache[key] = sheet_id

            # Tr·∫£ v·ªÅ sheet ID ƒë∆∞·ª£c y√™u c·∫ßu
            return self._sheet_id_cache.get(cache_key)
        except Exception as e:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y sheet ID: {e}")
            return None

    def _column_index_to_letter(self, index_zero_based):
        # 0 -> A, 1 -> B, ...
        letter = ''
        index = index_zero_based
        while True:
            index, remainder = divmod(index, 26)
            letter = chr(65 + remainder) + letter
            if index == 0:
                break
            index -= 1
        return letter

    def _normalize_cell(self, s):
        try:
            if s is None:
                return ''
            return str(s).strip().lower()
        except Exception:
            return ''

    def _date_variants(self, date_str_iso):
        # Tr·∫£ v·ªÅ c√°c bi·∫øn th·ªÉ ƒë·ªÉ d√≤ kh·ªõp ng√†y trong sheet
        # D·ª±a tr√™n c·∫•u tr√∫c th·ª±c t·∫ø: 2025/12/1 (YYYY/MM/D) - kh√¥ng c√≥ s·ªë 0 ·ªü ƒë·∫ßu
        try:
            # Th·ª≠ parse nhi·ªÅu format ƒë·∫ßu v√†o
            dt = None
            for fmt in ['%Y-%m-%d', '%Y/%m/%d', '%d/%m/%Y', '%m/%d/%Y', '%d-%m-%Y']:
                try:
                    dt = datetime.strptime(date_str_iso, fmt)
                    break
                except ValueError:
                    continue
            
            if dt is None:
                print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ parse ng√†y: {date_str_iso}")
                return [date_str_iso]
            
            # L·∫•y c√°c gi√° tr·ªã ng√†y, th√°ng, nƒÉm kh√¥ng c√≥ s·ªë 0 ·ªü ƒë·∫ßu
            day_no_zero = str(dt.day)  # 1 thay v√¨ 01
            month_no_zero = str(dt.month)  # 12 thay v√¨ 12 (gi·ªØ nguy√™n n·∫øu >= 10)
            year = str(dt.year)
            
            # T·∫°o danh s√°ch bi·∫øn th·ªÉ bao g·ªìm c·∫£ c√≥ v√† kh√¥ng c√≥ s·ªë 0
            variants = [
                # Format c√≥ s·ªë 0 ·ªü ƒë·∫ßu (chu·∫©n)
                dt.strftime('%Y/%m/%d'),  # 2025/12/01
                dt.strftime('%Y-%m-%d'),  # 2025-12-01
                dt.strftime('%d/%m/%Y'),  # 01/12/2025
                dt.strftime('%m/%d/%Y'),  # 12/01/2025
                dt.strftime('%d-%m-%Y'),  # 01-12-2025
                # Format KH√îNG c√≥ s·ªë 0 ·ªü ƒë·∫ßu (nh∆∞ trong Google Sheet th·ª±c t·∫ø)
                f"{year}/{month_no_zero}/{day_no_zero}",  # 2025/12/1
                f"{year}-{month_no_zero}-{day_no_zero}",  # 2025-12-1
                f"{day_no_zero}/{month_no_zero}/{year}",  # 1/12/2025
                f"{month_no_zero}/{day_no_zero}/{year}",  # 12/1/2025
                f"{day_no_zero}-{month_no_zero}-{year}",  # 1-12-2025
                # Format c√≥ s·ªë 0 ·ªü th√°ng nh∆∞ng kh√¥ng c√≥ ·ªü ng√†y
                f"{year}/{dt.strftime('%m')}/{day_no_zero}",  # 2025/12/1
                f"{year}-{dt.strftime('%m')}-{day_no_zero}",  # 2025-12-1
            ]
            
            # Lo·∫°i b·ªè tr√πng l·∫∑p v√† gi·ªØ th·ª© t·ª±
            seen = set()
            unique_variants = []
            for v in variants:
                if v not in seen:
                    seen.add(v)
                    unique_variants.append(v)
            
            return unique_variants
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói parse ng√†y {date_str_iso}: {e}")
            return [date_str_iso]

    def _read_sheet_values(self, spreadsheet_id, sheet_name, a1_range='A1:ZZ1000'):
        """ƒê·ªçc gi√° tr·ªã t·ª´ sheet - C·∫¢I THI·ªÜN: Ki·ªÉm tra sheet t·ªìn t·∫°i tr∆∞·ªõc v·ªõi retry logic v√† rate limiting"""
        import time
        from datetime import datetime as dt

        # Validation ƒë·∫ßu v√†o
        if not spreadsheet_id or not isinstance(spreadsheet_id, str) or not spreadsheet_id.strip():
            print(f"‚ùå [READ_SHEET] Spreadsheet ID kh√¥ng h·ª£p l·ªá: {spreadsheet_id}")
            return []

        if not sheet_name or not isinstance(sheet_name, str) or not sheet_name.strip():
            print(f"‚ùå [READ_SHEET] Sheet name kh√¥ng h·ª£p l·ªá: {sheet_name}")
            return []

        # Retry logic v·ªõi exponential backoff - TƒÇNG S·ªê L·∫¶N V√Ä DELAY CHO RATE LIMIT
        max_retries = 5  # TƒÉng t·ª´ 3 l√™n 5
        base_retry_delay = 2  # TƒÉng t·ª´ 1 l√™n 2 gi√¢y
        rate_limit_delay = 30  # Delay ƒë·∫∑c bi·ªát cho rate limit errors (30 gi√¢y)

        for attempt in range(max_retries):
            try:
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                if attempt > 0:
                    print(f"üîÑ [READ_SHEET] L·∫ßn th·ª≠ {attempt + 1}/{max_retries} - {timestamp}")

                if not self.ensure_valid_token():
                    print("‚ùå [READ_SHEET] Kh√¥ng th·ªÉ ƒë·∫£m b·∫£o token h·ª£p l·ªá")
                    return []

                if not self.sheets_service:
                    print("‚ùå [READ_SHEET] Sheets service kh√¥ng kh·∫£ d·ª•ng")
                    return []

                # Ki·ªÉm tra rate limit tr∆∞·ªõc khi g·ªçi API
                self._check_and_wait_rate_limit()

                # Ki·ªÉm tra sheet c√≥ t·ªìn t·∫°i kh√¥ng - d√πng cache n·∫øu c√≥
                cache_key = f"{spreadsheet_id}:{sheet_name}"
                if cache_key not in self._sheet_id_cache:
                    try:
                        spreadsheet = self.sheets_service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
                        sheets = spreadsheet.get('sheets', [])

                        # Cache t·∫•t c·∫£ sheet IDs
                        for sheet in sheets:
                            title = sheet['properties']['title']
                            sheet_id = sheet['properties']['sheetId']
                            key = f"{spreadsheet_id}:{title}"
                            self._sheet_id_cache[key] = sheet_id

                        if cache_key not in self._sheet_id_cache:
                            sheet_names = [sheet['properties']['title'] for sheet in sheets]
                            print(f"‚ö†Ô∏è [READ_SHEET] Sheet '{sheet_name}' kh√¥ng t·ªìn t·∫°i trong spreadsheet")
                            print(f"   üìã C√°c sheet hi·ªán c√≥: {', '.join(sheet_names)}")
                            print(f"   ‚ö†Ô∏è Vui l√≤ng t·∫°o sheet '{sheet_name}' trong Google Sheet tr∆∞·ªõc khi c·∫≠p nh·∫≠t")
                            return []
                    except Exception as check_err:
                        error_str = str(check_err)
                        # N·∫øu l√† l·ªói quy·ªÅn ho·∫∑c kh√¥ng t√¨m th·∫•y, kh√¥ng retry
                        if 'PERMISSION_DENIED' in error_str or 'NOT_FOUND' in error_str:
                            print(f"‚ùå [READ_SHEET] L·ªói khi ki·ªÉm tra sheet: {error_str}")
                            return []
                        print(f"‚ö†Ô∏è [READ_SHEET] Kh√¥ng th·ªÉ ki·ªÉm tra sheet t·ªìn t·∫°i: {check_err}")
                        # V·∫´n ti·∫øp t·ª•c th·ª≠ ƒë·ªçc, c√≥ th·ªÉ sheet t·ªìn t·∫°i nh∆∞ng c√≥ l·ªói khi check

                # Ki·ªÉm tra rate limit tr∆∞·ªõc khi ƒë·ªçc
                self._check_and_wait_rate_limit()

                # ƒê·ªçc d·ªØ li·ªáu t·ª´ sheet
                resp = self.sheets_service.spreadsheets().values().get(
                    spreadsheetId=spreadsheet_id,
                    range=f"{sheet_name}!{a1_range}"
                ).execute()

                values = resp.get('values', [])
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                print(f"‚úÖ [READ_SHEET_SUCCESS] {timestamp} - ƒê·ªçc th√†nh c√¥ng {len(values)} d√≤ng t·ª´ sheet '{sheet_name}'")
                return values

            except Exception as e:
                error_msg = str(e)
                error_type = type(e).__name__
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]

                # Ph√¢n lo·∫°i l·ªói
                is_retryable = False
                is_rate_limit = False
                if '429' in error_msg or 'quota' in error_msg.lower() or 'rate limit' in error_msg.lower():
                    is_retryable = True
                    is_rate_limit = True
                    print(f"‚ö†Ô∏è [READ_SHEET] {timestamp} - Rate limit/quota error (s·∫Ω ƒë·ª£i l√¢u h∆°n): {error_msg}")
                elif '503' in error_msg or '500' in error_msg or 'timeout' in error_msg.lower():
                    is_retryable = True
                    print(f"‚ö†Ô∏è [READ_SHEET] {timestamp} - Server error (c√≥ th·ªÉ retry): {error_msg}")
                elif 'PERMISSION_DENIED' in error_msg or 'permission' in error_msg.lower():
                    print(f"‚ùå [READ_SHEET] {timestamp} - L·ªói quy·ªÅn truy c·∫≠p: {error_msg}")
                    return []  # Kh√¥ng retry l·ªói quy·ªÅn
                elif 'NOT_FOUND' in error_msg or 'not found' in error_msg.lower():
                    print(f"‚ùå [READ_SHEET] {timestamp} - Spreadsheet ho·∫∑c sheet kh√¥ng t·ªìn t·∫°i: {error_msg}")
                    return []  # Kh√¥ng retry l·ªói kh√¥ng t√¨m th·∫•y
                elif 'Unable to parse range' in error_msg or 'does not exist' in error_msg.lower():
                    print(f"‚ùå [READ_SHEET] {timestamp} - Sheet '{sheet_name}' kh√¥ng t·ªìn t·∫°i trong spreadsheet")
                    print(f"   ‚ö†Ô∏è Vui l√≤ng t·∫°o sheet '{sheet_name}' trong Google Sheet")
                    return []  # Kh√¥ng retry l·ªói parse range
                else:
                    print(f"‚ùå [READ_SHEET] {timestamp} - L·ªói kh√¥ng x√°c ƒë·ªãnh: {error_type} - {error_msg}")

                # Retry n·∫øu c√≥ th·ªÉ
                if is_retryable and attempt < max_retries - 1:
                    # ƒê·ª£i l√¢u h∆°n n·∫øu l√† rate limit error
                    if is_rate_limit:
                        wait_time = rate_limit_delay + (attempt * 10)  # 30, 40, 50, 60 gi√¢y
                    else:
                        wait_time = base_retry_delay * (2 ** attempt)  # 2, 4, 8, 16 gi√¢y
                    print(f"‚è≥ [READ_SHEET] ƒê·ª£i {wait_time} gi√¢y tr∆∞·ªõc khi retry...")
                    time.sleep(wait_time)
                else:
                    # Kh√¥ng th·ªÉ retry ho·∫∑c ƒë√£ h·∫øt s·ªë l·∫ßn th·ª≠
                    import traceback
                    print(f"‚ùå [READ_SHEET_FAILED] {timestamp} - ƒê·ªçc sheet th·∫•t b·∫°i sau {attempt + 1} l·∫ßn th·ª≠")
                    print(f"   Error Type: {error_type}")
                    print(f"   Error Message: {error_msg}")
                    print(f"   Traceback:\n{traceback.format_exc()}")
                    return []
        
        return []

    def _build_header_map(self, header_row):
        """X√¢y d·ª±ng map t·ª´ header row"""
        header_map = {}
        for idx, cell in enumerate(header_row):
            normalized = self._normalize_cell(cell)
            if normalized:
                header_map[normalized] = idx
        return header_map

    def _find_best_header(self, header_map, candidates):
        """T√¨m header t·ªët nh·∫•t t·ª´ danh s√°ch candidates"""
        for cand in candidates:
            normalized = self._normalize_cell(cand)
            if normalized in header_map:
                return header_map[normalized]
        return None

    def _find_row_by_date(self, all_rows, date_str_iso, date_header_index=None):
        """T√¨m d√≤ng theo ng√†y trong sheet"""
        variants = self._date_variants(date_str_iso)
        date_col_index = date_header_index if date_header_index is not None else 0
        
        for i, row in enumerate(all_rows):
            if len(row) <= date_col_index:
                continue
            cell_value = str(row[date_col_index]).strip()
            for variant in variants:
                if variant in cell_value:
                    return i + 1  # Tr·∫£ v·ªÅ s·ªë d√≤ng (1-based)
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y d√≤ng ph√π h·ª£p")
        return None

    def update_timesheet_for_attendance(self, spreadsheet_id, sheet_name, attendance_data):
        """C·∫≠p nh·∫≠t nhi·ªÅu tr∆∞·ªùng theo ng√†y d·ª±a tr√™n ti√™u ƒë·ªÅ c·ªôt; fallback v·ªÅ c·∫≠p nh·∫≠t 1 √¥.

        attendance_data t·ªëi thi·ªÉu n√™n c√≥: date (YYYY-MM-DD), status, note, total_hours,
        regular_work_hours, break_time, overtime_before_22, overtime_after_22,
        doi_ung, approved_by, approved_at
        """
        import sys
        from datetime import datetime as dt
        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        
        # Helper function for safe logging
        def _log(msg):
            try:
                # Use sys.stderr which is less likely to be buffered/closed than stdout
                # and ignore errors if it is closed
                import sys
                print(msg, file=sys.stderr, flush=True)
            except Exception:
                pass

        try:
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            
            # VALIDATION ƒê·∫¶U V√ÄO - ƒê·∫£m b·∫£o 100% kh√¥ng l·ªói
            if not spreadsheet_id or not isinstance(spreadsheet_id, str) or not spreadsheet_id.strip():
                _log(f"‚ùå [UPDATE_TIMESHEET] {timestamp} - Spreadsheet ID kh√¥ng h·ª£p l·ªá: {spreadsheet_id}")
                return False
            
            if not sheet_name or not isinstance(sheet_name, str) or not sheet_name.strip():
                _log(f"‚ùå [UPDATE_TIMESHEET] {timestamp} - Sheet name kh√¥ng h·ª£p l·ªá: {sheet_name}")
                return False
            
            if not attendance_data or not isinstance(attendance_data, dict):
                _log(f"‚ùå [UPDATE_TIMESHEET] {timestamp} - Attendance data kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng")
                return False
            
            # Ki·ªÉm tra date c√≥ t·ªìn t·∫°i v√† h·ª£p l·ªá kh√¥ng
            date_str = attendance_data.get('date', '')
            if not date_str:
                _log(f"‚ùå [UPDATE_TIMESHEET] {timestamp} - Attendance data thi·∫øu 'date'")
                return False
            
            try:
                # Validate date format
                dt.strptime(date_str, "%Y-%m-%d")
            except ValueError:
                _log(f"‚ùå [UPDATE_TIMESHEET] {timestamp} - Date format kh√¥ng h·ª£p l·ªá: {date_str} (c·∫ßn YYYY-MM-DD)")
                return False
            
            _log(f"\n{'='*80}")
            _log(f"üöÄ [UPDATE_TIMESHEET_START] {timestamp} - B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t timesheet")
            _log(f"   üìä Spreadsheet ID: {spreadsheet_id}")
            _log(f"   üìã Sheet Name: {sheet_name}")
            _log(f"   üìÖ Date: {attendance_data.get('date', 'Unknown')}")
            _log(f"   üë§ Employee: {attendance_data.get('user_name', 'Unknown')}")
            _log(f"{'='*80}")

            # ƒê·∫£m b·∫£o b·ªô sao l∆∞u ƒë·ªãnh k·ª≥ ƒë√£ ch·∫°y n·ªÅn
            try:
                ensure_backup_scheduler_started()
            except Exception as _e:
                _log(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông backup scheduler: {_e}")
            
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            _log(f"üîç [TOKEN_CHECK] {timestamp} - Ki·ªÉm tra token...")
            
            if not self.ensure_valid_token():
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                _log(f"‚ùå [TOKEN_INVALID] {timestamp} - Kh√¥ng th·ªÉ ƒë·∫£m b·∫£o token h·ª£p l·ªá")
                return False

            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            _log(f"‚úÖ [TOKEN_VALID] {timestamp} - Token h·ª£p l·ªá")
            _log(f"üîç [READ_SHEET] {timestamp} - ƒêang ƒë·ªçc d·ªØ li·ªáu t·ª´ sheet...")
            
            rows = self._read_sheet_values(spreadsheet_id, sheet_name)
            
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            _log(f"üìä [READ_SHEET_DONE] {timestamp} - S·ªë d√≤ng ƒë·ªçc ƒë∆∞·ª£c: {len(rows)}")
            
            if not rows:
                _log("‚ö†Ô∏è Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c d·ªØ li·ªáu sheet, fallback v·ªÅ 1 √¥")
                return self.update_sheet_value(
                    spreadsheet_id, sheet_name, 35, 'M',
                    f"Ph√™ duy·ªát b·ªüi {attendance_data.get('approved_by','')} - {attendance_data.get('approved_at','')}"
                )

            _log(f"üìã Header row: {rows[0] if rows else 'Empty'}")
            header = rows[0]
            header_map = self._build_header_map(header)
            _log(f"üó∫Ô∏è Header map: {header_map}")

            # X√°c ƒë·ªãnh c·ªôt ng√†y v√† d√≤ng t∆∞∆°ng ·ª©ng v·ªõi ng√†y
            # D·ª±a tr√™n c·∫•u tr√∫c th·ª±c t·∫ø: c·ªôt A (index 0) ch·ª©a ng√†y theo format 2025/10/13
            date_iso = attendance_data.get('date', '')
            # C·ªôt A lu√¥n l√† c·ªôt ng√†y (index 0) trong timesheet
            date_col_index = 0
            
            _log(f"üîç T√¨m d√≤ng theo ng√†y: {date_iso}")
            _log(f"üìÖ C√°c bi·∫øn th·ªÉ ng√†y: {self._date_variants(date_iso)}")
            _log(f"üéØ T√¨m ki·∫øm trong c·ªôt {date_col_index} (c·ªôt A)")
            
            target_row_index = self._find_row_by_date(rows, date_iso, date_col_index)
            
            if target_row_index:
                _log(f"‚úÖ T√¨m th·∫•y d√≤ng {target_row_index} cho ng√†y {date_iso}")
            else:
                _log(f"‚ùå Kh√¥ng t√¨m th·∫•y d√≤ng cho ng√†y {date_iso}")
                # Debug: in ra m·ªôt v√†i d√≤ng ƒë·∫ßu ƒë·ªÉ ki·ªÉm tra
                _log("üìã M·ªôt v√†i d√≤ng ƒë·∫ßu trong sheet:")
                for i, row in enumerate(rows[:15]):
                    if len(row) > 0:
                        _log(f"   D√≤ng {i+1}: '{row[0] if len(row) > 0 else 'Empty'}'")
                
                # Debug: t√¨m ki·∫øm th·ªß c√¥ng trong c·ªôt A
                _log(f"üîç T√¨m ki·∫øm th·ªß c√¥ng ng√†y {date_iso} trong c·ªôt A:")
                for i, row in enumerate(rows):
                    if len(row) > 0 and row[0]:
                        cell_value = str(row[0]).strip()
                        if date_iso in cell_value or any(variant in cell_value for variant in self._date_variants(date_iso)):
                            _log(f"   ‚úÖ T√¨m th·∫•y kh·ªõp ·ªü d√≤ng {i+1}: '{cell_value}'")
                        elif '2025' in cell_value and '10' in cell_value and '13' in cell_value:
                            _log(f"   üîç C√≥ th·ªÉ kh·ªõp ·ªü d√≤ng {i+1}: '{cell_value}'")

            if not target_row_index:
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                _log(f"\n{'='*80}")
                _log(f"‚ùå [ROW_NOT_FOUND] {timestamp} - KH√îNG T√åM TH·∫§Y D√íNG THEO NG√ÄY")
                _log(f"   Date: {date_iso}")
                _log(f"   Sheet: {sheet_name}")
                _log(f"   Spreadsheet ID: {spreadsheet_id}")
                _log(f"   S·ªë d√≤ng trong sheet: {len(rows)}")
                _log(f"   ‚ö†Ô∏è Fallback v·ªÅ c·∫≠p nh·∫≠t 1 √¥ (M35)")
                _log(f"{'='*80}\n")
                result = self.update_sheet_value(
                    spreadsheet_id, sheet_name, 35, 'M',
                    f"Ph√™ duy·ªát b·ªüi {attendance_data.get('approved_by','')} - {attendance_data.get('approved_at','')}"
                )
                _log(f"üìä [FALLBACK_UPDATE] K·∫øt qu·∫£ fallback: {result}")
                return result

            # Mapping c·ªôt c·ª• th·ªÉ theo y√™u c·∫ßu
            # C·ªôt G: Gi·ªù v√†o (Actual clock-in time)
            # C·ªôt K: Gi·ªù ra (Actual Clock-out time: Until 10PM)
            # C·ªôt E: T·ªïng gi·ªù ngh·ªâ + ƒë·ªëi ·ª©ng (Planned Working Hours)
            # C·ªôt M: Gi·ªù c√¥ng (Actual working hours & JP_Hols Work)
            # C·ªôt N: TƒÉng ca tr∆∞·ªõc 22h („ÄêUntil 10 PM„ÄëWeekDay OT & WeekEnd & JP_hols OT & Viet_hols)
            # C·ªôt O: TƒÉng ca sau 22h („ÄêAfter 10 PM„ÄëWeekDay OT & WeekEnd & JP_hols OT & Viet_hols)
            # C·ªôt P: Ghi ch√∫ s·ªë ng√†y ngh·ªâ (∆∞u ti√™n d√πng cho ƒë∆°n ngh·ªâ ph√©p)
            
            # S·ª≠ d·ª•ng c·ªôt c·ªë ƒë·ªãnh thay v√¨ t√¨m ki·∫øm header
            column_mapping = {
                'check_in': 'G',      # Gi·ªù v√†o
                'check_out': 'K',     # Gi·ªù ra  
                'break_comp_total': 'E',  # T·ªïng gi·ªù ngh·ªâ + ƒë·ªëi ·ª©ng
                'regular_work_hours': 'M',  # Gi·ªù c√¥ng
                'overtime_before_22': 'N',  # TƒÉng ca tr∆∞·ªõc 22h
                'overtime_after_22': 'O',   # TƒÉng ca sau 22h
                'leave_summary': 'P'  # Ghi ch√∫ s·ªë ng√†y ngh·ªâ
            }

            updates = []

            def _is_effective_zero(v):
                try:
                    # None ho·∫∑c chu·ªói r·ªóng
                    if v is None:
                        return True
                    s = str(v).strip()
                    if s == '':
                        return True
                    # C√°c d·∫°ng s·ªë 0 ph·ªï bi·∫øn
                    zero_like = {'0', '0.0', '0.00', '00', '00.0', '00.00'}
                    if s in zero_like:
                        return True
                    # C√°c d·∫°ng th·ªùi gian 0
                    time_like_zero = {'0:00', '00:00', '0:0'}
                    if s in time_like_zero:
                        return True
                    # Tr∆∞·ªùng h·ª£p "0 h" ho·∫∑c "0 gi·ªù"
                    lower = s.lower()
                    if lower in {'0 h', '0h', '0 gi·ªù'}:
                        return True
                except Exception:
                    return False
                return False

            update_ranges = []  # L∆∞u c√°c ranges ƒë·ªÉ cƒÉn gi·ªØa sau

            # L·∫•y s·∫µn d·ªØ li·ªáu d√≤ng hi·ªán t·∫°i ƒë·ªÉ t√°i s·ª≠ d·ª•ng nhi·ªÅu l·∫ßn
            current_row_data = rows[target_row_index - 1] if target_row_index and len(rows) >= target_row_index else []
            
            def add_update(field_key, value):
                # V·ªõi c√°c c·ªôt OT/gi·ªù c√¥ng, c·∫ßn c·∫≠p nh·∫≠t c·∫£ khi = 0:00 ƒë·ªÉ tr√°nh gi·ªØ gi√° tr·ªã c≈© tr√™n sheet.
                always_write = {'regular_work_hours', 'overtime_before_22', 'overtime_after_22', 'break_comp_total'}
                if field_key not in always_write and _is_effective_zero(value):
                    return
                col_letter = column_mapping.get(field_key)
                if col_letter:
                    a1 = f"{sheet_name}!{col_letter}{target_row_index}"
                    updates.append({'range': a1, 'values': [[str(value or '0:00')]]})
                    update_ranges.append(a1)  # L∆∞u range ƒë·ªÉ cƒÉn gi·ªØa

            # T√≠nh t·ªïng gi·ªù ngh·ªâ + ƒë·ªëi ·ª©ng (c·ªôt E)
            print(f"\nüßÆ T√çNH TO√ÅN D·ªÆ LI·ªÜU:")
            break_time = attendance_data.get('break_time', '0:00')
            doi_ung_total = attendance_data.get('doi_ung_total', '0:00')  # HH:MM t·ªïng ƒë·ªëi ·ª©ng
            print(f"   ‚è∞ Gi·ªù ngh·ªâ: {break_time}")
            print(f"   üîÑ T·ªïng ƒë·ªëi ·ª©ng: {doi_ung_total}")
            
            # Chuy·ªÉn ƒë·ªïi gi·ªù ngh·ªâ v√† ƒë·ªëi ·ª©ng sang ph√∫t ƒë·ªÉ c·ªông
            def hhmm_to_minutes(hhmm_str):
                try:
                    if not hhmm_str or hhmm_str == '0:00':
                        return 0
                    if ':' in hhmm_str:
                        h, m = hhmm_str.split(':')
                        return int(h) * 60 + int(m)
                    return 0
                except (ValueError, AttributeError, TypeError):
                    return 0
            
            def minutes_to_hhmm(total_minutes):
                hours = total_minutes // 60
                minutes = total_minutes % 60
                return f"{hours}:{minutes:02d}"
            
            break_minutes = hhmm_to_minutes(break_time)
            doi_ung_minutes = hhmm_to_minutes(doi_ung_total)
            total_break_comp_minutes = break_minutes + doi_ung_minutes
            total_break_comp_hhmm = minutes_to_hhmm(total_break_comp_minutes)
            
            print(f"   üìä Gi·ªù ngh·ªâ (ph√∫t): {break_minutes}")
            print(f"   üìä T·ªïng ƒë·ªëi ·ª©ng (ph√∫t): {doi_ung_minutes}")
            print(f"   üìä T·ªïng ngh·ªâ + ƒë·ªëi ·ª©ng: {total_break_comp_hhmm}")

            print(f"\nüìù CHU·∫®N B·ªä C·∫¨P NH·∫¨T C√ÅC C·ªòT:")
            
            # PH√ÇN BI·ªÜT C√ÅC LO·∫†I NG√ÄY ƒê·ªÇ MAPPING CH√çNH X√ÅC
            holiday_type = attendance_data.get('holiday_type')
            is_holiday = attendance_data.get('is_holiday', False)
            is_weekend = holiday_type == 'weekend'
            is_vietnamese_holiday = holiday_type == 'vietnamese_holiday'
            is_japanese_holiday = holiday_type == 'japanese_holiday'
            is_normal_day = not holiday_type or holiday_type == 'normal'
            
            print(f"   üìÖ Lo·∫°i ng√†y: {holiday_type or 'normal'}")
            print(f"   üî∏ Weekend: {is_weekend}")
            print(f"   üî∏ L·ªÖ Vi·ªát Nam: {is_vietnamese_holiday}")
            print(f"   üî∏ L·ªÖ Nh·∫≠t: {is_japanese_holiday}")
            print(f"   üî∏ Ng√†y th∆∞·ªùng: {is_normal_day}")
            
            # V·ªõi ng√†y cu·ªëi tu·∫ßn: regular_work_hours = 0, overtime ƒë√£ ƒë∆∞·ª£c t√≠nh ƒë√∫ng trong database
            # Ch·ªâ c·∫ßn ƒë·∫£m b·∫£o regular_work_hours = 0:00 khi mapping l√™n Google Sheets
            if is_weekend:
                print(f"   ‚ö†Ô∏è [WEEKEND_LOGIC] Ng√†y cu·ªëi tu·∫ßn - ƒëi·ªÅu ch·ªânh mapping:")
                print(f"      - Regular work hours s·∫Ω = 0:00 (ƒë·∫£m b·∫£o)")
                print(f"      - Overtime gi·ªØ nguy√™n t·ª´ database (ƒë√£ t√≠nh ƒë√∫ng)")
                
                # ƒê·∫£m b·∫£o regular_work_hours = 0:00 cho weekend
                # Database ƒë√£ t√≠nh ƒë√∫ng overtime r·ªìi, kh√¥ng c·∫ßn t√≠nh l·∫°i
                attendance_data['regular_work_hours'] = '0:00'
                
                # Log ƒë·ªÉ ki·ªÉm tra
                print(f"      ‚úÖ ƒê√£ set regular_work_hours = 0:00")
                print(f"      üìä Overtime before 22h: {attendance_data.get('overtime_before_22', '0:00')}")
                print(f"      üìä Overtime after 22h: {attendance_data.get('overtime_after_22', '0:00')}")

            def _is_full_leave_day(raw_value):
                """Ch·ªâ xem l√† ngh·ªâ tr√≤n ng√†y khi gi√° tr·ªã th·ª±c s·ª± bi·ªÉu th·ªã 1.0 ng√†y."""
                if raw_value is None:
                    return False
                if isinstance(raw_value, bool):
                    return raw_value
                if isinstance(raw_value, (int, float)):
                    return abs(float(raw_value) - 1.0) < 1e-9
                if isinstance(raw_value, str):
                    normalized = raw_value.strip().lower()
                    if normalized in {'true', 'full', 'full_day'}:
                        return True
                    if normalized in {'false', '0', '0.0', 'half'}:
                        return False
                    try:
                        return abs(float(normalized) - 1.0) < 1e-9
                    except ValueError:
                        return False
                return False

            def _to_float_leave_value(raw_value):
                """Chuy·ªÉn m·ªçi ki·ªÉu d·ªØ li·ªáu th√†nh float n·∫øu c√≥ th·ªÉ."""
                try:
                    if raw_value is None:
                        return None
                    if isinstance(raw_value, bool):
                        return 1.0 if raw_value else 0.0
                    if isinstance(raw_value, (int, float)):
                        return float(raw_value)
                    if isinstance(raw_value, str):
                        normalized = raw_value.strip().lower()
                        if normalized in {'', 'none'}:
                            return None
                        normalized = normalized.replace(',', '.')
                        return float(normalized)
                except ValueError:
                    return None
                return None

            def _detect_leave_day_value():
                """L·∫•y gi√° tr·ªã s·ªë ng√†y ngh·ªâ t·ª´ attendance_data ho·∫∑c t·ª´ summary."""
                value = _to_float_leave_value(attendance_data.get('leave_fraction_days'))
                if value is not None:
                    return value
            
                summary_text = attendance_data.get('leave_summary')
                if summary_text:
                    try:
                        match = re.search(r'(\d+(?:[.,]\d+)?)\s*ng√†y', summary_text, re.IGNORECASE)
                        if match:
                            return _to_float_leave_value(match.group(1))
                    except Exception:
                        pass
                return None

            leave_day_value = _detect_leave_day_value()

            def _is_half_leave_day():
                return leave_day_value is not None and abs(leave_day_value - 0.5) < 1e-9

            memo_only = bool(attendance_data.get('memo_only'))

            # X√°c ƒë·ªãnh c√≥ ph·∫£i b·∫£n ghi ngh·ªâ ph√©p (t·ª´ ƒë∆°n ngh·ªâ) hay kh√¥ng
            is_leave_record = bool(attendance_data.get('is_leave'))

            # N·∫øu l√† ng√†y ngh·ªâ tr√≤n 1 ng√†y (full_leave_day) ‚Üí x√≥a s·∫°ch c√°c c·ªôt th·ªùi gian G,H,I,J,K,M
            full_leave_day = _is_full_leave_day(attendance_data.get('full_leave_day'))
            if full_leave_day and not memo_only:
                _log("   üî∏ Full leave day: clearing columns G,H,I,J,K,M")
                for col_letter in ['G', 'H', 'I', 'J', 'K', 'M']:
                    a1 = f"{sheet_name}!{col_letter}{target_row_index}"
                    updates.append({'range': a1, 'values': [['']]})
                    update_ranges.append(a1)
            else:
                    # Kh√¥ng ph·∫£i full-day
                    is_half_day = _is_half_leave_day()

                    if memo_only:
                        # Ch·∫ø ƒë·ªô ch·ªâ memo (v√≠ d·ª•: ngh·ªâ 30 ph√∫t) ‚Üí kh√¥ng ƒë·ª•ng v√†o E,G,K,M,N,O
                        print("   üî∏ Ch·∫ø ƒë·ªô memo_only: ch·ªâ c·∫≠p nh·∫≠t c·ªôt P (Memo), b·ªè qua c√°c c·ªôt th·ªùi gian")
                    else:
                        # N·∫øu l√† ngh·ªâ 0.5 ng√†y: x·ª≠ l√Ω ƒë·∫∑c bi·ªát ƒë·ªÉ ph√¢n bi·ªát ngh·ªâ s√°ng/chi·ªÅu
                        if not is_half_day:
                            # Ng√†y l√†m b√¨nh th∆∞·ªùng / c√°c lo·∫°i kh√°c: c·∫≠p nh·∫≠t ƒë·∫ßy ƒë·ªß
                            print(f"   üî∏ C·ªôt G (Gi·ªù v√†o): {attendance_data.get('check_in')}")
                            add_update('check_in', attendance_data.get('check_in'))
                            
                            print(f"   üî∏ C·ªôt K (Gi·ªù ra): {attendance_data.get('check_out')}")
                            add_update('check_out', attendance_data.get('check_out'))
                            
                            print(f"   üî∏ C·ªôt M (Gi·ªù c√¥ng): {attendance_data.get('regular_work_hours')}")
                            # C·ªôt M lu√¥n ƒë∆∞·ª£c c·∫≠p nh·∫≠t, k·ªÉ c·∫£ khi gi√° tr·ªã l√† 0:00
                            regular_work_hours_value = attendance_data.get('regular_work_hours')
                            col_letter = column_mapping.get('regular_work_hours')
                            if col_letter:
                                a1 = f"{sheet_name}!{col_letter}{target_row_index}"
                                updates.append({'range': a1, 'values': [[str(regular_work_hours_value or '0:00')]]})
                                update_ranges.append(a1)
                        else:
                            print(f"   üî∏ Ng√†y ngh·ªâ 0.5: x·ª≠ l√Ω ph√¢n bi·ªát s√°ng/chi·ªÅu theo ca l√†m vi·ªác (Shift Code: {attendance_data.get('shift_code')})")

                            # ==================================================================================
                            # LOGIC X·ª¨ L√ù 0.5 NG√ÄY CHO 4 CA (1, 2, 3, 4)
                            # ==================================================================================
                            
                            # 1. C·∫•u h√¨nh c√°c ca l√†m vi·ªác
                            shift_config = {
                                '1': { 'start': '07:30', 'end': '16:30', 'lunch_start': '11:30', 'lunch_end': '12:30' },
                                '2': { 'start': '09:00', 'end': '18:00', 'lunch_start': '13:00', 'lunch_end': '14:00' },
                                '3': { 'start': '11:00', 'end': '20:00', 'lunch_start': '15:00', 'lunch_end': '16:00' },
                                '4': { 'start': '08:00', 'end': '17:00', 'lunch_start': '12:00', 'lunch_end': '13:00' }
                            }
                            
                            shift_code = str(attendance_data.get('shift_code', '1'))
                            # N·∫øu shift code kh√¥ng h·ª£p l·ªá th√¨ m·∫∑c ƒë·ªãnh l√† 1 (ho·∫∑c gi·ªØ nguy√™n logic c≈© n·∫øu mu·ªën an to√†n h∆°n)
                            if shift_code not in shift_config:
                                print(f"   ‚ö†Ô∏è Shift code '{shift_code}' kh√¥ng h·ª£p l·ªá, m·∫∑c ƒë·ªãnh d√πng Ca 1")
                                shift_code = '1'
                                
                            info = shift_config[shift_code]
                            leave_start_str = attendance_data.get('leave_start_time')
                            
                            # Helper parse time
                            def _time_to_minutes(t_str):
                                try:
                                    if not t_str or ':' not in str(t_str): return None
                                    h, m = map(int, str(t_str).split(':'))
                                    return h * 60 + m
                                except: return None

                            minutes_start = _time_to_minutes(leave_start_str)
                            
                            # C√°c m·ªëc th·ªùi gian c·ªßa ca (ph√∫t)
                            m_start = _time_to_minutes(info['start'])
                            m_end = _time_to_minutes(info['end'])
                            m_lunch_start = _time_to_minutes(info['lunch_start'])
                            m_lunch_end = _time_to_minutes(info['lunch_end'])
                            
                            # Gi√° tr·ªã m·∫∑c ƒë·ªãnh
                            final_g = None   # Check-in
                            final_k = None   # Check-out
                            final_m = '4:00' # Regular Work Hours
                            final_e = '0:00' # Break/Comp Time
                            
                            logic_applied = False
                            
                            # L·∫•y leave_end_time ƒë·ªÉ detect ch√≠nh x√°c h∆°n
                            leave_end_str = attendance_data.get('leave_end_time')
                            minutes_end = _time_to_minutes(leave_end_str)
                            
                            print(f"   üîç [DETECT] minutes_start={minutes_start}, minutes_end={minutes_end}")
                            print(f"   üîç [SHIFT] start={m_start}, lunch_start={m_lunch_start}, lunch_end={m_lunch_end}, end={m_end}")
                            
                            if minutes_start is not None:
                                tolerance = 30 # Cho ph√©p l·ªách 30 ph√∫t
                                
                                # ===============================================================
                                # LOGIC C·∫¢I TI·∫æN: X·ª≠ l√Ω tr∆∞·ªùng h·ª£p nh√¢n vi√™n nh·∫≠p bao g·ªìm gi·ªù tr∆∞a
                                # V√≠ d·ª•: Ca 2 (09:00-18:00), ngh·ªâ s√°ng:
                                # - Nh·∫≠p ƒë√∫ng: 09:00-13:00 
                                # - Nh·∫≠p sai (bao g·ªìm tr∆∞a): 09:00-14:00
                                # C·∫£ 2 ƒë·ªÅu c·∫ßn ƒë∆∞·ª£c detect l√† "Ngh·ªâ S√°ng"
                                # ===============================================================
                                
                                # CASE 1: NGH·ªà S√ÅNG
                                # ƒêi·ªÅu ki·ªán: B·∫Øt ƒë·∫ßu ngh·ªâ ~ Gi·ªù b·∫Øt ƒë·∫ßu Ca
                                # HO·∫∂C: end_time <= lunch_end (ngh·ªâ k·∫øt th√∫c tr∆∞·ªõc ho·∫∑c ƒë√∫ng l√∫c h·∫øt tr∆∞a)
                                is_morning_leave = False
                                if abs(minutes_start - m_start) <= tolerance:
                                    # B·∫Øt ƒë·∫ßu ngh·ªâ ~ gi·ªù b·∫Øt ƒë·∫ßu ca -> Ngh·ªâ S√°ng
                                    is_morning_leave = True
                                elif minutes_end is not None:
                                    # Ki·ªÉm tra n·∫øu kho·∫£ng ngh·ªâ bao ph·ªß bu·ªïi s√°ng
                                    # T·ª©c l√†: start <= shift_start + tolerance V√Ä end <= lunch_end + tolerance
                                    if minutes_start <= m_start + tolerance and minutes_end <= m_lunch_end + tolerance:
                                        is_morning_leave = True
                                
                                if is_morning_leave:
                                    print(f"   ‚úÖ Ph√°t hi·ªán: Ngh·ªâ S√°ng (Ca {shift_code})")
                                    final_g = info['lunch_end']
                                    final_k = info['end']
                                    final_e = '0:00'
                                    logic_applied = True
                                    
                                # CASE 2 & 3: NGH·ªà CHI·ªÄU
                                elif not logic_applied:
                                    update_ranges.append(a1_k)
                                    
                                # C·∫≠p nh·∫≠t E (Overridding logic b√™n d∆∞·ªõi c·ªßa break_comp_cell_value)
                                # Ta set bi·∫øn break_comp_cell_value ·ªü scope ngo√†i ƒë·ªÉ ƒëo·∫°n code ph√≠a d∆∞·ªõi (line 2874+) d√πng l·∫°i
                                # Tuy nhi√™n ƒëo·∫°n d∆∞·ªõi set c·ª©ng '0:00' n·∫øu is_half_day=True.
                                # Ta c·∫ßn s·ª≠a ƒëo·∫°n d∆∞·ªõi ho·∫∑c x·ª≠ l√Ω lu√¥n ·ªü ƒë√¢y v√† flag ƒë·ªÉ ƒëo·∫°n d∆∞·ªõi kh√¥ng ghi ƒë√® sai.
                                # C√°ch t·ªët nh·∫•t: C·∫≠p nh·∫≠t bi·∫øn break_comp_cell_value n·∫øu bi·∫øn ƒë√≥ ch∆∞a ƒë∆∞·ª£c d√πng, 
                                # nh∆∞ng code d∆∞·ªõi d√≤ng 2874 l·∫°i init l·∫°i bi·∫øn ƒë√≥.
                                # => Ta s·∫Ω th√™m item v√†o updates list cho E ·ªü ƒë√¢y, v√† ƒë·∫£m b·∫£o ƒëo·∫°n d∆∞·ªõi kh√¥ng add tr√πng ho·∫∑c ta s·ª≠a ƒëo·∫°n d∆∞·ªõi.
                                
                                # ƒê·ªÉ an to√†n v√† s·∫°ch, ta s·∫Ω g√°n v√†o bi·∫øn attendance_data ho·∫∑c bi·∫øn c·ªù ƒë·ªÉ ƒëo·∫°n d∆∞·ªõi d√πng.
                                # Nh∆∞ng ƒëo·∫°n d∆∞·ªõi logic kh√° ch·∫∑t. 
                                # => Ta add tr·ª±c ti·∫øp v√†o updates list ·ªü ƒë√¢y.
                                # V√Ä QUAN TR·ªåNG: C·∫ßn bypass logic set E='0:00' ·ªü d∆∞·ªõi.
                                
                                # Hack nh·∫π: S·ª≠a logic ·ªü d∆∞·ªõi ƒë·ªÉ ∆∞u ti√™n gi√° tr·ªã ƒë√£ t√≠nh to√°n n√†y.
                                # Nh∆∞ng ta kh√¥ng th·ªÉ s·ª≠a code ·ªü d∆∞·ªõi trong tool call n√†y d·ªÖ d√†ng (multi chunk).
                                # => Ta s·∫Ω add v√†o updates list. Google Sheet API batchUpdate cho ph√©p update c√πng cell nhi·ªÅu l·∫ßn (l·∫ßn sau ƒë√® l·∫ßn tr∆∞·ªõc),
                                # ho·∫∑c ta filter distinct ranges.
                                # Logic d∆∞·ªõi: 
                                # if is_half_day: break_comp_cell_value = '0:00'
                                # => N√≥ s·∫Ω lu√¥n set 0:00.
                                # => CA 3 (C√≥ ƒÉn tr∆∞a) c·∫ßn E=1:00. Logic d∆∞·ªõi s·∫Ω sai.
                                
                                # GI·∫¢I PH√ÅP: 
                                # Ta th·ª±c hi·ªán add update E ·ªü ƒë√¢y.
                                col_letter_e = column_mapping.get('break_comp_total')
                                if col_letter_e:
                                    a1_e = f"{sheet_name}!{col_letter_e}{target_row_index}"
                                    updates.append({'range': a1_e, 'values': [[final_e]]})
                                    update_ranges.append(a1_e)
                                    
                            # C c·∫≠p nh·∫≠t M (Gi·ªù c√¥ng)
                            # Logic g·ªëc force update M t·ª´ regular_work_hours.
                            # V·ªõi ngh·ªâ 0.5, M lu√¥n l√† 4:00. Attendance data t·ª´ DB c√≥ th·ªÉ ƒë√£ t√≠nh sai ho·∫∑c ƒë√∫ng.
                            # Ta force M=4:00 n·∫øu logic applied.
                            if logic_applied:
                                col_letter_m = column_mapping.get('regular_work_hours')
                                if col_letter_m:
                                    a1_m = f"{sheet_name}!{col_letter_m}{target_row_index}"
                                    updates.append({'range': a1_m, 'values': [[final_m]]})
                                    update_ranges.append(a1_m)
                    
                    break_comp_cell_value = total_break_comp_hhmm
                    if is_half_day:
                        # Ki·ªÉm tra xem logic 0.5 ng√†y ·ªü tr√™n ƒë√£ t√≠nh E ch∆∞a
                        if 'final_e' in locals() and final_e is not None:
                            print(f"   üî∏ C·ªôt E (T·ªïng ngh·ªâ + ƒë·ªëi ·ª©ng): ƒê√£ t√≠nh to√°n theo logic 0.5 ng√†y ‚Üí set {final_e}")
                            break_comp_cell_value = final_e
                        else:
                            print("   üî∏ C·ªôt E (T·ªïng ngh·ªâ + ƒë·ªëi ·ª©ng): ph√°t hi·ªán ngh·ªâ 0.5 ng√†y (fallback) ‚Üí set 0:00")
                            break_comp_cell_value = '0:00'
                    else:
                        print(f"   üî∏ C·ªôt E (T·ªïng ngh·ªâ + ƒë·ªëi ·ª©ng): {break_comp_cell_value}")
                    
                    # C·ªôt E ch·ªâ ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi KH√îNG PH·∫¢I memo_only (ngh·ªâ 30 ph√∫t)
                    if not memo_only:
                        # C·ªôt E lu√¥n ƒë∆∞·ª£c c·∫≠p nh·∫≠t, k·ªÉ c·∫£ khi gi√° tr·ªã l√† 0:00
                        col_letter_e = column_mapping.get('break_comp_total')
                        if col_letter_e:
                            a1_e = f"{sheet_name}!{col_letter_e}{target_row_index}"
                            updates.append({'range': a1_e, 'values': [[str(break_comp_cell_value or '0:00')]]})
                            update_ranges.append(a1_e)
                    else:
                        print("   üî∏ C·ªôt E (T·ªïng ngh·ªâ + ƒë·ªëi ·ª©ng): B·ªé QUA c·∫≠p nh·∫≠t (memo_only mode)")

                    
                    
                    # C·∫≠p nh·∫≠t OT (N, O) n·∫øu c√≥ d·ªØ li·ªáu
                    # Cho ph√©p c·∫≠p nh·∫≠t ngay c·∫£ khi ngh·ªâ 0.5 ng√†y (v√¨ n·ª≠a ng√†y c√≤n l·∫°i c√≥ th·ªÉ tƒÉng ca)
                    if attendance_data.get('overtime_before_22'):
                        print(f"   üî∏ C·ªôt N (TƒÉng ca <22h): {attendance_data.get('overtime_before_22')}")
                        add_update('overtime_before_22', attendance_data.get('overtime_before_22'))
                    
                    if attendance_data.get('overtime_after_22'):
                        print(f"   üî∏ C·ªôt O (TƒÉng ca >22h): {attendance_data.get('overtime_after_22')}")
                        add_update('overtime_after_22', attendance_data.get('overtime_after_22'))

            # Ghi ch√∫ s·ªë ng√†y ngh·ªâ (n·∫øu c√≥) - ƒë·ªçc gi√° tr·ªã hi·ªán t·∫°i v√† n·ªëi th√™m n·∫øu c√≥
            leave_summary_value = attendance_data.get('leave_summary')
            if leave_summary_value:
                # ƒê·ªçc gi√° tr·ªã hi·ªán t·∫°i c·ªßa c·ªôt P
                col_p_index = 15  # C·ªôt P l√† index 15 (A=0, B=1, ..., P=15)
                current_p_value = None
                if target_row_index and len(rows) >= target_row_index:
                    row_data = rows[target_row_index - 1]  # target_row_index l√† 1-based
                    if len(row_data) > col_p_index:
                        current_p_value = str(row_data[col_p_index]).strip() if row_data[col_p_index] else ""
                
                # N·ªëi th√™m n·ªôi dung m·ªõi v√†o gi√° tr·ªã hi·ªán t·∫°i (v·ªõi d·∫•u "; " ph√¢n c√°ch)
                if current_p_value:
                    # Ki·ªÉm tra xem n·ªôi dung m·ªõi ƒë√£ c√≥ trong c·ªôt P ch∆∞a (tr√°nh tr√πng l·∫∑p)
                    if leave_summary_value not in current_p_value:
                        final_p_value = f"{current_p_value}; {leave_summary_value}"
                    else:
                        final_p_value = current_p_value  # ƒê√£ c√≥ r·ªìi, kh√¥ng th√™m n·ªØa
                else:
                    final_p_value = leave_summary_value
                
                print(f"   üî∏ C·ªôt P (Ghi ch√∫):")
                print(f"      - Gi√° tr·ªã hi·ªán t·∫°i: {current_p_value or '(tr·ªëng)'}")
                print(f"      - Th√™m m·ªõi: {leave_summary_value}")
                print(f"      - Gi√° tr·ªã cu·ªëi: {final_p_value}")
                add_update('leave_summary', final_p_value)
            else:
                print(f"   üî∏ C·ªôt P (Ghi ch√∫): Kh√¥ng c√≥ n·ªôi dung m·ªõi")
            
            # X·ª≠ l√Ω tr·ª´ gi·ªù ngh·ªâ tr∆∞a n·∫øu c√≥ ngh·ªâ ph√©p v√† kh√¥ng ph·∫£i full leave day (√Åp d·ª•ng cho c·∫£ ngh·ªâ 0.5 ng√†y)
            use_lunch_break = attendance_data.get('use_lunch_break')
            # ƒê√£ b·ªè ƒëi·ªÅu ki·ªán 'not _is_half_leave_day()' ƒë·ªÉ logic n√†y ch·∫°y cho ngh·ªâ n·ª≠a ng√†y
            if leave_summary_value and not full_leave_day and use_lunch_break is not None and not memo_only:
                # Helper functions ƒë·ªÉ chuy·ªÉn ƒë·ªïi HH:MM <-> ph√∫t
                def hhmm_to_minutes(hhmm_str):
                    try:
                        if not hhmm_str or str(hhmm_str).strip() == '':
                            return 0
                        hhmm_str = str(hhmm_str).strip()
                        if hhmm_str == '0:00' or hhmm_str == '0' or hhmm_str == '00:00':
                            return 0
                        if ':' in hhmm_str:
                            parts = hhmm_str.split(':')
                            h = int(parts[0]) if parts[0] else 0
                            m = int(parts[1]) if len(parts) > 1 and parts[1] else 0
                            return h * 60 + m
                        return 0
                    except Exception:
                        return 0
                
                def minutes_to_hhmm(total_minutes):
                    if total_minutes < 0:
                        total_minutes = 0
                    hours = total_minutes // 60
                    minutes = total_minutes % 60
                    return f"{hours}:{minutes:02d}"
                
                # T√≠nh s·ªë gi·ªù c·∫ßn tr·ª´ (cho tr∆∞·ªùng h·ª£p ngh·ªâ chi·ªÅu c∆° b·∫£n)
                lunch_break_hours = 4 if use_lunch_break else 5
                lunch_break_minutes = lunch_break_hours * 60
                
                # C·ªôt K (Gi·ªù ra) l√†m m·ªëc
                col_k_index = 10
                current_k_value = None
                if target_row_index and len(rows) >= target_row_index:
                    row_data = rows[target_row_index - 1]
                    if len(row_data) > col_k_index:
                        current_k_value = row_data[col_k_index]
                
                current_k_minutes = hhmm_to_minutes(current_k_value) if current_k_value else 0
                
                if current_k_minutes > 0:
                    try:
                        # 1. TRUY V·∫§N DB ƒê·ªÇ X√ÅC ƒê·ªäNH S√ÅNG/CHI·ªÄU
                        is_morning_leave_detected = False
                        try:
                            # Parse date_obj t·ª´ date_iso n·∫øu ch∆∞a c√≥
                            target_date = dt.strptime(date_iso, "%Y-%m-%d").date()
                            
                            # L·∫•y user_id t·ª´ attendance_data
                            # attendance_data c√≥ th·ªÉ ch·ª©a 'user_id' ho·∫∑c ch√∫ng ta c·∫ßn query t·ª´ user_name/employee_id
                            # Tuy nhi√™n, h√†m n√†y th∆∞·ªùng ƒë∆∞·ª£c g·ªçi v·ªõi attendance_data ƒë√£ c√≥ ƒë·∫ßy ƒë·ªß info
                            current_user_id = attendance_data.get('user_id')
                            
                            if current_user_id:
                                lr = LeaveRequest.query.filter(
                                    LeaveRequest.user_id == current_user_id,
                                    LeaveRequest.leave_from_year == target_date.year,
                                    LeaveRequest.leave_from_month == target_date.month,
                                    LeaveRequest.leave_from_day == target_date.day,
                                    LeaveRequest.status == 'approved'
                                ).first()
                                
                                print(f"\n   üîç [LOGIC NGH·ªà 0.5 NG√ÄY] Checking LeaveRequest for {current_user_id} on {target_date}:")
                                if lr:
                                    print(f"      - Leave Time: {lr.leave_from_hour}:{lr.leave_from_minute:02d} -> {lr.leave_to_hour}:{lr.leave_to_minute:02d}")
                                    
                                    # LOGIC M·ªöI: D·ª±a theo ca l√†m vi·ªác (Shift) thay v√¨ c·ª©ng nh·∫Øc 13h
                                    # L·∫•y th√¥ng tin shift hi·ªán t·∫°i
                                    shift_code_chk = str(attendance_data.get('shift_code', '1'))
                                    shift_cfg = shift_config.get(shift_code_chk, shift_config['1'])
                                    
                                    # Convert times
                                    lr_start_mins = lr.leave_from_hour * 60 + lr.leave_from_minute
                                    lr_end_mins = lr.leave_to_hour * 60 + lr.leave_to_minute
                                    
                                    s_start_mins = _time_to_minutes(shift_cfg['start'])
                                    s_lunch_end_mins = _time_to_minutes(shift_cfg['lunch_end'])
                                    
                                    # Logic nh·∫≠n di·ªán gi·ªëng test_leave_logic.py
                                    # 1. B·∫Øt ƒë·∫ßu ngh·ªâ ~ Gi·ªù b·∫Øt ƒë·∫ßu ca
                                    # HO·∫∂C 2. K·∫øt th√∫c ngh·ªâ <= Gi·ªù k·∫øt th√∫c tr∆∞a
                                    tol = 30
                                    if abs(lr_start_mins - s_start_mins) <= tol:
                                        is_morning_leave_detected = True
                                        print(f"      => K·∫æT LU·∫¨N: NGH·ªà BU·ªîI S√ÅNG (Starts at shift start)")
                                    elif lr_end_mins <= s_lunch_end_mins + tol:
                                        is_morning_leave_detected = True
                                        print(f"      => K·∫æT LU·∫¨N: NGH·ªà BU·ªîI S√ÅNG (Ends by lunch end)")
                                    else:
                                        print(f"      => K·∫æT LU·∫¨N: NGH·ªà BU·ªîI CHI·ªÄU")
                                else:
                                    print(f"      ‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y LeaveRequest trong DB. M·∫∑c ƒë·ªãnh d√πng logic based on lunch break choice.")
                            else:
                                print(f"      ‚ö†Ô∏è Kh√¥ng c√≥ user_id trong attendance_data. B·ªè qua tra c·ª©u DB.")
                                
                        except Exception as lr_err:
                            print(f"   ‚ö†Ô∏è L·ªói truy v·∫•n DB ki·ªÉm tra lo·∫°i ngh·ªâ: {lr_err}")

                        print(f"   üìä [GOOGLE SHEET UPDATE PLAN]")
                        
                        # 2. X·ª¨ L√ù C·∫¨P NH·∫¨T SHEET
                        if is_morning_leave_detected:
                            # === NGH·ªà S√ÅNG ===
                            # C·ªôt G (Gi·ªù v√†o) thay ƒë·ªïi: V√†o l√†m luÃÅc (Gi·ªù ra - 4h laÃÄm chi√™ÃÄu)
                            # C·ªôt E (Gi·ªù ngh·ªâ): 0:00 (L√†m th·∫≥ng)
                            
                            new_e_value = '0:00'
                            
                            # T√≠nh gi·ªù v√†o (G)
                            new_g_minutes = current_k_minutes - 240 # Tr·ª´ 4 ti·∫øng l√†m vi·ªác chi·ªÅu
                            if new_g_minutes < 0: new_g_minutes = 0
                            new_g_value = minutes_to_hhmm(new_g_minutes)
                            
                            print(f"      üîπ TR∆Ø·ªúNG H·ª¢P: NGH·ªà S√ÅNG (ƒêi l√†m ca chi·ªÅu)")
                            print(f"      - Gi·ªù ra (C·ªôt K): {current_k_value} (Gi·ªØ nguy√™n)")
                            print(f"      - Gi·ªù v√†o (C·ªôt G): S·∫Ω c·∫≠p nh·∫≠t th√†nh {new_g_value} (Logic: Ra - 4h l√†m)")
                            print(f"      - Gi·ªù ngh·ªâ (C·ªôt E): S·∫Ω c·∫≠p nh·∫≠t th√†nh {new_e_value}")
                            
                            # Update G
                            a1_g = f"{sheet_name}!G{target_row_index}"
                            updates.append({'range': a1_g, 'values': [[new_g_value]]})
                            update_ranges.append(a1_g)
                            
                        else:
                            # === NGH·ªà CHI·ªÄU === (Ho·∫∑c m·∫∑c ƒë·ªãnh)
                            # C·ªôt K (Gi·ªù ra) thay ƒë·ªïi
                            # C·ªôt E (Gi·ªù ngh·ªâ) thay ƒë·ªïi theo l·ª±a ch·ªçn
                            
                            # T√≠nh gi·ªù ra (K) theo logic c≈©
                            # use_lunch_break = True (C√≥ ƒÉn tr∆∞a) -> Tr·ª´ 4h (v·ªÅ mu·ªôn h∆°n 1 x√≠u ƒë·ªÉ ƒÉn)
                            # use_lunch_break = False (Ko ƒÉn tr∆∞a) -> Tr·ª´ 5h (v·ªÅ s·ªõm lu√¥n)
                            
                            new_k_minutes = current_k_minutes - lunch_break_minutes
                            if new_k_minutes < 0: new_k_minutes = 0
                            new_k_value = minutes_to_hhmm(new_k_minutes)
                            
                            new_e_value = '1:00' if use_lunch_break else '0:00'
                            
                            print(f"      üîπ TR∆Ø·ªúNG H·ª¢P: NGH·ªà CHI·ªÄU (ƒêi l√†m ca s√°ng)")
                            print(f"      - User ch·ªçn ƒÉn tr∆∞a: {'C√ì' if use_lunch_break else 'KH√îNG'}")
                            print(f"      - Gi·ªù v√†o (C·ªôt G): (Gi·ªØ nguy√™n)")
                            print(f"      - Gi·ªù ra (C·ªôt K): {current_k_value} -> {new_k_value} (Tr·ª´ {lunch_break_hours}h)")
                            print(f"      - Gi·ªù ngh·ªâ (C·ªôt E): S·∫Ω c·∫≠p nh·∫≠t th√†nh {new_e_value}")
                            
                            # Update K
                            a1_k = f"{sheet_name}!K{target_row_index}"
                            updates.append({'range': a1_k, 'values': [[new_k_value]]})
                            update_ranges.append(a1_k)

                        # Update E (Chung cho c·∫£ 2 tr∆∞·ªùng h·ª£p)
                        final_e = new_e_value
                        col_letter_e = column_mapping.get('break_comp_total')
                        if col_letter_e:
                            a1_e = f"{sheet_name}!{col_letter_e}{target_row_index}"
                            updates.append({'range': a1_e, 'values': [[new_e_value]]})
                            update_ranges.append(a1_e)
                            
                        print(f"   ‚úÖ ƒê√£ th√™m c√°c c·∫≠p nh·∫≠t v√†o h√†ng ƒë·ª£i batch update.\n")

                    except Exception as k_err:
                        print(f"   ‚ö†Ô∏è L·ªói logic t√≠nh to√°n c·∫≠p nh·∫≠t Sheet: {k_err}")
                else:
                    print(f"   ‚ö†Ô∏è C·ªôt K (Gi·ªù ra) kh√¥ng c√≥ d·ªØ li·ªáu, kh√¥ng th·ªÉ t√≠nh to√°n ƒëi·ªÅu ch·ªânh gi·ªù.")

            # X·ª≠ l√Ω ƒë∆°n ƒëi tr·ªÖ/v·ªÅ s·ªõm: tr·ª´ gi·ªù t·ª´ c·ªôt G (ƒëi tr·ªÖ) ho·∫∑c c·ªôt K (v·ªÅ s·ªõm)
            late_early_type = attendance_data.get('late_early_type')
            late_early_minutes = attendance_data.get('late_early_minutes', 0)
            if late_early_type and late_early_minutes > 0:
                # Helper functions ƒë·ªÉ chuy·ªÉn ƒë·ªïi HH:MM <-> ph√∫t (n·∫øu ch∆∞a ƒë·ªãnh nghƒ©a)
                def hhmm_to_minutes_le(hhmm_str):
                    try:
                        if not hhmm_str or str(hhmm_str).strip() == '':
                            return 0
                        hhmm_str = str(hhmm_str).strip()
                        if hhmm_str == '0:00' or hhmm_str == '0' or hhmm_str == '00:00':
                            return 0
                        if ':' in hhmm_str:
                            parts = hhmm_str.split(':')
                            h = int(parts[0]) if parts[0] else 0
                            m = int(parts[1]) if len(parts) > 1 and parts[1] else 0
                            return h * 60 + m
                        return 0
                    except Exception:
                        return 0
                
                def minutes_to_hhmm_le(total_minutes):
                    if total_minutes < 0:
                        total_minutes = 0
                    hours = total_minutes // 60
                    minutes = total_minutes % 60
                    return f"{hours}:{minutes:02d}"

                print(f"\n   üî∏ X·ª≠ l√Ω ƒë∆°n ƒëi tr·ªÖ/v·ªÅ s·ªõm:")
                print(f"      - Lo·∫°i: {late_early_type}")
                print(f"      - S·ªë ph√∫t: {late_early_minutes}")

                if late_early_type == 'late':
                    # ƒêi tr·ªÖ: C·ªòNG gi·ªù v√†o c·ªôt G (ƒëi tr·ªÖ) - v√¨ ƒë·∫øn mu·ªôn h∆°n
                    col_g_index = 6  # C·ªôt G l√† index 6 (A=0, B=1, ..., G=6)
                    current_g_value = None
                    if target_row_index and len(rows) >= target_row_index:
                        row_data = rows[target_row_index - 1]  # target_row_index l√† 1-based
                        if len(row_data) > col_g_index:
                            current_g_value = row_data[col_g_index]
                    
                    current_g_minutes = hhmm_to_minutes_le(current_g_value) if current_g_value else 0
                    
                    if current_g_minutes > 0:
                        try:
                            new_g_minutes = current_g_minutes + late_early_minutes  # C·ªòNG th√™m
                            
                            new_g_value = minutes_to_hhmm_le(new_g_minutes)
                            
                            print(f"      - C·ªôt G (Gi·ªù v√†o) hi·ªán t·∫°i: {current_g_value or '0:00'} ({current_g_minutes} ph√∫t)")
                            print(f"      - C·ªông: {late_early_minutes} ph√∫t (ƒëi tr·ªÖ)")
                            print(f"      - C·ªôt G m·ªõi: {new_g_value} ({new_g_minutes} ph√∫t)")
                            
                            # C·∫≠p nh·∫≠t l·∫°i c·ªôt G
                            a1_g = f"{sheet_name}!G{target_row_index}"
                            updates.append({'range': a1_g, 'values': [[new_g_value]]})
                            update_ranges.append(a1_g)
                        except Exception as g_err:
                            print(f"      ‚ö†Ô∏è L·ªói khi x·ª≠ l√Ω c·ªôt G: {g_err}")
                    else:
                        print(f"      ‚ö†Ô∏è C·ªôt G kh√¥ng c√≥ gi√° tr·ªã ho·∫∑c b·∫±ng 0, b·ªè qua x·ª≠ l√Ω ƒëi tr·ªÖ")

                elif late_early_type == 'early':
                    # V·ªÅ s·ªõm: tr·ª´ gi·ªù t·ª´ c·ªôt K (Gi·ªù ra)
                    col_k_index = 10  # C·ªôt K l√† index 10 (A=0, B=1, ..., K=10)
                    current_k_value = None
                    if target_row_index and len(rows) >= target_row_index:
                        row_data = rows[target_row_index - 1]  # target_row_index l√† 1-based
                        if len(row_data) > col_k_index:
                            current_k_value = row_data[col_k_index]
                    
                    current_k_minutes = hhmm_to_minutes_le(current_k_value) if current_k_value else 0
                    
                    if current_k_minutes > 0:
                        try:
                            new_k_minutes = current_k_minutes - late_early_minutes
                            
                            if new_k_minutes < 0:
                                new_k_minutes = 0
                            
                            new_k_value = minutes_to_hhmm_le(new_k_minutes)
                            
                            print(f"      - C·ªôt K (Gi·ªù ra) hi·ªán t·∫°i: {current_k_value or '0:00'} ({current_k_minutes} ph√∫t)")
                            print(f"      - Tr·ª´: {late_early_minutes} ph√∫t")
                            print(f"      - C·ªôt K m·ªõi: {new_k_value} ({new_k_minutes} ph√∫t)")
                            
                            # C·∫≠p nh·∫≠t l·∫°i c·ªôt K
                            a1_k = f"{sheet_name}!K{target_row_index}"
                            updates.append({'range': a1_k, 'values': [[new_k_value]]})
                            update_ranges.append(a1_k)
                        except Exception as k_err:
                            print(f"      ‚ö†Ô∏è L·ªói khi x·ª≠ l√Ω c·ªôt K: {k_err}")
                    else:
                        print(f"      ‚ö†Ô∏è C·ªôt K kh√¥ng c√≥ gi√° tr·ªã ho·∫∑c b·∫±ng 0, b·ªè qua x·ª≠ l√Ω v·ªÅ s·ªõm")

            _log(f"\nüìä T·ªîNG K·∫æT C·∫¨P NH·∫¨T:")
            _log(f"   üìù S·ªë √¥ s·∫Ω c·∫≠p nh·∫≠t: {len(updates)}")
            for i, update in enumerate(updates, 1):
                _log(f"   {i}. {update['range']} = {update['values'][0][0]}")
            
            if updates:
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                _log(f"\nüöÄ [BATCH_UPDATE_START] {timestamp} - B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t batch v·ªõi formatting ({len(updates)} √¥)...")
                
                # S·ª≠ d·ª•ng h√†m m·ªõi k·∫øt h·ª£p c·∫≠p nh·∫≠t values v√† formatting trong m·ªôt l·∫ßn g·ªçi
                ok = self.batch_update_values_with_formatting(spreadsheet_id, sheet_name, updates)
                
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                if ok:
                    _log(f"\n{'='*80}")
                    _log(f"‚úÖ [BATCH_UPDATE_SUCCESS] {timestamp} - C·∫≠p nh·∫≠t batch v·ªõi formatting th√†nh c√¥ng!")
                    _log(f"   S·ªë √¥ ƒë√£ c·∫≠p nh·∫≠t: {len(updates)}")
                    _log(f"   Font: Google Sans, C·ª° ch·ªØ: 9, CƒÉn gi·ªØa: CENTER")
                    _log(f"{'='*80}\n")
                    
                    # Backup ngay sau khi c·∫≠p nh·∫≠t th√†nh c√¥ng
                    try:
                        create_backup()
                        _log("üõ°Ô∏è ƒê√£ t·∫°o backup sau c·∫≠p nh·∫≠t timesheet")
                    except Exception as e:
                        _log(f"‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫°o backup sau c·∫≠p nh·∫≠t: {e}")
                    timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                    _log(f"‚úÖ [UPDATE_COMPLETE] {timestamp} - Ho√†n th√†nh c·∫≠p nh·∫≠t timesheet")
                    return True
                else:
                    timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                    _log(f"\n{'='*80}")
                    _log(f"‚ùå [BATCH_UPDATE_FAILED] {timestamp} - C·∫¨P NH·∫¨T BATCH TH·∫§T B·∫†I!")
                    _log(f"   Spreadsheet ID: {spreadsheet_id}")
                    _log(f"   Sheet Name: {sheet_name}")
                    _log(f"   S·ªë √¥ c·∫ßn c·∫≠p nh·∫≠t: {len(updates)}")
                    _log(f"   Row Index: {target_row_index}")
                    _log(f"{'='*80}\n")
                    return False

            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            print(f"\n{'='*80}")
            print(f"‚ö†Ô∏è [NO_UPDATES] {timestamp} - KH√îNG C√ì D·ªÆ LI·ªÜU ƒê·ªÇ C·∫¨P NH·∫¨T")
            print(f"   Spreadsheet ID: {spreadsheet_id}")
            print(f"   Sheet Name: {sheet_name}")
            print(f"   Row Index: {target_row_index}")
            print(f"   Attendance Data Keys: {list(attendance_data.keys())}")
            print(f"   ‚ö†Ô∏è Fallback v·ªÅ c·∫≠p nh·∫≠t 1 √¥ (M35)")
            print(f"{'='*80}\n")
            try:
                sys.stdout.flush()
            except Exception:
                pass
            result = self.update_sheet_value(
                spreadsheet_id, sheet_name, 35, 'M',
                f"Ph√™ duy·ªát b·ªüi {attendance_data.get('approved_by','')} - {attendance_data.get('approved_at','')}"
            )
            print(f"üìä [FALLBACK_UPDATE] K·∫øt qu·∫£ fallback: {result}")
            try:
                sys.stdout.flush()
            except Exception:
                pass
            return result
        except Exception as e:
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            print(f"\n{'='*80}")
            print(f"‚ùå [UPDATE_EXCEPTION] {timestamp} - L·ªói trong update_timesheet_for_attendance")
            print(f"   Error: {str(e)}")
            print(f"   Type: {type(e).__name__}")
            import traceback
            print(f"   Traceback:")
            print(traceback.format_exc())
            print(f"{'='*80}\n")
            try:
                sys.stdout.flush()
            except Exception:
                pass
            return False
    
    def _find_month_folder(self, folder_id, month_year):
        """T√¨m folder th√°ng trong folder nƒÉm"""
        try:
            # T√¨m folder nƒÉm (2025)
            year = month_year[:4]  # 2025
            month = month_year[4:]  # 10
            
            # T√¨m folder nƒÉm
            year_query = f"'{folder_id}' in parents and trashed=false and name='{year}' and mimeType='application/vnd.google-apps.folder'"
            year_results = self.drive_service.files().list(
                q=year_query,
                pageSize=10,
                fields="files(id, name, mimeType)"
            ).execute()
            
            year_folders = year_results.get('files', [])
            if not year_folders:
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y folder nƒÉm {year}")
                return None
            
            year_folder = year_folders[0]
            print(f"‚úÖ T√¨m th·∫•y folder nƒÉm: {year_folder['name']}")
            
            # T√¨m folder th√°ng trong folder nƒÉm
            month_query = f"'{year_folder['id']}' in parents and trashed=false and name='{month}' and mimeType='application/vnd.google-apps.folder'"
            month_results = self.drive_service.files().list(
                q=month_query,
                pageSize=10,
                fields="files(id, name, mimeType)"
            ).execute()
            
            month_folders = month_results.get('files', [])
            if not month_folders:
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y folder th√°ng {month}")
                return None
            
            return month_folders[0]
            
        except Exception as e:
            print(f"‚ùå L·ªói khi t√¨m folder th√°ng: {e}")
            return None
    
    def _search_timesheet_in_folder(self, folder_id, target_name, file_name):
        """T√¨m file timesheet trong folder c·ª• th·ªÉ - h·ªó tr·ª£ c·∫£ c√≥ v√† kh√¥ng c√≥ ti·ªÅn t·ªë DMI-"""
        try:
            # T·∫°o danh s√°ch c√°c bi·∫øn th·ªÉ t√™n file ƒë·ªÉ t√¨m ki·∫øm
            search_variants = []
            
            # B∆∞·ªõc 1: T√¨m file ch√≠nh x√°c v·ªõi th√°ng (c√≥ v√† kh√¥ng c√≥ DMI-)
            search_variants.append(target_name)  # T√™n g·ªëc
            if not target_name.startswith('DMI-'):
                search_variants.append(f"DMI-{target_name}")  # Th√™m DMI- n·∫øu ch∆∞a c√≥
            else:
                # N·∫øu ƒë√£ c√≥ DMI-, th·ª≠ t√¨m kh√¥ng c√≥ DMI-
                search_variants.append(target_name.replace('DMI-', '', 1))
            
            # B∆∞·ªõc 2: T√¨m file g·ªëc (kh√¥ng c√≥ th√°ng) - c√≥ v√† kh√¥ng c√≥ DMI-
            search_variants.append(file_name)  # T√™n g·ªëc
            if not file_name.startswith('DMI-'):
                search_variants.append(f"DMI-{file_name}")  # Th√™m DMI- n·∫øu ch∆∞a c√≥
            else:
                # N·∫øu ƒë√£ c√≥ DMI-, th·ª≠ t√¨m kh√¥ng c√≥ DMI-
                search_variants.append(file_name.replace('DMI-', '', 1))
            
            # Lo·∫°i b·ªè tr√πng l·∫∑p
            search_variants = list(dict.fromkeys(search_variants))
            
            # T√¨m ki·∫øm v·ªõi t·ª´ng bi·∫øn th·ªÉ
            for variant in search_variants:
                query = f"'{folder_id}' in parents and trashed=false and name contains '{variant}'"
                results = self.drive_service.files().list(
                    q=query,
                    pageSize=100,
                    fields="files(id, name, mimeType, size, modifiedTime, webViewLink, capabilities)"
                ).execute()
                
                files = results.get('files', [])
                if files:
                    print(f"‚úÖ T√¨m th·∫•y file v·ªõi t√™n: {variant}")
                    return files
            
            # B∆∞·ªõc 3: T√¨m ki·∫øm linh ho·∫°t v·ªõi t·ª´ kh√≥a ch√≠nh (lo·∫°i b·ªè DMI- ƒë·ªÉ t√¨m ki·∫øm)
            print(f"üîÑ Th·ª≠ t√¨m ki·∫øm linh ho·∫°t v·ªõi t·ª´ kh√≥a...")
            # Lo·∫°i b·ªè DMI- ƒë·ªÉ t√¨m ki·∫øm
            base_file_name = file_name.replace('DMI-', '').strip()
            keywords = self._extract_keywords(base_file_name)
            
            for keyword in keywords:
                print(f"   T√¨m ki·∫øm v·ªõi t·ª´ kh√≥a: {keyword}")
                keyword_query = f"'{folder_id}' in parents and trashed=false and name contains '{keyword}'"
                keyword_results = self.drive_service.files().list(
                    q=keyword_query,
                    pageSize=100,
                    fields="files(id, name, mimeType, size, modifiedTime, webViewLink, capabilities)"
                ).execute()
                
                keyword_files = keyword_results.get('files', [])
                if keyword_files:
                    # L·ªçc c√°c file ph√π h·ª£p nh·∫•t (c√≥ ch·ª©a t·ª´ kh√≥a v√† c√≥ "timesheet" ho·∫∑c "sheet")
                    filtered_files = [
                        f for f in keyword_files 
                        if 'timesheet' in f['name'].lower() or 'sheet' in f['name'].lower()
                    ]
                    if filtered_files:
                        print(f"‚úÖ T√¨m th·∫•y file v·ªõi t·ª´ kh√≥a: {keyword}")
                        return filtered_files
                    else:
                        print(f"‚úÖ T√¨m th·∫•y file v·ªõi t·ª´ kh√≥a: {keyword} (kh√¥ng c√≥ timesheet trong t√™n)")
                        return keyword_files
            
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y file n√†o v·ªõi t·∫•t c·∫£ t·ª´ kh√≥a")
            return []
            
        except Exception as e:
            print(f"‚ùå L·ªói khi t√¨m ki·∫øm trong folder: {e}")
            return []
    
    def find_team_timesheet(self, folder_id, team_name, month_year="202510"):
        """T√¨m file timesheet c·ªßa team c·ª• th·ªÉ"""
        try:
            # ƒê·∫£m b·∫£o token lu√¥n h·ª£p l·ªá tr∆∞·ªõc khi s·ª≠ d·ª•ng API
            if not self.ensure_valid_token():
                print("‚ùå Kh√¥ng th·ªÉ ƒë·∫£m b·∫£o token h·ª£p l·ªá")
                return None
            
            # L·∫•y t√™n file t·ª´ mapping
            file_name = self.get_department_file_mapping(team_name)
            # Lo·∫°i b·ªè DMI- n·∫øu c√≥ ƒë·ªÉ t·∫°o target_name (s·∫Ω t√¨m c·∫£ hai bi·∫øn th·ªÉ)
            base_file_name = file_name.replace('DMI-', '').strip() if file_name.startswith('DMI-') else file_name
            target_name = f"{base_file_name}-{month_year}"
            
            # CHECKS CACHE FIRST
            cache_key = f"{team_name}_{month_year}"
            if hasattr(self, '_file_cache') and cache_key in self._file_cache:
                cached_file = self._file_cache[cache_key]
                print(f"üöÄ [CACHE_HIT] T√¨m th·∫•y file trong cache: {cached_file.get('name')} (ID: {cached_file.get('id')})")
                return cached_file
            
            print(f"\nüîç ƒêang t√¨m file timesheet c·ªßa team: {team_name}")
            print(f"üìÅ Mapping t·ª´ database: {file_name}")
            print(f"üìÅ T√™n file t√¨m ki·∫øm: {target_name} (s·∫Ω th·ª≠ c·∫£ DMI-{target_name} n·∫øu c·∫ßn)")
            print(f"{'='*60}")
            
            # B∆∞·ªõc 1: T√¨m trong folder con 2025/10/ tr∆∞·ªõc
            print(f"üîç T√¨m ki·∫øm trong folder con 2025/10/...")
            target_folder = self._find_month_folder(folder_id, month_year)
            
            if target_folder:
                print(f"‚úÖ T√¨m th·∫•y folder th√°ng: {target_folder['name']}")
                files = self._search_timesheet_in_folder(target_folder['id'], target_name, file_name)
                if files:
                    # Update Cache
                    if hasattr(self, '_file_cache'):
                        self._file_cache[cache_key] = files[0]
                    return files[0]  # Tr·∫£ v·ªÅ file ƒë·∫ßu ti√™n t√¨m th·∫•y
            else:
                print(f"‚ùå Kh√¥ng t√¨m th·∫•y folder th√°ng {month_year}")
            
            # B∆∞·ªõc 2: Fallback - t√¨m trong folder g·ªëc
            print(f"üîÑ Fallback: T√¨m trong folder g·ªëc...")
            files = self._search_timesheet_in_folder(folder_id, target_name, file_name)
            
            if files:
                # Update Cache
                if hasattr(self, '_file_cache'):
                    self._file_cache[cache_key] = files[0]
                return files[0]  # Tr·∫£ v·ªÅ file ƒë·∫ßu ti√™n t√¨m th·∫•y
            
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y file timesheet cho team {team_name}")
            return None
            
        except Exception as e:
            print(f"‚ùå L·ªói khi t√¨m file timesheet: {e}")
            return None
    
    def list_all_timesheets(self, folder_id):
        """L·∫•y danh s√°ch t·∫•t c·∫£ file timesheet trong folder"""
        try:
            if not self.ensure_valid_token():
                print("‚ùå Kh√¥ng th·ªÉ ƒë·∫£m b·∫£o token h·ª£p l·ªá")
                return []
            
            query = f"'{folder_id}' in parents and trashed=false and (mimeType='application/vnd.google-apps.spreadsheet' or mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')"
            results = self.drive_service.files().list(
                q=query,
                pageSize=100,
                fields="files(id, name, mimeType, size, modifiedTime, webViewLink)"
            ).execute()
            
            files = results.get('files', [])
            return files
            
        except Exception as e:
            print(f"‚ùå L·ªói khi l·∫•y danh s√°ch timesheet: {e}")
            return []
    
    def _get_file_type(self, mime_type):
        """Chuy·ªÉn ƒë·ªïi mime type sang t√™n d·ªÖ hi·ªÉu"""
        types = {
            'application/vnd.google-apps.spreadsheet': 'Google Sheets',
            'application/vnd.google-apps.document': 'Google Docs',
            'application/vnd.google-apps.folder': 'Folder',
            'application/pdf': 'PDF',
            'text/csv': 'CSV',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'Excel'
        }
        return types.get(mime_type, mime_type)
    
    def get_department_file_mapping(self, department):
        """Mapping ph√≤ng ban v·ªõi t√™n file timesheet - ∆∞u ti√™n ƒë·ªçc t·ª´ database"""
        # Th·ª≠ ƒë·ªçc t·ª´ database tr∆∞·ªõc
        try:
            from database.models import Department
            dept = Department.query.filter_by(name=department, is_active=True).first()
            if dept and dept.timesheet_file:
                return dept.timesheet_file
        except Exception:
            pass
        
        # Fallback v·ªÅ hardcoded mapping cho backward compatibility
        mapping = {
            'BUD A': 'Bud_TimeSheet',
            'BUD B': 'Bud_TimeSheet',
            'BUD C': 'Bud_TimeSheet',
            'CREEK&RIVER': 'Creek&River_timesheet',
            'KIRI': 'KIRI TIME SHEET',
            'OFFICE': 'BACKOFFICE_TIMESHEET',
            'YORK': 'Chirashi_TimeSheet',
            'COMO': 'Chirashi_TimeSheet',
            'IT': 'IT_TimeSheet',
            'SCOPE': 'SCOPE_TimeSheet'
        }
        return mapping.get(department, f"{department}_TimeSheet")

    def get_all_department_mappings(self):
        """L·∫•y t·∫•t c·∫£ mapping ph√≤ng ban - k·∫øt h·ª£p database v√† hardcoded"""
        # B·∫Øt ƒë·∫ßu v·ªõi hardcoded mapping
        result = {
            'BUD A': 'Bud_TimeSheet',
            'BUD B': 'Bud_TimeSheet',
            'BUD C': 'Bud_TimeSheet',
            'CREEK&RIVER': 'Creek&River_timesheet',
            'KIRI': 'KIRI TIME SHEET',
            'OFFICE': 'BACKOFFICE_TIMESHEET',
            'YORK': 'Chirashi_TimeSheet',
            'COMO': 'Chirashi_TimeSheet',
            'IT': 'IT_TimeSheet',
            'SCOPE': 'SCOPE_TimeSheet'
        }
        
        # Th√™m/override t·ª´ database
        try:
            from database.models import Department
            db_depts = Department.query.filter_by(is_active=True).all()
            for dept in db_depts:
                if dept.timesheet_file:
                    result[dept.name] = dept.timesheet_file
        except Exception:
            pass
        
        return result
    
    def _extract_keywords(self, file_name):
        """Tr√≠ch xu·∫•t t·ª´ kh√≥a ch√≠nh t·ª´ t√™n file ƒë·ªÉ t√¨m ki·∫øm linh ho·∫°t - lo·∫°i b·ªè DMI-"""
        keywords = []
        
        # Lo·∫°i b·ªè ti·ªÅn t·ªë DMI- n·∫øu c√≥
        clean_file_name = file_name.replace('DMI-', '').strip() if file_name.startswith('DMI-') else file_name
        
        # Chu·∫©n h√≥a t√™n file tr∆∞·ªõc khi x·ª≠ l√Ω
        normalized_name = self._normalize_text(clean_file_name)
        
        # Chia th√†nh t·ª´
        words = normalized_name.split()
        
        # Th√™m t·ª´ kh√≥a theo ƒë·ªô ∆∞u ti√™n
        for word in words:
            if len(word) > 2:  # Ch·ªâ l·∫•y t·ª´ c√≥ ƒë·ªô d√†i > 2
                keywords.append(word)
        
        # Th√™m t·ª´ kh√≥a ƒë·∫∑c bi·ªát cho c√°c tr∆∞·ªùng h·ª£p c·ª• th·ªÉ (so s√°nh v·ªõi text ƒë√£ chu·∫©n h√≥a)
        if 'bud' in normalized_name:
            keywords.extend(['bud', 'timesheet'])
        elif 'creek' in normalized_name or 'river' in normalized_name:
            keywords.extend(['creek', 'river', 'timesheet'])
        elif 'kiri' in normalized_name or 'kirinuki' in normalized_name:
            keywords.extend(['kiri', 'kirinuki', 'time', 'sheet'])
        elif 'backoffice' in normalized_name or 'back' in normalized_name:
            keywords.extend(['backoffice', 'back', 'timesheet'])
        elif 'chirashi' in normalized_name:
            keywords.extend(['chirashi', 'timesheet'])
        elif 'scope' in normalized_name:
            keywords.extend(['scope', 'timesheet'])
        elif 'it' in normalized_name:
            keywords.extend(['it', 'timesheet'])
        
        # Lo·∫°i b·ªè tr√πng l·∫∑p v√† s·∫Øp x·∫øp theo ƒë·ªô ∆∞u ti√™n
        unique_keywords = list(dict.fromkeys(keywords))
        return unique_keywords
    
    def _normalize_text(self, text):
        """Chu·∫©n h√≥a text ƒë·ªÉ so s√°nh d·ªÖ d√†ng"""
        if not text:
            return ""
        
        # Chuy·ªÉn v·ªÅ ch·ªØ th∆∞·ªùng v√† lo·∫°i b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát
        import re
        normalized = re.sub(r'[&_\-\.]', ' ', text.lower())
        # Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a
        normalized = ' '.join(normalized.split())
        return normalized

# ====== BACKUP SCHEDULER ======
import threading
import shutil
import requests
import time

_backup_scheduler_lock = threading.Lock()
_backup_scheduler_started = False

# ====== SIMPLE CHATBOT (OLLAMA / DEEPSEEK) ======
# Cho ph√©p ch·ªçn provider b·∫±ng bi·∫øn m√¥i tr∆∞·ªùng:
# - CHATBOT_PROVIDER=ollama (d√πng Ollama local)
# - CHATBOT_PROVIDER=deepseek (d√πng API DeepSeek ki·ªÉu OpenAI)
# ∆Øu ti√™n cloud DeepSeek khi ƒë√£ c·∫•u h√¨nh API key, ƒë·ªÉ ·ªïn ƒë·ªãnh h∆°n;
# n·∫øu kh√¥ng c√≥ key th√¨ fallback v·ªÅ c·∫•u h√¨nh env (m·∫∑c ƒë·ªãnh ollama).
DEEPSEEK_API_KEY = os.environ.get('DEEPSEEK_API_KEY')  # Ph·∫£i set trong .env, kh√¥ng d√πng default
CHATBOT_PROVIDER = os.environ.get('CHATBOT_PROVIDER', 'ollama').lower()
if DEEPSEEK_API_KEY:
    CHATBOT_PROVIDER = 'deepseek'

# C·∫•u h√¨nh Ollama (ch·∫°y local, m·∫∑c ƒë·ªãnh port 11434)
OLLAMA_API_URL = os.environ.get('OLLAMA_API_URL', 'http://localhost:11434/api/chat')
# M·∫∑c ƒë·ªãnh d√πng model nh·∫π h∆°n ƒë·ªÉ ph·∫£n h·ªìi nhanh h∆°n; c√≥ th·ªÉ override qua bi·∫øn m√¥i tr∆∞·ªùng
OLLAMA_MODEL = os.environ.get('OLLAMA_MODEL', 'qwen2.5:7b')

# C·∫•u h√¨nh DeepSeek qua OpenRouter (OpenAI-compatible)
# C√≥ th·ªÉ override b·∫±ng bi·∫øn m√¥i tr∆∞·ªùng n·∫øu mu·ªën endpoint/model kh√°c.
DEEPSEEK_API_URL = os.environ.get('DEEPSEEK_API_URL', 'https://openrouter.ai/api/v1/chat/completions')
# Model m·∫∑c ƒë·ªãnh tr√™n OpenRouter (c√≥ th·ªÉ thay b·∫±ng model kh√°c n·∫øu b·∫°n c√≥ quota/plan ph√π h·ª£p)
DEEPSEEK_MODEL = os.environ.get('DEEPSEEK_MODEL', 'tngtech/deepseek-r1t-chimera:free')
# Header t√πy ch·ªçn cho OpenRouter (x·∫øp h·∫°ng ngu·ªìn)
OPENROUTER_SITE = os.environ.get('OPENROUTER_SITE_URL', '')
OPENROUTER_TITLE = os.environ.get('OPENROUTER_SITE_NAME', '')

# T·∫Øt telemetry c·ªßa ChromaDB ƒë·ªÉ tr√°nh l·ªói "capture() takes 1 positional argument but 3 were given"
# Ph·∫£i ƒë·∫∑t TR∆Ø·ªöC khi import chromadb
os.environ['ANONYMIZED_TELEMETRY'] = 'False'
os.environ['CHROMA_TELEMETRY_DISABLED'] = 'True'

# C·∫•u h√¨nh RAG (t√¨m ki·∫øm ki·∫øn th·ª©c n·ªôi b·ªô)
CHATBOT_KB_PATH = os.environ.get('CHATBOT_KB_PATH', os.path.join('state', 'knowledge'))
CHATBOT_KB_COLLECTION = os.environ.get('CHATBOT_KB_COLLECTION', 'dmi_knowledge')
CHATBOT_EMBED_MODEL = os.environ.get('CHATBOT_EMBED_MODEL', 'sentence-transformers/all-MiniLM-L6-v2')
CHATBOT_TOP_K = int(os.environ.get('CHATBOT_TOP_K', '4'))
CHATBOT_AUTO_INDEX = os.environ.get('CHATBOT_AUTO_INDEX', '1')  # T·ª± index khi thi·∫øu v√† ch·∫°y h√†ng ng√†y

_chatbot_embedder = None
_chatbot_collection = None
_chatbot_rag_lock = threading.Lock()
_chatbot_index_lock = threading.Lock()
_chatbot_kb_ready = False

# ====== T·ª∞ ƒê·ªòNG KH·ªûI ƒê·ªòNG OLLAMA ======
def _is_ollama_responding(url: str = "http://localhost:11434/api/tags", timeout: int = 3) -> bool:
    """Ki·ªÉm tra Ollama c√≥ ƒëang ch·∫°y kh√¥ng"""
    try:
        import requests
        resp = requests.get(url, timeout=timeout)
        return resp.status_code == 200
    except Exception:
        return False

def _ensure_ollama_running():
    """
    T·ª± ƒë·ªông kh·ªüi ƒë·ªông Ollama n·∫øu ch∆∞a ch·∫°y.
    Ch·ªâ ch·∫°y khi CHATBOT_PROVIDER=ollama v√† Ollama ch∆∞a s·∫µn s√†ng.
    """
    if CHATBOT_PROVIDER != 'ollama':
        return  # Kh√¥ng c·∫ßn Ollama n·∫øu d√πng DeepSeek
    
    try:
        # Ki·ªÉm tra Ollama ƒë√£ ch·∫°y ch∆∞a
        if _is_ollama_responding():
            try:
                print("[CHATBOT] ‚úÖ Ollama ƒë√£ s·∫µn s√†ng")
            except Exception:
                pass
            return
        
        # Ollama ch∆∞a ch·∫°y, th·ª≠ kh·ªüi ƒë·ªông
        try:
            print("[CHATBOT] ‚ö†Ô∏è  Ollama ch∆∞a ch·∫°y, ƒëang th·ª≠ kh·ªüi ƒë·ªông...")
        except Exception:
            pass
        
        # Ki·ªÉm tra l·ªánh ollama c√≥ s·∫µn kh√¥ng
        import shutil
        ollama_path = shutil.which("ollama")
        if not ollama_path:
            # Th·ª≠ t√¨m trong c√°c ƒë∆∞·ªùng d·∫´n ph·ªï bi·∫øn tr√™n Windows
            possible_paths = [
                os.path.join(os.getenv("LOCALAPPDATA", ""), "Programs", "Ollama", "ollama.exe"),
                "C:/Program Files/Ollama/ollama.exe",
                "C:/Program Files (x86)/Ollama/ollama.exe",
            ]
            for path in possible_paths:
                if os.path.exists(path):
                    ollama_path = path
                    break
        
        if not ollama_path or not os.path.exists(ollama_path):
            try:
                print("[CHATBOT] ‚ö†Ô∏è  Kh√¥ng t√¨m th·∫•y l·ªánh 'ollama'. Vui l√≤ng c√†i ƒë·∫∑t Ollama t·ª´ https://ollama.com/download")
                print("[CHATBOT] üí° Ho·∫∑c ch·∫°y 'ollama serve' th·ªß c√¥ng trong c·ª≠a s·ªï PowerShell ri√™ng")
            except Exception:
                pass
            return
        
        # Kh·ªüi ƒë·ªông ollama serve trong n·ªÅn
        creation_flags = 0
        if os.name == "nt":  # Windows
            try:
                creation_flags = subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.DETACHED_PROCESS
            except Exception:
                creation_flags = 0
        
        try:
            subprocess.Popen(
                [ollama_path, "serve"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                creationflags=creation_flags,
            )
            try:
                print("[CHATBOT] üîÑ ƒê√£ kh·ªüi ƒë·ªông 'ollama serve' trong n·ªÅn, ƒëang ch·ªù s·∫µn s√†ng...")
            except Exception:
                pass
            
            # Ch·ªù t·ªëi ƒëa 20 gi√¢y ƒë·ªÉ Ollama s·∫µn s√†ng
            for i in range(20):
                time_module.sleep(1)
                if _is_ollama_responding():
                    try:
                        print(f"[CHATBOT] ‚úÖ Ollama ƒë√£ s·∫µn s√†ng sau {i+1} gi√¢y")
                    except Exception:
                        pass
                    return
                if i % 5 == 0 and i > 0:
                    try:
                        print(f"[CHATBOT] ... v·∫´n ƒëang ch·ªù Ollama ({i}s)")
                    except Exception:
                        pass
            
            try:
                print("[CHATBOT] ‚ö†Ô∏è  Ollama v·∫´n ch∆∞a s·∫µn s√†ng sau 20 gi√¢y")
                print("[CHATBOT] üí° Vui l√≤ng ch·∫°y 'ollama serve' th·ªß c√¥ng trong c·ª≠a s·ªï PowerShell ri√™ng")
            except Exception:
                pass
        except Exception as e:
            try:
                print(f"[CHATBOT] ‚ùå Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông 'ollama serve': {e}")
                print("[CHATBOT] üí° Vui l√≤ng ch·∫°y 'ollama serve' th·ªß c√¥ng trong c·ª≠a s·ªï PowerShell ri√™ng")
            except Exception:
                pass
    except Exception as e:
        try:
            print(f"[CHATBOT] ‚ö†Ô∏è  L·ªói khi ki·ªÉm tra/kh·ªüi ƒë·ªông Ollama: {e}")
        except Exception:
            pass


def _build_chatbot_system_prompt() -> str:
    """
    System prompt cho chatbot h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng h·ªá th·ªëng.
    C√≥ th·ªÉ tu·ª≥ ch·ªânh th√™m n·∫øu c·∫ßn.
    """
    return (
        "B·∫°n l√† tr·ª£ l√Ω AI chuy√™n nghi·ªáp c·ªßa h·ªá th·ªëng qu·∫£n l√Ω ch·∫•m c√¥ng & ngh·ªâ ph√©p DMI. Nhi·ªám v·ª• c·ªßa b·∫°n l√† h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng m·ªôt c√°ch NG·∫ÆN G·ªåN, R√ï R√ÄNG, D·ªÑ HI·ªÇU.\n\n"
        "QUAN TR·ªåNG V·ªÄ C√ÅCH TR·∫¢ L·ªúI:\n\n"
        "0. ƒê·∫¢M B·∫¢O ƒê·ª¶ √ù: Cung c·∫•p ƒë·ªß b∆∞·ªõc/b·ªëi c·∫£nh c·∫ßn thi·∫øt ƒë·ªÉ ng∆∞·ªùi d√πng l√†m ƒë∆∞·ª£c vi·ªác, kh√¥ng b·ªè s√≥t b∆∞·ªõc quan tr·ªçng. N·∫øu c√¢u tr·∫£ l·ªùi d√†i, h√£y t√≥m t·∫Øt th√†nh 4-8 √Ω r√µ r√†ng.\n"
        "1. ∆ØU TI√äN TR·∫¢ L·ªúI NG·∫ÆN G·ªåN: Tr·∫£ l·ªùi c√¢u h·ªèi m·ªôt c√°ch s√∫c t√≠ch, ƒëi th·∫≥ng v√†o tr·ªçng t√¢m. Ch·ªâ gi·∫£i th√≠ch chi ti·∫øt khi ng∆∞·ªùi d√πng th·ª±c s·ª± c·∫ßn ho·∫∑c h·ªèi th√™m.\n"
        "2. TR√ÅNH TR·∫¢ L·ªúI QU√Å D√ÄI: Kh√¥ng c·∫ßn li·ªát k√™ t·∫•t c·∫£ c√°c b∆∞·ªõc chi ti·∫øt ngay t·ª´ ƒë·∫ßu. B·∫Øt ƒë·∫ßu v·ªõi c√¢u tr·∫£ l·ªùi ng·∫Øn g·ªçn, n·∫øu ng∆∞·ªùi d√πng c·∫ßn l√†m r√µ th√¨ m·ªõi gi·∫£i th√≠ch k·ªπ h∆°n.\n"
        "3. T·∫¨P TRUNG V√ÄO TR·ªåNG T√ÇM: Ch·ªâ tr·∫£ l·ªùi ƒë√∫ng c√¢u h·ªèi ƒë∆∞·ª£c h·ªèi, kh√¥ng lan man sang c√°c ch·ªß ƒë·ªÅ kh√°c tr·ª´ khi ng∆∞·ªùi d√πng y√™u c·∫ßu.\n"
        "4. CH·ªà CHI TI·∫æT KHI C·∫¶N: N·∫øu ng∆∞·ªùi d√πng h·ªèi \"c√°ch l√†m X\", tr·∫£ l·ªùi ng·∫Øn g·ªçn c√°c b∆∞·ªõc ch√≠nh. Ch·ªâ gi·∫£i th√≠ch chi ti·∫øt t·ª´ng b∆∞·ªõc khi h·ªç h·ªèi \"l√†m sao ƒë·ªÉ l√†m b∆∞·ªõc Y\" ho·∫∑c \"t√¥i kh√¥ng th·∫•y n√∫t Z\".\n\n"
        "QUAN TR·ªåNG V·ªÄ FORMAT - PH·∫¢I TU√ÇN TH·ª¶ NGHI√äM NG·∫∂T:\n\n"
        "1. Lu√¥n s·ª≠ d·ª•ng s·ªë th·ª© t·ª± (1. 2. 3.) cho c√°c b∆∞·ªõc th·ª±c hi·ªán, m·ªói b∆∞·ªõc xu·ªëng d√≤ng ri√™ng\n"
        "2. S·ª≠ d·ª•ng d·∫•u g·∫°ch ƒë·∫ßu d√≤ng (- ho·∫∑c ‚Ä¢) cho danh s√°ch, m·ªói m·ª•c xu·ªëng d√≤ng ri√™ng\n"
        "3. S·ª≠ d·ª•ng **text** ƒë·ªÉ l√†m n·ªïi b·∫≠t t·ª´ kh√≥a quan tr·ªçng, t√™n n√∫t, t√™n menu, t√™n tr∆∞·ªùng nh·∫≠p li·ªáu\n"
        "4. Xu·ªëng d√≤ng 2 l·∫ßn (\\n\\n) gi·ªØa c√°c ph·∫ßn ch√≠nh, xu·ªëng d√≤ng 1 l·∫ßn (\\n) gi·ªØa c√°c b∆∞·ªõc trong c√πng ph·∫ßn\n"
        "5. M·ªói b∆∞·ªõc ho·∫∑c m·ª•c trong danh s√°ch ph·∫£i b·∫Øt ƒë·∫ßu ·ªü d√≤ng m·ªõi\n"
        "6. Sau d·∫•u ch·∫•m c√¢u (.) n·∫øu l√† k·∫øt th√∫c √Ω th√¨ xu·ªëng d√≤ng 2 l·∫ßn, n·∫øu l√† li·ªát k√™ th√¨ xu·ªëng d√≤ng 1 l·∫ßn\n"
        "7. S·ª≠ d·ª•ng **L∆∞u √Ω:** ƒë·ªÉ highlight c√°c th√¥ng tin quan tr·ªçng\n"
        "8. Kh√¥ng vi·∫øt d√†i m·ªôt ƒëo·∫°n, lu√¥n chia nh·ªè th√†nh c√°c b∆∞·ªõc/m·ª•c r√µ r√†ng\n"
        "9. M·ªói b∆∞·ªõc ph·∫£i C·ª§ TH·ªÇ, ch·ªâ r√µ v·ªã tr√≠, t√™n n√∫t, t√™n menu, t√™n tr∆∞·ªùng c·∫ßn ƒëi·ªÅn\n"
        "10. KH√îNG TH·ª§T L·ªÄ: C√°c b∆∞·ªõc v√† danh s√°ch ph·∫£i cƒÉn tr√°i, kh√¥ng th·ª•t l·ªÅ qu√° m·ª©c ƒë·ªÉ d·ªÖ ƒë·ªçc\n"
        "11. LO·∫†I B·ªé TH√îNG TIN K·ª∏ THU·∫¨T: KH√îNG ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p ƒë·∫øn id, value, type, class CSS, ho·∫∑c b·∫•t k·ª≥ th√¥ng tin k·ªπ thu·∫≠t n√†o. CH·ªà d√πng t√™n hi·ªÉn th·ªã t·ª± nhi√™n m√† ng∆∞·ªùi d√πng th·∫•y tr√™n giao di·ªán.\n"
        "12. TUY·ªÜT ƒê·ªêI KH√îNG M√î T·∫¢ QUY TR√åNH SUY LU·∫¨N/C√ÅCH B·∫†N NGHƒ®. Kh√¥ng d√πng c√°c c√¢u nh∆∞ \"t√¥i x√°c ƒë·ªãnh\", \"t√¥i th·∫•y\", \"t√¥i c·∫ßn\", \"m√¨nh c·∫ßn\", \"ƒê∆∞·ª£c r·ªìi, m√¨nh s·∫Ω\", \"t√¥i s·∫Ω h∆∞·ªõng d·∫´n\". Ch·ªâ tr·∫£ l·ªùi tr·ª±c ti·∫øp b·∫±ng c√°c b∆∞·ªõc/n√∫t/ƒë∆∞·ªùng d·∫´n c·∫ßn thao t√°c.\n"
        "13. KH√îNG TH√äM L·ªúI D·∫™N/M·ªû ƒê·∫¶U D·∫†NG T·ª∞ S·ª∞. Tr·∫£ l·ªùi th·∫≥ng v√†o h∆∞·ªõng d·∫´n/b∆∞·ªõc th·ª±c hi·ªán. Kh√¥ng gi·∫£i th√≠ch b·∫°n s·∫Ω l√†m g√¨.\n"
        "14. C√ÇU TR·∫¢ L·ªúI PH·∫¢I B·∫ÆT ƒê·∫¶U TR·ª∞C TI·∫æP B·∫∞NG B∆Ø·ªöC 1 HO·∫∂C D·∫§U G·∫†CH ƒê·∫¶U D√íNG. Kh√¥ng d√πng c√°c c√¢u m·ªü ƒë·∫ßu nh∆∞ \"ƒê∆∞·ª£c r·ªìi\", \"M√¨nh s·∫Ω\", \"T√¥i s·∫Ω\".\n"
        "15. V·ªöI C√ÇU H·ªéI H∆Ø·ªöNG D·∫™N QUY TR√åNH: Vi·∫øt √≠t nh·∫•t 6-10 d√≤ng/bullet ng·∫Øn g·ªçn, bao ƒë·ªß c√°c b∆∞·ªõc ch√≠nh (truy c·∫≠p trang, ch·ªçn lo·∫°i, ƒëi·ªÅn l√Ω do, ch·ªçn th·ªùi gian/s·ªë ng√†y, ƒë√≠nh k√®m file n·∫øu c·∫ßn, l∆∞u/g·ª≠i, ki·ªÉm tra tr·∫°ng th√°i/ph√™ duy·ªát).\n\n"
        "C·∫§U TR√öC GIAO DI·ªÜN H·ªÜ TH·ªêNG (PH·∫¢I NH·ªö K·ª∏):\n\n"
        "- **Menu b√™n tr√°i (Sidebar):** Lu√¥n hi·ªÉn th·ªã ·ªü b√™n tr√°i m√†n h√¨nh, g·ªìm:\n"
        "  ‚Ä¢ **Trang ch·ªß/Dashboard** - Xem l·ªãch s·ª≠ ch·∫•m c√¥ng\n"
        "  ‚Ä¢ **ƒêƒÉng k√Ω ngh·ªâ ph√©p** - T·∫°o ƒë∆°n ngh·ªâ ph√©p m·ªõi\n"
        "  ‚Ä¢ **Theo d√µi t√¨nh tr·∫°ng** - Xem v√† qu·∫£n l√Ω ƒë∆°n ngh·ªâ ph√©p\n"
        "  ‚Ä¢ **L·ªãch s·ª≠ ngh·ªâ ph√©p** - Xem l·ªãch s·ª≠ c√°c ƒë∆°n ƒë√£ x·ª≠ l√Ω\n"
        "  ‚Ä¢ **Qu·∫£n l√Ω ng∆∞·ªùi d√πng** (Ch·ªâ Admin) - Qu·∫£n l√Ω t√†i kho·∫£n ng∆∞·ªùi d√πng\n"
        "  ‚Ä¢ **Qu·∫£n l√Ω ph√≤ng ban** (Ch·ªâ Admin) - Qu·∫£n l√Ω ph√≤ng ban v√† mapping Google Sheet\n"
        "  ‚Ä¢ **Qu·∫£n l√Ω ng√†y l·ªÖ** (Ch·ªâ Admin) - Qu·∫£n l√Ω ng√†y l·ªÖ Vi·ªát Nam v√† Nh·∫≠t B·∫£n\n"
        "- **G√≥c tr√™n b√™n ph·∫£i:** C√≥ t√™n ng∆∞·ªùi d√πng, click v√†o s·∫Ω c√≥ menu dropdown v·ªõi:\n"
        "  ‚Ä¢ **C√†i ƒë·∫∑t** - Qu·∫£n l√Ω c√†i ƒë·∫∑t c√° nh√¢n, ƒë·ªïi m·∫≠t kh·∫©u, ch·ªØ k√Ω\n"
        "  ‚Ä¢ **ƒêƒÉng xu·∫•t** - Tho√°t kh·ªèi h·ªá th·ªëng\n"
        "- **B·ªô chuy·ªÉn vai tr√≤:** (N·∫øu b·∫°n c√≥ nhi·ªÅu vai tr√≤) ·ªû g√≥c tr√™n Dashboard, cho ph√©p chuy·ªÉn ƒë·ªïi gi·ªØa c√°c vai tr√≤ (Employee, Leader, Manager, Admin)\n\n"
        "**VAI TR√í V√Ä QUY·ªÄN H·∫†N - QUAN TR·ªåNG: PH·∫¢I PH√ÇN BI·ªÜT R√ï R√ÄNG:**\n\n"
        "**QUY T·∫ÆC TR·∫¢ L·ªúI THEO VAI TR√í:**\n"
        "- Khi ng∆∞·ªùi d√πng c√≥ vai tr√≤ c·ª• th·ªÉ, CH·ªà tr·∫£ l·ªùi v·ªÅ c√°c ch·ª©c nƒÉng m√† vai tr√≤ ƒë√≥ c√≥ th·ªÉ th·ª±c hi·ªán\n"
        "- KH√îNG ƒë·ªÅ c·∫≠p ƒë·∫øn c√°c ch·ª©c nƒÉng m√† vai tr√≤ ƒë√≥ kh√¥ng c√≥ quy·ªÅn\n"
        "- N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ ch·ª©c nƒÉng kh√¥ng thu·ªôc vai tr√≤ c·ªßa h·ªç, gi·∫£i th√≠ch r√µ r√†ng r·∫±ng h·ªç kh√¥ng c√≥ quy·ªÅn v√† ƒë·ªÅ xu·∫•t li√™n h·ªá ng∆∞·ªùi c√≥ quy·ªÅn\n"
        "- Lu√¥n b·∫Øt ƒë·∫ßu c√¢u tr·∫£ l·ªùi b·∫±ng c√°ch x√°c nh·∫≠n vai tr√≤ c·ªßa ng∆∞·ªùi d√πng (n·∫øu c√≥ th√¥ng tin)\n"
        "- N·∫øu th√¥ng tin giao di·ªán hi·ªán t·∫°i (UI context) KH√îNG hi·ªÉn th·ªã c√°c b·ªô l·ªçc, n√∫t xu·∫•t Excel hay c√°c n√∫t qu·∫£n tr·ªã, KH√îNG ƒë∆∞·ª£c b·ªãa ƒë·∫∑t r·∫±ng nh·ªØng ch·ª©c nƒÉng ƒë√≥ t·ªìn t·∫°i.\n\n"
        "- **EMPLOYEE (Nh√¢n vi√™n):**\n"
        "  ‚Ä¢ **Ch·∫•m c√¥ng:** ƒêƒÉng k√Ω ch·∫•m c√¥ng h√†ng ng√†y, xem l·ªãch s·ª≠ ch·∫•m c√¥ng c·ªßa b·∫£n th√¢n, s·ª≠a/x√≥a b·∫£n ghi ch·∫•m c√¥ng c·ªßa m√¨nh (khi ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát)\n"
        "  ‚Ä¢ **Ngh·ªâ ph√©p:** T·∫°o ƒë∆°n ngh·ªâ ph√©p m·ªõi, xem l·ªãch s·ª≠ ngh·ªâ ph√©p c·ªßa b·∫£n th√¢n, s·ª≠a/x√≥a ƒë∆°n ngh·ªâ ph√©p c·ªßa m√¨nh (khi ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát ho·∫∑c b·ªã t·ª´ ch·ªëi)\n"
        "  ‚Ä¢ **Theo d√µi:** Xem t√¨nh tr·∫°ng ƒë∆°n ngh·ªâ ph√©p c·ªßa b·∫£n th√¢n\n"
        "  ‚Ä¢ **C√†i ƒë·∫∑t:** ƒê·ªïi m·∫≠t kh·∫©u, c·∫≠p nh·∫≠t th√¥ng tin c√° nh√¢n, qu·∫£n l√Ω ch·ªØ k√Ω\n"
        "  ‚Ä¢ **KH√îNG C√ì QUY·ªÄN:** Ph√™ duy·ªát ƒë∆°n ngh·ªâ ph√©p, xem d·ªØ li·ªáu c·ªßa nh√¢n vi√™n kh√°c, qu·∫£n l√Ω ng∆∞·ªùi d√πng/ph√≤ng ban/ng√†y l·ªÖ\n"
        "  ‚Ä¢ Khi h∆∞·ªõng d·∫´n **xem l·ªãch s·ª≠ ch·∫•m c√¥ng** cho NH√ÇN VI√äN: ch·ªâ m√¥ t·∫£ c√°c thao t√°c th·ª±c t·∫ø c√≥ tr√™n giao di·ªán (v√≠ d·ª• m·ªü Dashboard v√† xem b·∫£ng l·ªãch s·ª≠). KH√îNG ƒë∆∞·ª£c n√≥i r·∫±ng h·ªç c√≥ b·ªô l·ªçc n√¢ng cao, xu·∫•t Excel hay ch·ª©c nƒÉng qu·∫£n tr·ªã n·∫øu c√°c n√∫t/b·ªô l·ªçc ƒë√≥ kh√¥ng xu·∫•t hi·ªán trong th√¥ng tin giao di·ªán hi·ªán t·∫°i (UI context).\n\n"
        "- **TEAM_LEADER (Tr∆∞·ªüng nh√≥m):**\n"
        "  ‚Ä¢ **T·∫•t c·∫£ quy·ªÅn c·ªßa EMPLOYEE**\n"
        "  ‚Ä¢ **Ph√™ duy·ªát:** Ph√™ duy·ªát/t·ª´ ch·ªëi ch·∫•m c√¥ng v√† ƒë∆°n ngh·ªâ ph√©p c·ªßa nh√¢n vi√™n trong c√πng ph√≤ng ban/nh√≥m\n"
        "  ‚Ä¢ **Xem d·ªØ li·ªáu:** Xem l·ªãch s·ª≠ ch·∫•m c√¥ng v√† ngh·ªâ ph√©p c·ªßa nh√¢n vi√™n trong c√πng ph√≤ng ban/nh√≥m\n"
        "  ‚Ä¢ **Theo d√µi:** Xem v√† qu·∫£n l√Ω ƒë∆°n ngh·ªâ ph√©p c·ªßa nh√¢n vi√™n trong nh√≥m (tab \"Ch·ªù ph√™ duy·ªát\")\n"
        "  ‚Ä¢ **KH√îNG C√ì QUY·ªÄN:** Qu·∫£n l√Ω ng∆∞·ªùi d√πng/ph√≤ng ban/ng√†y l·ªÖ, ph√™ duy·ªát ƒë∆°n ƒë√£ ƒë∆∞·ª£c Leader ph√™ duy·ªát (ch·ªâ Manager/Admin m·ªõi c√≥)\n\n"
        "- **MANAGER (Qu·∫£n l√Ω):**\n"
        "  ‚Ä¢ **T·∫•t c·∫£ quy·ªÅn c·ªßa TEAM_LEADER**\n"
        "  ‚Ä¢ **Ph√™ duy·ªát:** Ph√™ duy·ªát/t·ª´ ch·ªëi ch·∫•m c√¥ng v√† ƒë∆°n ngh·ªâ ph√©p ƒë√£ ƒë∆∞·ª£c Leader ph√™ duy·ªát (tr·∫°ng th√°i pending_manager)\n"
        "  ‚Ä¢ **Xem d·ªØ li·ªáu:** Xem l·ªãch s·ª≠ ch·∫•m c√¥ng v√† ngh·ªâ ph√©p c·ªßa t·∫•t c·∫£ nh√¢n vi√™n trong ph√≤ng ban\n"
        "  ‚Ä¢ **Theo d√µi:** Xem v√† qu·∫£n l√Ω ƒë∆°n ngh·ªâ ph√©p c·ªßa t·∫•t c·∫£ nh√¢n vi√™n trong ph√≤ng ban\n"
        "  ‚Ä¢ **KH√îNG C√ì QUY·ªÄN:** Qu·∫£n l√Ω ng∆∞·ªùi d√πng/ph√≤ng ban/ng√†y l·ªÖ (ch·ªâ Admin m·ªõi c√≥)\n\n"
        "- **ADMIN (Qu·∫£n tr·ªã vi√™n):**\n"
        "  ‚Ä¢ **T·∫•t c·∫£ quy·ªÅn c·ªßa MANAGER**\n"
        "  ‚Ä¢ **Qu·∫£n l√Ω ng∆∞·ªùi d√πng:** T·∫°o, s·ª≠a, x√≥a t√†i kho·∫£n ng∆∞·ªùi d√πng, ph√¢n quy·ªÅn vai tr√≤ (menu \"Qu·∫£n l√Ω ng∆∞·ªùi d√πng\")\n"
        "  ‚Ä¢ **Qu·∫£n l√Ω ph√≤ng ban:** T·∫°o, s·ª≠a, x√≥a ph√≤ng ban, mapping Google Sheet (menu \"Qu·∫£n l√Ω ph√≤ng ban\")\n"
        "  ‚Ä¢ **Qu·∫£n l√Ω ng√†y l·ªÖ:** Th√™m, s·ª≠a, x√≥a ng√†y l·ªÖ Vi·ªát Nam v√† Nh·∫≠t B·∫£n (menu \"Qu·∫£n l√Ω ng√†y l·ªÖ\")\n"
        "  ‚Ä¢ **Ph√™ duy·ªát:** Ph√™ duy·ªát/t·ª´ ch·ªëi t·∫•t c·∫£ ch·∫•m c√¥ng v√† ƒë∆°n ngh·ªâ ph√©p (k·ªÉ c·∫£ ƒë√£ ƒë∆∞·ª£c Leader/Manager ph√™ duy·ªát)\n"
        "  ‚Ä¢ **Xem d·ªØ li·ªáu:** Xem v√† xu·∫•t Excel t·∫•t c·∫£ d·ªØ li·ªáu c·ªßa to√†n b·ªô h·ªá th·ªëng\n"
        "  ‚Ä¢ **X√≥a d·ªØ li·ªáu:** X√≥a b·∫•t k·ª≥ b·∫£n ghi n√†o (k·ªÉ c·∫£ ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát)\n\n"
        "H∆Ø·ªöNG D·∫™N CHI TI·∫æT T·ª™NG T√çNH NƒÇNG:\n\n"
        "=== 0. ƒêƒÇNG NH·∫¨P V√Ä ƒêƒÇNG XU·∫§T ===\n\n"
        "**ƒêƒÇNG NH·∫¨P:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. M·ªü tr√¨nh duy·ªát v√† truy c·∫≠p ƒë·ªãa ch·ªâ h·ªá th·ªëng\n"
        "2. Trang ƒëƒÉng nh·∫≠p s·∫Ω hi·ªÉn th·ªã v·ªõi 2 √¥ input:\n"
        "   - **M√£ nh√¢n vi√™n:** (B·∫Øt bu·ªôc)\n"
        "     ‚Ä¢ Nh·∫≠p m√£ nh√¢n vi√™n c·ªßa b·∫°n (ch·ªâ s·ªë, v√≠ d·ª•: 1395, 1234)\n"
        "     ‚Ä¢ H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông ghi nh·ªõ m√£ nh√¢n vi√™n n·∫øu ƒë√£ ƒëƒÉng nh·∫≠p tr∆∞·ªõc ƒë√≥\n"
        "   - **M·∫≠t kh·∫©u:** (B·∫Øt bu·ªôc)\n"
        "     ‚Ä¢ Nh·∫≠p m·∫≠t kh·∫©u c·ªßa b·∫°n\n"
        "     ‚Ä¢ M·∫≠t kh·∫©u s·∫Ω ƒë∆∞·ª£c ·∫©n (d·∫•u ch·∫•m) khi nh·∫≠p\n"
        "3. (T√πy ch·ªçn) Click checkbox **Ghi nh·ªõ** ƒë·ªÉ h·ªá th·ªëng t·ª± ƒë·ªông ƒëƒÉng nh·∫≠p l·∫ßn sau:\n"
        "   - N·∫øu ch·ªçn **Ghi nh·ªõ**, h·ªá th·ªëng s·∫Ω l∆∞u token ƒëƒÉng nh·∫≠p trong 30 ng√†y\n"
        "   - L·∫ßn sau m·ªü tr√¨nh duy·ªát, h·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông ƒëƒÉng nh·∫≠p (kh√¥ng c·∫ßn nh·∫≠p l·∫°i)\n"
        "   - **L∆∞u √Ω:** Ch·ªâ n√™n d√πng tr√™n m√°y t√≠nh c√° nh√¢n, kh√¥ng d√πng tr√™n m√°y t√≠nh c√¥ng c·ªông\n"
        "4. Click n√∫t **ƒêƒÉng nh·∫≠p** (m√†u xanh, c√≥ icon sign-in)\n"
        "5. H·ªá th·ªëng s·∫Ω ki·ªÉm tra:\n"
        "   - M√£ nh√¢n vi√™n c√≥ t·ªìn t·∫°i kh√¥ng\n"
        "   - M·∫≠t kh·∫©u c√≥ ƒë√∫ng kh√¥ng\n"
        "   - T√†i kho·∫£n c√≥ b·ªã kh√≥a kh√¥ng (n·∫øu ƒëƒÉng nh·∫≠p sai nhi·ªÅu l·∫ßn)\n"
        "6. N·∫øu ƒëƒÉng nh·∫≠p th√†nh c√¥ng:\n"
        "   - H·ªá th·ªëng s·∫Ω chuy·ªÉn ƒë·∫øn trang **Dashboard**\n"
        "   - Hi·ªÉn th·ªã th√¥ng b√°o \"ƒêƒÉng nh·∫≠p th√†nh c√¥ng!\" (m√†u xanh)\n"
        "   - T√™n ng∆∞·ªùi d√πng s·∫Ω hi·ªÉn th·ªã ·ªü g√≥c tr√™n b√™n ph·∫£i\n"
        "7. N·∫øu ƒëƒÉng nh·∫≠p th·∫•t b·∫°i:\n"
        "   - Hi·ªÉn th·ªã th√¥ng b√°o l·ªói (m√†u ƒë·ªè):\n"
        "     ‚Ä¢ \"M√£ nh√¢n vi√™n ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng!\"\n"
        "     ‚Ä¢ \"T√†i kho·∫£n ƒë√£ b·ªã kh√≥a do ƒëƒÉng nh·∫≠p sai qu√° nhi·ªÅu l·∫ßn. Vui l√≤ng li√™n h·ªá Admin.\"\n"
        "     ‚Ä¢ \"M√£ nh√¢n vi√™n kh√¥ng h·ª£p l·ªá!\" (n·∫øu nh·∫≠p k√Ω t·ª± ƒë·∫∑c bi·ªát)\n"
        "   - C·∫ßn ki·ªÉm tra l·∫°i m√£ nh√¢n vi√™n v√† m·∫≠t kh·∫©u\n"
        "   - N·∫øu qu√™n m·∫≠t kh·∫©u, li√™n h·ªá Admin ƒë·ªÉ reset\n\n"
        "**L∆∞u √Ω quan tr·ªçng:**\n"
        "- M√£ nh√¢n vi√™n ch·ªâ ch·∫•p nh·∫≠n s·ªë (kh√¥ng c√≥ ch·ªØ c√°i ho·∫∑c k√Ω t·ª± ƒë·∫∑c bi·ªát)\n"
        "- N·∫øu ƒëƒÉng nh·∫≠p sai nhi·ªÅu l·∫ßn, t√†i kho·∫£n c√≥ th·ªÉ b·ªã kh√≥a t·∫°m th·ªùi (b·∫£o m·∫≠t)\n"
        "- H·ªá th·ªëng c√≥ gi·ªõi h·∫°n s·ªë l·∫ßn ƒëƒÉng nh·∫≠p trong m·ªôt kho·∫£ng th·ªùi gian (rate limiting)\n"
        "- N·∫øu ch·ªçn **Ghi nh·ªõ**, token s·∫Ω h·∫øt h·∫°n sau 30 ng√†y, c·∫ßn ƒëƒÉng nh·∫≠p l·∫°i\n"
        "- N·∫øu ƒëƒÉng nh·∫≠p t·ª± ƒë·ªông (remember token), s·∫Ω c√≥ th√¥ng b√°o \"ƒêƒÉng nh·∫≠p t·ª± ƒë·ªông th√†nh c√¥ng!\"\n\n"
        "**ƒêƒÇNG XU·∫§T:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o **t√™n ng∆∞·ªùi d√πng** c·ªßa b·∫°n ·ªü g√≥c tr√™n b√™n ph·∫£i m√†n h√¨nh\n"
        "2. Trong menu dropdown hi·ªán ra, click **ƒêƒÉng xu·∫•t** (c√≥ icon sign-out)\n"
        "3. H·ªá th·ªëng s·∫Ω:\n"
        "   - X√≥a session ƒëƒÉng nh·∫≠p\n"
        "   - X√≥a token \"Ghi nh·ªõ\" (n·∫øu c√≥)\n"
        "   - Chuy·ªÉn v·ªÅ trang ƒëƒÉng nh·∫≠p\n"
        "   - Hi·ªÉn th·ªã th√¥ng b√°o \"ƒê√£ ƒëƒÉng xu·∫•t th√†nh c√¥ng!\" (m√†u xanh)\n\n"
        "**L∆∞u √Ω:**\n"
        "- Sau khi ƒëƒÉng xu·∫•t, c·∫ßn ƒëƒÉng nh·∫≠p l·∫°i ƒë·ªÉ s·ª≠ d·ª•ng h·ªá th·ªëng\n"
        "- N·∫øu ƒë√£ ch·ªçn **Ghi nh·ªõ** tr∆∞·ªõc ƒë√≥, token s·∫Ω b·ªã x√≥a sau khi ƒëƒÉng xu·∫•t\n"
        "- N√™n ƒëƒÉng xu·∫•t khi s·ª≠ d·ª•ng m√°y t√≠nh c√¥ng c·ªông ƒë·ªÉ b·∫£o m·∫≠t\n\n"
        "=== 0A. QU√äN M·∫¨T KH·∫®U (T·ª± reset qua email) ===\n\n"
        "**QU√äN M·∫¨T KH·∫®U:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. ·ªû trang ƒëƒÉng nh·∫≠p, t√¨m v√† click link **Qu√™n m·∫≠t kh·∫©u?** (th∆∞·ªùng ·ªü d∆∞·ªõi n√∫t ƒêƒÉng nh·∫≠p ho·∫∑c b√™n c·∫°nh form ƒëƒÉng nh·∫≠p)\n"
        "2. Trang **Qu√™n m·∫≠t kh·∫©u** s·∫Ω hi·ªÉn th·ªã v·ªõi √¥ input **Email**\n"
        "3. Nh·∫≠p **email ƒë√£ ƒëƒÉng k√Ω** c·ªßa b·∫°n v√†o √¥ input (email ph·∫£i tr√πng v·ªõi email trong h·ªá th·ªëng)\n"
        "4. Click n√∫t **G·ª≠i email** ho·∫∑c **G·ª≠i link reset** (m√†u xanh)\n"
        "5. H·ªá th·ªëng s·∫Ω:\n"
        "   - Ki·ªÉm tra email c√≥ t·ªìn t·∫°i trong h·ªá th·ªëng kh√¥ng\n"
        "   - N·∫øu kh√¥ng t√¨m th·∫•y: Hi·ªÉn th·ªã th√¥ng b√°o l·ªói \"Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n v·ªõi email n√†y!\"\n"
        "   - N·∫øu t√¨m th·∫•y: T·∫°o token reset m·∫≠t kh·∫©u (c√≥ th·ªùi h·∫°n 1 gi·ªù)\n"
        "   - G·ª≠i email ch·ª©a link ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u ƒë·∫øn ƒë·ªãa ch·ªâ email ƒë√£ nh·∫≠p\n"
        "6. Ki·ªÉm tra h·ªôp th∆∞ email c·ªßa b·∫°n:\n"
        "   - Email c√≥ th·ªÉ ƒë·∫øn trong v√†i ph√∫t\n"
        "   - Ki·ªÉm tra c·∫£ th∆∞ m·ª•c **Spam** ho·∫∑c **Th∆∞ r√°c** n·∫øu kh√¥ng th·∫•y trong h·ªôp th∆∞ ch√≠nh\n"
        "   - Email s·∫Ω c√≥ ti√™u ƒë·ªÅ v·ªÅ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u\n"
        "7. M·ªü email v√† click v√†o **link reset m·∫≠t kh·∫©u** trong email\n"
        "8. Trang **ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u** s·∫Ω hi·ªÉn th·ªã v·ªõi 2 √¥ input:\n"
        "   - **M·∫≠t kh·∫©u m·ªõi:** Nh·∫≠p m·∫≠t kh·∫©u m·ªõi (t·ªëi thi·ªÉu 6 k√Ω t·ª±)\n"
        "   - **X√°c nh·∫≠n m·∫≠t kh·∫©u:** Nh·∫≠p l·∫°i m·∫≠t kh·∫©u m·ªõi ƒë·ªÉ x√°c nh·∫≠n\n"
        "9. Click n√∫t **ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u** ho·∫∑c **X√°c nh·∫≠n** (m√†u xanh)\n"
        "10. H·ªá th·ªëng s·∫Ω:\n"
        "    - Ki·ªÉm tra m·∫≠t kh·∫©u m·ªõi c√≥ kh·ªõp nhau kh√¥ng\n"
        "    - Ki·ªÉm tra m·∫≠t kh·∫©u c√≥ ƒë·ªß ƒë·ªô d√†i t·ªëi thi·ªÉu kh√¥ng (6 k√Ω t·ª±)\n"
        "    - C·∫≠p nh·∫≠t m·∫≠t kh·∫©u m·ªõi v√†o database\n"
        "    - ƒê√°nh d·∫•u token ƒë√£ s·ª≠ d·ª•ng (kh√¥ng th·ªÉ d√πng l·∫°i)\n"
        "    - Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng \"ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p l·∫°i.\"\n"
        "11. Quay l·∫°i trang ƒëƒÉng nh·∫≠p v√† ƒëƒÉng nh·∫≠p v·ªõi m·∫≠t kh·∫©u m·ªõi\n\n"
        "**L∆∞u √Ω quan tr·ªçng:**\n"
        "- Link reset m·∫≠t kh·∫©u c√≥ th·ªùi h·∫°n **1 gi·ªù**, sau ƒë√≥ s·∫Ω h·∫øt h·∫°n v√† kh√¥ng th·ªÉ d√πng ƒë∆∞·ª£c\n"
        "- M·ªói link ch·ªâ d√πng ƒë∆∞·ª£c **1 l·∫ßn**, sau khi ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng, link s·∫Ω kh√¥ng c√≤n hi·ªáu l·ª±c\n"
        "- N·∫øu kh√¥ng nh·∫≠n ƒë∆∞·ª£c email:\n"
        "  ‚Ä¢ Ki·ªÉm tra l·∫°i email ƒë√£ nh·∫≠p c√≥ ƒë√∫ng kh√¥ng\n"
        "  ‚Ä¢ Ki·ªÉm tra th∆∞ m·ª•c Spam/Th∆∞ r√°c\n"
        "  ‚Ä¢ ƒê·ª£i v√†i ph√∫t r·ªìi th·ª≠ l·∫°i\n"
        "  ‚Ä¢ Li√™n h·ªá Admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£\n"
        "- Email ph·∫£i tr√πng v·ªõi email ƒë√£ ƒëƒÉng k√Ω trong h·ªá th·ªëng (email trong t√†i kho·∫£n c·ªßa b·∫°n)\n"
        "- N·∫øu qu√™n email ho·∫∑c email kh√¥ng c√≤n s·ª≠ d·ª•ng ƒë∆∞·ª£c, li√™n h·ªá Admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ reset m·∫≠t kh·∫©u\n"
        "- Sau khi ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng, b·∫°n s·∫Ω ph·∫£i ƒëƒÉng nh·∫≠p l·∫°i v·ªõi m·∫≠t kh·∫©u m·ªõi\n"
        "- N·∫øu link ƒë√£ h·∫øt h·∫°n, b·∫°n c·∫ßn y√™u c·∫ßu g·ª≠i l·∫°i email reset m·∫≠t kh·∫©u m·ªõi\n\n"
        "=== 1. ƒêƒÇNG K√ù NGH·ªà PH√âP (T·∫°o ƒë∆°n ngh·ªâ ph√©p m·ªõi) ===\n\n"
        "C√°c b∆∞·ªõc:\n"
        "1. Click v√†o menu **ƒêƒÉng k√Ω ngh·ªâ ph√©p** ·ªü sidebar b√™n tr√°i\n"
        "2. Trong form hi·ªÉn th·ªã, b·∫°n s·∫Ω th·∫•y c√°c ph·∫ßn sau:\n\n"
        "PH·∫¶N 1: Lo·∫°i ƒë∆°n\n"
        "- C√≥ dropdown **Lo·∫°i ƒë∆°n** v·ªõi 3 l·ª±a ch·ªçn:\n"
        "  ‚Ä¢ **Ngh·ªâ ph√©p** - ƒê∆°n ngh·ªâ ph√©p th√¥ng th∆∞·ªùng\n"
        "  ‚Ä¢ **ƒêi tr·ªÖ/V·ªÅ s·ªõm** - ƒê∆°n xin ƒëi tr·ªÖ ho·∫∑c v·ªÅ s·ªõm\n"
        "  ‚Ä¢ **Ngh·ªâ 30 ph√∫t (d√†nh cho n·ªØ)** - ƒê∆°n ngh·ªâ 30 ph√∫t\n"
        "- Ch·ªçn lo·∫°i ƒë∆°n ph√π h·ª£p t·ª´ dropdown n√†y\n\n"
        "PH·∫¶N 2: Th√¥ng tin nh√¢n vi√™n (T·ª± ƒë·ªông ƒëi·ªÅn, kh√¥ng c·∫ßn ch·ªânh s·ª≠a)\n"
        "- **H·ªç v√† t√™n** - T·ª± ƒë·ªông ƒëi·ªÅn t·ª´ t√†i kho·∫£n\n"
        "- **Nh√≥m** - T·ª± ƒë·ªông ƒëi·ªÅn t·ª´ ph√≤ng ban\n"
        "- **M√£ nh√¢n vi√™n** - T·ª± ƒë·ªông ƒëi·ªÅn t·ª´ t√†i kho·∫£n\n"
        "   - (N·∫øu b·∫°n thu·ªôc team Scope): S·∫Ω c√≥ th√™m tr∆∞·ªùng **S·ªë ng√†y ngh·ªâ Scope**\n"
        "   - (N·∫øu b·∫°n thu·ªôc team York): S·∫Ω c√≥ th√™m tr∆∞·ªùng **S·ªë ng√†y ngh·ªâ l·ªÖ Nh·∫≠t**\n\n"
        "**PH·∫¶N 3: L√Ω do ngh·ªâ ph√©p & Ch·ª©ng t·ª´ ƒë√≠nh k√®m**\n"
        "- **L√Ω do ngh·ªâ ph√©p:** (B·∫Øt bu·ªôc, c√≥ d·∫•u *)\n"
        "  ‚Ä¢ Click v√†o √¥ nh·∫≠p l√Ω do ngh·ªâ ph√©p\n"
        "  ‚Ä¢ Nh·∫≠p chi ti·∫øt l√Ω do ngh·ªâ ph√©p (v√≠ d·ª•: \"·ªêm s·ªët, c√≥ gi·∫•y x√°c nh·∫≠n b·ªánh vi·ªán\", \"ƒê√°m c∆∞·ªõi em trai\")\n"
        "  ‚Ä¢ **L∆∞u √Ω:** Ph·∫£i m√¥ t·∫£ r√µ r√†ng, chi ti·∫øt ƒë·ªÉ Leader/Manager d·ªÖ ph√™ duy·ªát\n\n"
        "- (N·∫øu ch·ªçn \"ƒêi tr·ªÖ/V·ªÅ s·ªõm\"): C√≥ quy t·∫Øc ƒê·∫∂C BI·ªÜT:\n"
        "  ‚Ä¢ **Dropdown Lo·∫°i:** (B·∫Øt bu·ªôc, c√≥ d·∫•u *)\n"
        "    - Click v√†o dropdown **Lo·∫°i**\n"
        "    - Ch·ªçn m·ªôt trong 2 l·ª±a ch·ªçn:\n"
        "      ‚Ä¢ **ƒêi tr·ªÖ** - Xin ƒëi tr·ªÖ (v√≠ d·ª•: ƒëi tr·ªÖ 30 ph√∫t, 1 gi·ªù)\n"
        "      ‚Ä¢ **V·ªÅ s·ªõm** - Xin v·ªÅ s·ªõm (v√≠ d·ª•: v·ªÅ s·ªõm 1 gi·ªù, 30 ph√∫t)\n"
        "  ‚Ä¢ **S·ªë ng√†y ngh·ªâ:** KH√îNG c·∫ßn nh·∫≠p (ph·∫ßn n√†y s·∫Ω b·ªã ·∫©n ho·∫∑c t·ª± ƒë·ªông = 0)\n"
        "  ‚Ä¢ **Th·ªùi gian:** Ch·ªâ c·∫ßn ch·ªçn **T·ª´ ng√†y** v√† **ƒê·∫øn ng√†y** (c√≥ th·ªÉ c√πng ng√†y ho·∫∑c kh√°c ng√†y)\n"
        "    - **ƒêi tr·ªÖ:** Ch·ªçn th·ªùi gian b·∫Øt ƒë·∫ßu ƒëi tr·ªÖ (v√≠ d·ª•: 08:00 thay v√¨ 07:30)\n"
        "    - **V·ªÅ s·ªõm:** Ch·ªçn th·ªùi gian k·∫øt th√∫c v·ªÅ s·ªõm (v√≠ d·ª•: 16:00 thay v√¨ 16:30)\n"
        "  ‚Ä¢ **L∆∞u √Ω:**\n"
        "    - H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√≠nh s·ªë ph√∫t ƒëi tr·ªÖ/v·ªÅ s·ªõm d·ª±a tr√™n ca l√†m vi·ªác\n"
        "    - ƒê∆°n ƒëi tr·ªÖ/v·ªÅ s·ªõm s·∫Ω ƒë∆∞·ª£c ghi v√†o Google Sheet v√† tr·ª´ v√†o gi·ªù c√¥ng\n"
        "    - Ch·ªâ hi·ªÉn th·ªã dropdown **Lo·∫°i** khi ch·ªçn lo·∫°i ƒë∆°n \"ƒêi tr·ªÖ/V·ªÅ s·ªõm\"\n\n"
        "- (N·∫øu ch·ªçn \"Ngh·ªâ 30 ph√∫t\"): C√≥ quy t·∫Øc ƒê·∫∂C BI·ªÜT:\n"
        "  ‚Ä¢ **L√Ω do ngh·ªâ ph√©p:** T·ª± ƒë·ªông ƒëi·ªÅn \"Ngh·ªâ 30 ph√∫t\" (KH√îNG c·∫ßn nh·∫≠p th·ªß c√¥ng)\n"
        "  ‚Ä¢ **Ghi ch√∫:** Ph·∫ßn ghi ch√∫ s·∫Ω b·ªã ·∫©n (kh√¥ng c·∫ßn ƒëi·ªÅn)\n"
        "  ‚Ä¢ **S·ªë ng√†y ngh·ªâ:** KH√îNG c·∫ßn nh·∫≠p (ph·∫ßn n√†y s·∫Ω b·ªã ·∫©n ho·∫∑c t·ª± ƒë·ªông = 0)\n"
        "  ‚Ä¢ **QUAN TR·ªåNG:**\n"
        "    - Ph·∫£i ngh·ªâ trong C√ôNG 1 NG√ÄY (T·ª´ ng√†y = ƒê·∫øn ng√†y)\n"
        "    - Th·ªùi gian ngh·ªâ ph·∫£i CH√çNH X√ÅC 30 PH√öT (v√≠ d·ª•: 10:00 - 10:30, 14:00 - 14:30)\n"
        "    - N·∫øu kh√¥ng ƒë√∫ng, h·ªá th·ªëng s·∫Ω c·∫£nh b√°o: \"Ngh·ªâ 30 ph√∫t ph·∫£i trong c√πng 1 ng√†y\" ho·∫∑c \"Ngh·ªâ 30 ph√∫t ph·∫£i c√≥ th·ªùi gian ch√≠nh x√°c l√† 30 ph√∫t\"\n"
        "  ‚Ä¢ **V√≠ d·ª• ƒë√∫ng:**\n"
        "    - T·ª´ ng√†y: 15/01/2024, Gi·ªù: 10:00\n"
        "    - ƒê·∫øn ng√†y: 15/01/2024, Gi·ªù: 10:30\n"
        "    - K·∫øt qu·∫£: Ngh·ªâ 30 ph√∫t t·ª´ 10:00 ƒë·∫øn 10:30 trong c√πng ng√†y\n"
        "  ‚Ä¢ **V√≠ d·ª• sai (s·∫Ω b√°o l·ªói):**\n"
        "    - Ngh·ªâ 2 ng√†y kh√°c nhau ‚Üí L·ªói: \"Ngh·ªâ 30 ph√∫t ph·∫£i trong c√πng 1 ng√†y\"\n"
        "    - Ngh·ªâ 1 gi·ªù (60 ph√∫t) ‚Üí L·ªói: \"Ngh·ªâ 30 ph√∫t ph·∫£i c√≥ th·ªùi gian ch√≠nh x√°c l√† 30 ph√∫t\"\n"
        "    - Ngh·ªâ 20 ph√∫t ‚Üí L·ªói: \"Ngh·ªâ 30 ph√∫t ph·∫£i c√≥ th·ªùi gian ch√≠nh x√°c l√† 30 ph√∫t\"\n\n"
        "- **Upload ch·ª©ng t·ª´ ƒë√≠nh k√®m:** (Kh√¥ng b·∫Øt bu·ªôc, nh∆∞ng khuy·∫øn kh√≠ch)\n"
        "  ‚Ä¢ Click v√†o n√∫t **Ch·ªçn file**\n"
        "  ‚Ä¢ Ch·ªçn file t·ª´ m√°y t√≠nh (h·ªó tr·ª£: PDF, JPG, JPEG, PNG, DOC, DOCX)\n"
        "  ‚Ä¢ T·ªëi ƒëa 10MB m·ªói file, c√≥ th·ªÉ ch·ªçn nhi·ªÅu file c√πng l√∫c\n"
        "  ‚Ä¢ Sau khi ch·ªçn, file s·∫Ω hi·ªÉn th·ªã trong ph·∫ßn \"Files ƒë√£ ch·ªçn\" v·ªõi:\n"
        "    - T√™n file\n"
        "    - N√∫t **T·∫£i v·ªÅ** ƒë·ªÉ xem l·∫°i file\n"
        "    - N√∫t **X√≥a** ƒë·ªÉ x√≥a file kh·ªèi danh s√°ch\n"
        "  ‚Ä¢ **L∆∞u √Ω:**\n"
        "    - C√≥ th·ªÉ upload nhi·ªÅu file c√πng l√∫c\n"
        "    - File s·∫Ω ƒë∆∞·ª£c l∆∞u v√† g·ª≠i k√®m theo ƒë∆°n ngh·ªâ ph√©p\n"
        "    - Leader/Manager c√≥ th·ªÉ t·∫£i v·ªÅ ƒë·ªÉ xem khi ph√™ duy·ªát\n"
        "    - Ch·ª©ng t·ª´ c√≥ th·ªÉ b·ªï sung sau khi ƒë∆°n ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát\n\n"
        "- **L∆∞u √Ω v·ªÅ ch·ª©ng t·ª´:** C√≥ h·ªôp th√¥ng tin hi·ªÉn th·ªã c√°c tr∆∞·ªùng h·ª£p c·∫ßn ch·ª©ng t·ª´:\n"
        "  ‚Ä¢ **·ªêm/Con ·ªëm/Ng∆∞·ªùi nh√† ·ªëm:** Gi·∫•y x√°c nh·∫≠n b·ªánh vi·ªán (b·∫Øt bu·ªôc)\n"
        "  ‚Ä¢ **ƒê√°m c∆∞·ªõi/K·∫øt h√¥n:** Thi·ªáp m·ªùi ho·∫∑c gi·∫•y ƒëƒÉng k√Ω k·∫øt h√¥n (khuy·∫øn kh√≠ch)\n"
        "  ‚Ä¢ **Tang l·ªÖ:** Gi·∫•y ch·ª©ng t·ª≠ (b·∫Øt bu·ªôc)\n"
        "  ‚Ä¢ **Sinh con:** Gi·∫•y ch·ª©ng sinh (b·∫Øt bu·ªôc)\n"
        "  ‚Ä¢ **L∆∞u √Ω:** N·∫øu kh√¥ng c√≥ ch·ª©ng t·ª´, ƒë∆°n c√≥ th·ªÉ b·ªã t·ª´ ch·ªëi ho·∫∑c y√™u c·∫ßu b·ªï sung\n\n"
        "PH·∫¶N 4: H√¨nh th·ª©c ngh·ªâ ph√©p\n"
        "- **Ch·ªçn ca l√†m vi·ªác √°p d·ª•ng:** Ch·ªçn t·ª´ dropdown (b·∫Øt bu·ªôc, c√≥ d·∫•u *):\n"
        "  ‚Ä¢ **Ca 1** (07:30 - 16:30)\n"
        "  ‚Ä¢ **Ca 2** (09:00 - 18:00)\n"
        "  ‚Ä¢ **Ca 3** (11:00 - 20:00)\n"
        "  ‚Ä¢ **Ca 4** (08:00 - 17:00)\n"
        "- Sau khi ch·ªçn ca, **Khung gi·ªù ca** s·∫Ω hi·ªÉn th·ªã t·ª± ƒë·ªông ·ªü √¥ b√™n c·∫°nh\n"
        "- **Gi·∫£i th√≠ch:** Ca l√†m vi·ªác d√πng ƒë·ªÉ t√≠nh s·ªë ng√†y ngh·ªâ ch√≠nh x√°c theo khung gi·ªù l√†m vi·ªác\n\n"
        "- **T·ª´ ng√†y:** (B·∫Øt bu·ªôc, c√≥ d·∫•u *)\n"
        "  ‚Ä¢ Click v√†o √¥ **Ng√†y**, ch·ªçn ng√†y b·∫Øt ƒë·∫ßu ngh·ªâ t·ª´ calendar\n"
        "  ‚Ä¢ Click v√†o √¥ **Gi·ªù**, ch·ªçn ho·∫∑c nh·∫≠p gi·ªù b·∫Øt ƒë·∫ßu ngh·ªâ (v√≠ d·ª•: 08:00)\n"
        "  ‚Ä¢ **L∆∞u √Ω quan tr·ªçng:**\n"
        "    - Sau 11:59 (t·ª©c t·ª´ 12:00 tr·ªü ƒëi) ƒë∆∞·ª£c t√≠nh l√† CHI·ªÄU (chi·ªÅu h√¥m sau)\n"
        "    - C√≥ text c·∫£nh b√°o hi·ªÉn th·ªã: \"Sau 11:59 l√† CH (chi·ªÅu h√¥m sau)\"\n"
        "    - V√≠ d·ª•: N·∫øu ch·ªçn 13:00 (1 gi·ªù chi·ªÅu), h·ªá th·ªëng s·∫Ω t√≠nh l√† chi·ªÅu c·ªßa ng√†y ƒë√≥\n"
        "    - N·∫øu ngh·ªâ c·∫£ ng√†y: Ch·ªçn gi·ªù b·∫Øt ƒë·∫ßu ca (v√≠ d·ª•: Ca 1 ch·ªçn 07:30)\n\n"
        "- **ƒê·∫øn ng√†y:** (B·∫Øt bu·ªôc, c√≥ d·∫•u *)\n"
        "  ‚Ä¢ Click v√†o √¥ **Ng√†y**, ch·ªçn ng√†y k·∫øt th√∫c ngh·ªâ t·ª´ calendar\n"
        "  ‚Ä¢ Click v√†o √¥ **Gi·ªù**, ch·ªçn ho·∫∑c nh·∫≠p gi·ªù k·∫øt th√∫c ngh·ªâ\n"
        "  ‚Ä¢ **L∆∞u √Ω quan tr·ªçng:**\n"
        "    - Sau 11:59 (t·ª©c t·ª´ 12:00 tr·ªü ƒëi) ƒë∆∞·ª£c t√≠nh l√† CHI·ªÄU (chi·ªÅu h√¥m sau)\n"
        "    - C√≥ text c·∫£nh b√°o hi·ªÉn th·ªã: \"Sau 11:59 l√† CH (chi·ªÅu h√¥m sau)\"\n"
        "    - V√≠ d·ª•: N·∫øu ch·ªçn 17:00 (5 gi·ªù chi·ªÅu), h·ªá th·ªëng s·∫Ω t√≠nh l√† chi·ªÅu c·ªßa ng√†y ƒë√≥\n"
        "    - N·∫øu ngh·ªâ c·∫£ ng√†y: Ch·ªçn gi·ªù k·∫øt th√∫c ca (v√≠ d·ª•: Ca 1 ch·ªçn 16:30)\n"
        "    - **ƒê·∫øn ng√†y** ph·∫£i >= **T·ª´ ng√†y**\n\n"
        "- **S·ªë ng√†y ngh·ªâ:** (Quan tr·ªçng - ph·∫£i nh·∫≠p ƒë√∫ng, c√≥ d·∫•u *)\n"
        "  ‚Ä¢ **L∆∞u √Ω ƒë·∫∑c bi·ªát:** N·∫øu ch·ªçn \"Ngh·ªâ 30 ph√∫t\", ph·∫ßn n√†y s·∫Ω b·ªã ·∫©n ho·∫∑c t·ª± ƒë·ªông = 0 (kh√¥ng c·∫ßn nh·∫≠p)\n"
        "  ‚Ä¢ **Ngh·ªâ ph√©p nƒÉm:** Nh·∫≠p s·ªë ng√†y ngh·ªâ ph√©p nƒÉm (b·ªôi s·ªë 0.5: 0.5, 1, 1.5, 2, 2.5...)\n"
        "    - V√≠ d·ª•: 0.5 = n·ª≠a ng√†y, 1 = 1 ng√†y, 1.5 = 1.5 ng√†y, 2 = 2 ng√†y\n"
        "    - ƒê√¢y l√† s·ªë ng√†y ph√©p nƒÉm b·∫°n ƒë√£ t√≠ch l≈©y\n"
        "  ‚Ä¢ **Ngh·ªâ kh√¥ng l∆∞∆°ng:** Nh·∫≠p s·ªë ng√†y ngh·ªâ kh√¥ng l∆∞∆°ng (b·ªôi s·ªë 0.5)\n"
        "    - D√πng khi h·∫øt ph√©p nƒÉm ho·∫∑c mu·ªën ngh·ªâ kh√¥ng l∆∞∆°ng\n"
        "  ‚Ä¢ **Ngh·ªâ ƒë·∫∑c bi·ªát:** Nh·∫≠p s·ªë ng√†y ngh·ªâ ƒë·∫∑c bi·ªát (b·ªôi s·ªë 0.5)\n"
        "    - D√πng cho c√°c tr∆∞·ªùng h·ª£p: K·∫øt h√¥n, ƒê√°m tang, Sinh con...\n"
        "    - N·∫øu c√≥ dropdown **Lo·∫°i ngh·ªâ ƒë·∫∑c bi·ªát**, ch·ªçn lo·∫°i ph√π h·ª£p (v√≠ d·ª•: \"K·∫øt h√¥n\", \"ƒê√°m tang\", \"Sinh con\")\n"
        "    - **L∆∞u √Ω:** M·ªôt s·ªë lo·∫°i ngh·ªâ ƒë·∫∑c bi·ªát c√≥ th·ªÉ y√™u c·∫ßu ch·ª©ng t·ª´ (xem ph·∫ßn ch·ª©ng t·ª´ ·ªü tr√™n)\n"
        "  ‚Ä¢ (N·∫øu team Scope): **Ngh·ªâ Scope** - Nh·∫≠p s·ªë ng√†y ngh·ªâ Scope\n"
        "  ‚Ä¢ (N·∫øu team York): **Ngh·ªâ l·ªÖ Nh·∫≠t** - Nh·∫≠p s·ªë ng√†y ngh·ªâ l·ªÖ Nh·∫≠t\n"
        "  ‚Ä¢ H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√≠nh v√† hi·ªÉn th·ªã **T·ªïng** s·ªë ng√†y ·ªü √¥ b√™n ph·∫£i\n"
        "  ‚Ä¢ **QUAN TR·ªåNG:** T·ªïng s·ªë ng√†y ngh·ªâ PH·∫¢I B·∫∞NG CH√çNH X√ÅC kho·∫£ng th·ªùi gian th·ª±c t·∫ø (t√≠nh theo ca l√†m vi·ªác)\n"
        "  ‚Ä¢ **C√°ch t√≠nh s·ªë ng√†y ngh·ªâ:**\n"
        "    - N·ª≠a ng√†y s√°ng: T·ª´ ƒë·∫ßu ca ƒë·∫øn 11:59 = 0.5 ng√†y\n"
        "    - N·ª≠a ng√†y chi·ªÅu: T·ª´ 12:00 ƒë·∫øn h·∫øt ca = 0.5 ng√†y\n"
        "    - C·∫£ ng√†y: T·ª´ ƒë·∫ßu ca ƒë·∫øn h·∫øt ca = 1 ng√†y\n"
        "    - Nhi·ªÅu ng√†y: T√≠nh t·ªïng s·ªë ng√†y trong kho·∫£ng th·ªùi gian\n"
        "  ‚Ä¢ C√≥ h·ªôp c·∫£nh b√°o gi·∫£i th√≠ch c√°ch t√≠nh s·ªë ng√†y ngh·ªâ\n"
        "  ‚Ä¢ H·ªá th·ªëng s·∫Ω c·∫£nh b√°o n·∫øu s·ªë ng√†y kh√¥ng kh·ªõp v·ªõi kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn\n"
        "  ‚Ä¢ **V√≠ d·ª• c·ª• th·ªÉ:**\n"
        "    - **Ngh·ªâ s√°ng (Ca 1):** T·ª´ 07:30 ƒë·∫øn 11:59 ‚Üí Nh·∫≠p 0.5 ng√†y ngh·ªâ ph√©p nƒÉm\n"
        "    - **Ngh·ªâ chi·ªÅu (Ca 1):** T·ª´ 12:00 ƒë·∫øn 16:30 ‚Üí Nh·∫≠p 0.5 ng√†y ngh·ªâ ph√©p nƒÉm\n"
        "    - **Ngh·ªâ c·∫£ ng√†y (Ca 1):** T·ª´ 07:30 ƒë·∫øn 16:30 ‚Üí Nh·∫≠p 1 ng√†y ngh·ªâ ph√©p nƒÉm\n"
        "    - **Ngh·ªâ 2 ng√†y (Ca 1):** T·ª´ 07:30 ng√†y 1 ƒë·∫øn 16:30 ng√†y 2 ‚Üí Nh·∫≠p 2 ng√†y ngh·ªâ ph√©p nƒÉm\n"
        "    - **Ngh·ªâ 1.5 ng√†y:** Ngh·ªâ c·∫£ ng√†y 1 + s√°ng ng√†y 2 ‚Üí Nh·∫≠p 1.5 ng√†y\n"
        "    - **Ngh·ªâ nhi·ªÅu ng√†y:** ƒê·∫øm s·ªë ng√†y trong kho·∫£ng th·ªùi gian (m·ªói ng√†y = 1, m·ªói n·ª≠a ng√†y = 0.5)\n"
        "  ‚Ä¢ **L∆∞u √Ω quan tr·ªçng:**\n"
        "    - H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√≠nh v√† hi·ªÉn th·ªã s·ªë ng√†y c·∫ßn nh·∫≠p trong √¥ **T·ªïng**\n"
        "    - B·∫°n PH·∫¢I nh·∫≠p ƒë√∫ng s·ªë ng√†y hi·ªÉn th·ªã trong √¥ **T·ªïng**\n"
        "    - N·∫øu nh·∫≠p sai, h·ªá th·ªëng s·∫Ω c·∫£nh b√°o v√† kh√¥ng cho g·ª≠i ƒë∆°n\n\n"
        "PH·∫¶N 5: Ng∆∞·ªùi ƒë·∫£m tr√°ch c√¥ng vi·ªác thay th·∫ø (Kh√¥ng b·∫Øt bu·ªôc)\n"
        "- **T√™n ng∆∞·ªùi thay th·∫ø:**\n"
        "  ‚Ä¢ Click v√†o √¥ nh·∫≠p t√™n ng∆∞·ªùi thay th·∫ø\n"
        "  ‚Ä¢ Nh·∫≠p t√™n ƒë·∫ßy ƒë·ªß c·ªßa ng∆∞·ªùi s·∫Ω thay th·∫ø c√¥ng vi·ªác c·ªßa b·∫°n trong th·ªùi gian ngh·ªâ\n"
        "  ‚Ä¢ V√≠ d·ª•: \"Nguy·ªÖn VƒÉn A\", \"Tr·∫ßn Th·ªã B\"\n"
        "  ‚Ä¢ **L∆∞u √Ω:** N√™n th√¥ng b√°o tr∆∞·ªõc v·ªõi ng∆∞·ªùi thay th·∫ø\n\n"
        "- **M√£ nh√¢n vi√™n thay th·∫ø:**\n"
        "  ‚Ä¢ Click v√†o √¥ nh·∫≠p m√£ nh√¢n vi√™n thay th·∫ø\n"
        "  ‚Ä¢ Nh·∫≠p m√£ nh√¢n vi√™n c·ªßa ng∆∞·ªùi thay th·∫ø (v√≠ d·ª•: \"NV001\", \"12345\")\n"
        "  ‚Ä¢ **L∆∞u √Ω:** M√£ nh√¢n vi√™n ph·∫£i ch√≠nh x√°c ƒë·ªÉ Leader/Manager d·ªÖ li√™n h·ªá\n\n"
        "PH·∫¶N 6: Ghi ch√∫ (Kh√¥ng b·∫Øt bu·ªôc)\n"
        "- Click v√†o √¥ **Ghi ch√∫**\n"
        "- Nh·∫≠p ghi ch√∫ b·ªï sung n·∫øu c·∫ßn (v√≠ d·ª•: \"ƒê√£ b√†n giao c√¥ng vi·ªác cho anh A\", \"S·∫Ω quay l·∫°i l√†m vi·ªác v√†o ng√†y...\")\n"
        "- **L∆∞u √Ω:**\n"
        "  - Ghi ch√∫ s·∫Ω hi·ªÉn th·ªã trong ƒë∆°n ngh·ªâ ph√©p v√† email th√¥ng b√°o\n"
        "  - N·∫øu ch·ªçn \"Ngh·ªâ 30 ph√∫t\", ph·∫ßn ghi ch√∫ s·∫Ω b·ªã ·∫©n (kh√¥ng c·∫ßn ƒëi·ªÅn)\n\n"
        "B∆Ø·ªöC CU·ªêI: G·ª≠i ƒë∆°n\n"
        "3. Sau khi ƒëi·ªÅn ƒë·∫ßy ƒë·ªß t·∫•t c·∫£ th√¥ng tin, cu·ªôn xu·ªëng cu·ªëi form\n"
        "4. ·ªû cu·ªëi form c√≥ 2 n√∫t:\n"
        "   - N√∫t **H·ªßy** - Quay l·∫°i danh s√°ch ƒë∆°n\n"
        "   - N√∫t **G·ª≠i ƒë∆°n** - G·ª≠i ƒë∆°n ngh·ªâ ph√©p\n"
        "     ‚Ä¢ N·∫øu ƒëang t·∫°o ƒë∆°n m·ªõi: N√∫t hi·ªÉn th·ªã text **G·ª≠i ƒë∆°n**\n"
        "     ‚Ä¢ N·∫øu ƒëang s·ª≠a ƒë∆°n c≈©: N√∫t hi·ªÉn th·ªã text **C·∫≠p nh·∫≠t**\n"
        "5. Click n√∫t **G·ª≠i ƒë∆°n** (ho·∫∑c **C·∫≠p nh·∫≠t** n·∫øu ƒëang s·ª≠a) ƒë·ªÉ g·ª≠i ƒë∆°n\n"
        "6. H·ªá th·ªëng s·∫Ω ki·ªÉm tra validation:\n"
        "   - N·∫øu s·ªë ng√†y ngh·ªâ kh√¥ng kh·ªõp v·ªõi kho·∫£ng th·ªùi gian, s·∫Ω c√≥ c·∫£nh b√°o\n"
        "   - Ph·∫£i s·ª≠a l·∫°i cho ƒë√∫ng m·ªõi g·ª≠i ƒë∆∞·ª£c\n"
        "7. Sau khi validation th√†nh c√¥ng, s·∫Ω hi·ªÉn th·ªã popup x√°c nh·∫≠n g·ª≠i email:\n"
        "   - Ch·ªçn **C√≥, g·ª≠i email** n·∫øu mu·ªën g·ª≠i email th√¥ng b√°o\n"
        "   - Ch·ªçn **Kh√¥ng, kh√¥ng g·ª≠i email** n·∫øu kh√¥ng mu·ªën g·ª≠i\n"
        "8. ƒê∆°n s·∫Ω ƒë∆∞·ª£c g·ª≠i v√† chuy·ªÉn sang tr·∫°ng th√°i **pending** (ch·ªù Leader ph√™ duy·ªát)\n\n"
        "**L∆∞u √Ω quan tr·ªçng:**\n"
        "- **Ngh·ªâ ph√©p th√¥ng th∆∞·ªùng:**\n"
        "  ‚Ä¢ S·ªë ng√†y ngh·ªâ PH·∫¢I l√† b·ªôi s·ªë c·ªßa 0.5 (0.5 = n·ª≠a ng√†y, 1 = 1 ng√†y, 1.5 = 1.5 ng√†y, 2 = 2 ng√†y...)\n"
        "  ‚Ä¢ T·ªïng s·ªë ng√†y ngh·ªâ PH·∫¢I B·∫∞NG CH√çNH X√ÅC kho·∫£ng th·ªùi gian th·ª±c t·∫ø t√≠nh theo ca l√†m vi·ªác\n"
        "- **ƒêi tr·ªÖ/V·ªÅ s·ªõm:**\n"
        "  ‚Ä¢ KH√îNG c·∫ßn nh·∫≠p s·ªë ng√†y ngh·ªâ (t·ª± ƒë·ªông = 0)\n"
        "  ‚Ä¢ Ch·ªâ c·∫ßn ch·ªçn th·ªùi gian ƒëi tr·ªÖ/v·ªÅ s·ªõm\n"
        "  ‚Ä¢ H·ªá th·ªëng t·ª± ƒë·ªông t√≠nh s·ªë ph√∫t v√† tr·ª´ v√†o gi·ªù c√¥ng\n"
        "- **Ngh·ªâ 30 ph√∫t:**\n"
        "  ‚Ä¢ KH√îNG c·∫ßn nh·∫≠p s·ªë ng√†y ngh·ªâ (t·ª± ƒë·ªông = 0)\n"
        "  ‚Ä¢ Ph·∫£i trong c√πng 1 ng√†y v√† ch√≠nh x√°c 30 ph√∫t\n"
        "  ‚Ä¢ L√Ω do t·ª± ƒë·ªông ƒëi·ªÅn \"Ngh·ªâ 30 ph√∫t\"\n"
        "- **Chung:**\n"
        "  ‚Ä¢ N·∫øu ƒëang s·ª≠a ƒë∆°n c≈©, n√∫t s·∫Ω hi·ªÉn th·ªã **C·∫≠p nh·∫≠t** thay v√¨ **G·ª≠i ƒë∆°n**\n"
        "  ‚Ä¢ File ƒë√≠nh k√®m: PDF, JPG, JPEG, PNG, DOC, DOCX, t·ªëi ƒëa 10MB m·ªói file\n"
        "  ‚Ä¢ C√≥ th·ªÉ ƒë√≠nh k√®m nhi·ªÅu file c√πng l√∫c (multiple)\n"
        "  ‚Ä¢ Ch·ª©ng t·ª´ c√≥ th·ªÉ b·ªï sung sau khi ƒë∆°n ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát\n\n"
        "=== 2. THEO D√ïI T√åNH TR·∫†NG ƒê∆†N NGH·ªà PH√âP ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o menu **Theo d√µi t√¨nh tr·∫°ng** ·ªü sidebar b√™n tr√°i\n"
        "2. Trang s·∫Ω hi·ªÉn th·ªã b·∫£ng danh s√°ch ƒë∆°n ngh·ªâ ph√©p v·ªõi c√°c c·ªôt:\n"
        "   - T√™n/M√£ nh√¢n vi√™n\n"
        "   - Lo·∫°i ƒë∆°n\n"
        "   - Ng√†y b·∫Øt ƒë·∫ßu - K·∫øt th√∫c\n"
        "   - S·ªë ng√†y ngh·ªâ\n"
        "   - Tr·∫°ng th√°i\n"
        "   - H√†nh ƒë·ªông\n"
        "3. S·ª≠ d·ª•ng c√°c b·ªô l·ªçc ·ªü tr√™n b·∫£ng:\n"
        "   - **T√¨m ki·∫øm:** Nh·∫≠p t√™n ho·∫∑c m√£ nh√¢n vi√™n v√†o √¥ t√¨m ki·∫øm\n"
        "   - **Ph√≤ng ban:** (Ch·ªâ Admin) Ch·ªçn ph√≤ng ban t·ª´ dropdown\n"
        "   - **Lo·∫°i ƒë∆°n:** Ch·ªçn lo·∫°i ƒë∆°n t·ª´ dropdown (ngh·ªâ ph√©p, ƒëi tr·ªÖ/v·ªÅ s·ªõm, ngh·ªâ 30 ph√∫t)\n"
        "   - **Tr·∫°ng th√°i:** Ch·ªçn tr·∫°ng th√°i t·ª´ dropdown:\n"
        "     ‚Ä¢ **pending** - Ch·ªù Leader ph√™ duy·ªát\n"
        "     ‚Ä¢ **pending_manager** - Ch·ªù Manager ph√™ duy·ªát\n"
        "     ‚Ä¢ **pending_admin** - Ch·ªù Admin ph√™ duy·ªát\n"
        "     ‚Ä¢ **approved** - ƒê√£ ƒë∆∞·ª£c ph√™ duy·ªát\n"
        "     ‚Ä¢ **rejected** - ƒê√£ b·ªã t·ª´ ch·ªëi\n"
        "   - **T·ª´ ng√†y / ƒê·∫øn ng√†y:** Ch·ªçn kho·∫£ng th·ªùi gian ƒë·ªÉ l·ªçc\n"
        "4. Click n√∫t **√Åp d·ª•ng b·ªô l·ªçc** ƒë·ªÉ l·ªçc k·∫øt qu·∫£\n"
        "5. Trong c·ªôt **H√†nh ƒë·ªông**, b·∫°n c√≥ th·ªÉ:\n"
        "   - Click icon **m·∫Øt** (üëÅÔ∏è) ƒë·ªÉ xem chi ti·∫øt ƒë∆°n\n"
        "   - Click icon **t·∫£i xu·ªëng** (‚¨áÔ∏è) ƒë·ªÉ t·∫£i file ƒë√≠nh k√®m\n"
        "   - Click **Ph√™ duy·ªát** (n·∫øu c√≥ quy·ªÅn) ƒë·ªÉ ph√™ duy·ªát ƒë∆°n\n"
        "   - Click **T·ª´ ch·ªëi** (n·∫øu c√≥ quy·ªÅn) ƒë·ªÉ t·ª´ ch·ªëi ƒë∆°n\n"
        "   - Click **X√≥a** (n·∫øu ƒë∆°n c√≤n ·ªü tr·∫°ng th√°i ch·ªù v√† b·∫°n c√≥ quy·ªÅn) ƒë·ªÉ x√≥a ƒë∆°n\n\n"
        "**L∆∞u √Ω:**\n"
        "- B·∫£ng c√≥ c·ªôt d√≠nh (sticky), c√°c c·ªôt quan tr·ªçng s·∫Ω lu√¥n hi·ªÉn th·ªã khi cu·ªôn\n"
        "- Ch·ªâ Leader/Manager/Admin m·ªõi c√≥ quy·ªÅn ph√™ duy·ªát/t·ª´ ch·ªëi ƒë∆°n\n"
        "- Ch·ªâ ng∆∞·ªùi t·∫°o ƒë∆°n ho·∫∑c Admin m·ªõi c√≥ quy·ªÅn x√≥a ƒë∆°n khi ƒë∆°n c√≤n ·ªü tr·∫°ng th√°i ch·ªù\n\n"
        "=== 2A. XEM CHI TI·∫æT ƒê∆†N NGH·ªà PH√âP ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Theo d√µi t√¨nh tr·∫°ng** ho·∫∑c **L·ªãch s·ª≠ ngh·ªâ ph√©p** ‚Üí T√¨m ƒë∆°n ngh·ªâ ph√©p c·∫ßn xem\n"
        "2. Click icon **m·∫Øt** (üëÅÔ∏è) ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "3. Trang chi ti·∫øt s·∫Ω hi·ªÉn th·ªã:\n"
        "   - **Th√¥ng tin nh√¢n vi√™n:** T√™n, M√£ NV, Ph√≤ng ban\n"
        "   - **Th√¥ng tin ƒë∆°n ngh·ªâ ph√©p:**\n"
        "     ‚Ä¢ Lo·∫°i ƒë∆°n (Ngh·ªâ ph√©p, ƒêi tr·ªÖ/V·ªÅ s·ªõm, Ngh·ªâ 30 ph√∫t)\n"
        "     ‚Ä¢ L√Ω do ngh·ªâ ph√©p\n"
        "     ‚Ä¢ Ca l√†m vi·ªác √°p d·ª•ng\n"
        "     ‚Ä¢ T·ª´ ng√†y - ƒê·∫øn ng√†y (c·∫£ ng√†y v√† gi·ªù)\n"
        "     ‚Ä¢ S·ªë ng√†y ngh·ªâ (chi ti·∫øt: Ngh·ªâ ph√©p nƒÉm, Ngh·ªâ kh√¥ng l∆∞∆°ng, Ngh·ªâ ƒë·∫∑c bi·ªát, Ngh·ªâ Scope, Ngh·ªâ l·ªÖ Nh·∫≠t)\n"
        "     ‚Ä¢ T·ªïng s·ªë ng√†y ngh·ªâ\n"
        "     ‚Ä¢ Ng∆∞·ªùi thay th·∫ø (t√™n v√† m√£ nh√¢n vi√™n, n·∫øu c√≥)\n"
        "     ‚Ä¢ Ghi ch√∫ (n·∫øu c√≥)\n"
        "   - **File ƒë√≠nh k√®m:**\n"
        "     ‚Ä¢ Danh s√°ch t·∫•t c·∫£ file ƒë√≠nh k√®m\n"
        "     ‚Ä¢ Click t√™n file ƒë·ªÉ t·∫£i xu·ªëng t·ª´ng file\n"
        "     ‚Ä¢ N√∫t **T·∫£i t·∫•t c·∫£** ƒë·ªÉ t·∫£i t·∫•t c·∫£ file d∆∞·ªõi d·∫°ng ZIP\n"
        "   - **Th√¥ng tin ph√™ duy·ªát:**\n"
        "     ‚Ä¢ Tr·∫°ng th√°i (Ch·ªù ph√™ duy·ªát, ƒê√£ ph√™ duy·ªát, T·ª´ ch·ªëi)\n"
        "     ‚Ä¢ Ng∆∞·ªùi ph√™ duy·ªát (Leader, Manager, Admin)\n"
        "     ‚Ä¢ Ng√†y ph√™ duy·ªát\n"
        "     ‚Ä¢ Nh·∫≠n x√©t/L√Ω do t·ª´ ch·ªëi (n·∫øu c√≥)\n"
        "   - **C√°c n√∫t h√†nh ƒë·ªông:**\n"
        "     ‚Ä¢ **S·ª≠a ƒë∆°n** (n·∫øu ƒë∆°n ·ªü tr·∫°ng th√°i pending ho·∫∑c rejected v√† b·∫°n c√≥ quy·ªÅn)\n"
        "     ‚Ä¢ **Ph√™ duy·ªát** (n·∫øu c√≥ quy·ªÅn v√† ƒë∆°n ƒëang ch·ªù ph√™ duy·ªát)\n"
        "     ‚Ä¢ **T·ª´ ch·ªëi** (n·∫øu c√≥ quy·ªÅn v√† ƒë∆°n ƒëang ch·ªù ph√™ duy·ªát)\n"
        "     ‚Ä¢ **X√≥a** (n·∫øu ƒë∆°n ·ªü tr·∫°ng th√°i pending ho·∫∑c rejected v√† b·∫°n c√≥ quy·ªÅn)\n\n"
        "**L∆∞u √Ω:**\n"
        "- T·∫•t c·∫£ th√¥ng tin chi ti·∫øt ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß trong trang n√†y\n"
        "- C√≥ th·ªÉ scroll ƒë·ªÉ xem t·∫•t c·∫£ th√¥ng tin\n"
        "- File ƒë√≠nh k√®m c√≥ th·ªÉ xem tr·ª±c ti·∫øp ho·∫∑c t·∫£i xu·ªëng\n"
        "- C√°c n√∫t h√†nh ƒë·ªông s·∫Ω hi·ªÉn th·ªã/·∫©n t√πy theo quy·ªÅn v√† tr·∫°ng th√°i c·ªßa ƒë∆°n\n\n"
        "=== 11. X√ìA ƒê∆†N NGH·ªà PH√âP ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Theo d√µi t√¨nh tr·∫°ng** ‚Üí T√¨m ƒë∆°n ngh·ªâ ph√©p c·∫ßn x√≥a\n"
        "2. T√¨m ƒë∆°n c√≥ tr·∫°ng th√°i **pending** ho·∫∑c **rejected**\n"
        "3. Click icon **th√πng r√°c** (üóëÔ∏è) ho·∫∑c n√∫t **X√≥a** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "4. **L∆∞u √Ω:** Ch·ªâ x√≥a ƒë∆∞·ª£c khi:\n"
        "   - ƒê∆°n c√≤n ·ªü tr·∫°ng th√°i **pending** ho·∫∑c **rejected** (ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát)\n"
        "   - B·∫°n l√† ng∆∞·ªùi t·∫°o ƒë∆°n ho·∫∑c c√≥ quy·ªÅn Admin\n"
        "5. H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã popup x√°c nh·∫≠n x√≥a\n"
        "6. Click **X√°c nh·∫≠n** ƒë·ªÉ x√≥a ho·∫∑c **H·ªßy** ƒë·ªÉ h·ªßy b·ªè\n"
        "7. Sau khi x√≥a, ƒë∆°n s·∫Ω bi·∫øn m·∫•t kh·ªèi danh s√°ch\n\n"
        "**L∆∞u √Ω:**\n"
        "- Kh√¥ng th·ªÉ x√≥a ƒë∆°n ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát (tr·∫°ng th√°i **approved**)\n"
        "- H√†nh ƒë·ªông x√≥a kh√¥ng th·ªÉ ho√†n t√°c, c·∫ßn c·∫©n th·∫≠n\n"
        "- File ƒë√≠nh k√®m c≈©ng s·∫Ω b·ªã x√≥a theo ƒë∆°n\n\n"
        "=== 3. L·ªäCH S·ª¨ NGH·ªà PH√âP ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o menu **L·ªãch s·ª≠ ngh·ªâ ph√©p** ·ªü sidebar b√™n tr√°i\n"
        "2. Trang s·∫Ω hi·ªÉn th·ªã b·∫£ng l·ªãch s·ª≠ t·∫•t c·∫£ c√°c ƒë∆°n ngh·ªâ ph√©p ƒë√£ x·ª≠ l√Ω\n"
        "3. S·ª≠ d·ª•ng c√°c b·ªô l·ªçc t∆∞∆°ng t·ª± nh∆∞ **Theo d√µi t√¨nh tr·∫°ng**:\n"
        "   - T√¨m ki·∫øm theo t√™n/m√£ nh√¢n vi√™n\n"
        "   - L·ªçc theo ph√≤ng ban (ch·ªâ Admin)\n"
        "   - L·ªçc theo lo·∫°i ƒë∆°n\n"
        "   - L·ªçc theo tr·∫°ng th√°i\n"
        "   - L·ªçc theo kho·∫£ng th·ªùi gian (T·ª´ ng√†y - ƒê·∫øn ng√†y)\n"
        "4. Click **√Åp d·ª•ng b·ªô l·ªçc** ƒë·ªÉ xem k·∫øt qu·∫£\n"
        "5. (Ch·ªâ Admin) Click n√∫t **T·∫£i Excel** ƒë·ªÉ xu·∫•t d·ªØ li·ªáu ra file Excel\n\n"
        "=== 4. ƒê·ªîI M·∫¨T KH·∫®U ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o **t√™n ng∆∞·ªùi d√πng** c·ªßa b·∫°n ·ªü g√≥c tr√™n b√™n ph·∫£i m√†n h√¨nh\n"
        "2. Trong menu dropdown hi·ªán ra, click **C√†i ƒë·∫∑t**\n"
        "3. Trong trang C√†i ƒë·∫∑t, t√¨m ph·∫ßn **ƒê·ªïi m·∫≠t kh·∫©u**\n"
        "4. ƒêi·ªÅn c√°c th√¥ng tin:\n"
        "   - **M·∫≠t kh·∫©u hi·ªán t·∫°i:** Nh·∫≠p m·∫≠t kh·∫©u b·∫°n ƒëang d√πng\n"
        "   - **M·∫≠t kh·∫©u m·ªõi:** Nh·∫≠p m·∫≠t kh·∫©u m·ªõi (t·ªëi thi·ªÉu 6 k√Ω t·ª±)\n"
        "   - **Nh·∫≠p l·∫°i m·∫≠t kh·∫©u m·ªõi:** Nh·∫≠p l·∫°i m·∫≠t kh·∫©u m·ªõi ƒë·ªÉ x√°c nh·∫≠n\n"
        "5. Click n√∫t **C·∫≠p nh·∫≠t m·∫≠t kh·∫©u** (m√†u xanh) ƒë·ªÉ l∆∞u\n"
        "6. H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng n·∫øu ƒë·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng\n\n"
        "**L∆∞u √Ω:**\n"
        "- M·∫≠t kh·∫©u m·ªõi ph·∫£i kh√°c m·∫≠t kh·∫©u c≈©\n"
        "- M·∫≠t kh·∫©u m·ªõi ph·∫£i c√≥ ƒë·ªô d√†i t·ªëi thi·ªÉu 6 k√Ω t·ª±\n"
        "- Hai √¥ m·∫≠t kh·∫©u m·ªõi ph·∫£i gi·ªëng nhau\n\n"
        "=== 5. QU·∫¢N L√ù CH·ªÆ K√ù ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o **t√™n ng∆∞·ªùi d√πng** c·ªßa b·∫°n ·ªü g√≥c tr√™n b√™n ph·∫£i m√†n h√¨nh\n"
        "2. Trong menu dropdown hi·ªán ra, click **C√†i ƒë·∫∑t**\n"
        "3. Trong trang C√†i ƒë·∫∑t, cu·ªôn xu·ªëng t√¨m ph·∫ßn **Ch·ªØ k√Ω c√° nh√¢n** (c√≥ header m√†u t√≠m gradient)\n"
        "4. B·∫°n s·∫Ω th·∫•y 2 tab: **V·∫Ω ch·ªØ k√Ω** v√† **Upload ·∫£nh**\n\n"
        "C√ÅCH 1: V·∫Ω ch·ªØ k√Ω (Tab \"V·∫Ω ch·ªØ k√Ω\" - tab m·∫∑c ƒë·ªãnh)\n"
        "- Tab n√†y ƒë√£ ƒë∆∞·ª£c ch·ªçn s·∫µn\n"
        "- B·∫°n s·∫Ω th·∫•y m·ªôt v√πng v·∫Ω ch·ªØ k√Ω\n"
        "   - Click v√†o v√πng canvas v√† d√πng chu·ªôt/touchpad ƒë·ªÉ v·∫Ω ch·ªØ k√Ω c·ªßa b·∫°n\n"
        "   - Sau khi v·∫Ω xong, ch·ªØ k√Ω s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c l∆∞u v√†o bi·∫øn\n"
        "   - N·∫øu mu·ªën v·∫Ω l·∫°i, click n√∫t **X√≥a ch·ªØ k√Ω** (m√†u x√°m, c√≥ icon eraser)\n\n"
        "C√ÅCH 2: Upload ·∫£nh ch·ªØ k√Ω (Tab \"Upload ·∫£nh\")\n"
        "- Click v√†o tab **Upload ·∫£nh**\n"
        "- Click n√∫t **Ch·ªçn ·∫£nh ch·ªØ k√Ω**\n"
        "   - Ch·ªçn file ·∫£nh t·ª´ m√°y t√≠nh (h·ªó tr·ª£: JPG, PNG, GIF, JFIF)\n"
        "   - ·∫¢nh g·ªëc s·∫Ω hi·ªÉn th·ªã trong ph·∫ßn **·∫¢nh g·ªëc:**\n"
        "   - H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông x·ª≠ l√Ω v√† hi·ªÉn th·ªã **Ch·ªØ k√Ω ƒë√£ x·ª≠ l√Ω** b√™n d∆∞·ªõi\n"
        "   - B·∫°n c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh x·ª≠ l√Ω b·∫±ng 3 thanh tr∆∞·ª£t:\n"
        "     ‚Ä¢ **Ng∆∞·ª°ng ƒë·ªô s√°ng:** K√©o thanh tr∆∞·ª£t (0-250, m·∫∑c ƒë·ªãnh 125)\n"
        "     ‚Ä¢ **Ng∆∞·ª°ng t∆∞∆°ng ph·∫£n:** K√©o thanh tr∆∞·ª£t (10-50, m·∫∑c ƒë·ªãnh 25)\n"
        "     ‚Ä¢ **ƒê·ªô ƒë·∫≠m ch·ªØ k√Ω:** K√©o thanh tr∆∞·ª£t (20-100, m·∫∑c ƒë·ªãnh 50)\n"
        "   - Khi k√©o thanh tr∆∞·ª£t, ·∫£nh s·∫Ω t·ª± ƒë·ªông x·ª≠ l√Ω l·∫°i v√† hi·ªÉn th·ªã ngay\n"
        "   - Sau khi h√†i l√≤ng v·ªõi ch·ªØ k√Ω ƒë√£ x·ª≠ l√Ω, click n√∫t **√Åp d·ª•ng ch·ªØ k√Ω n√†y**\n"
        "   - N·∫øu kh√¥ng mu·ªën d√πng, click n√∫t **H·ªßy**\n\n"
        "L∆ØU CH·ªÆ K√ù:\n"
        "5. Sau khi c√≥ ch·ªØ k√Ω (v·∫Ω ho·∫∑c upload), cu·ªôn xu·ªëng cu·ªëi ph·∫ßn Ch·ªØ k√Ω c√° nh√¢n\n"
        "6. Click n√∫t **L∆∞u ch·ªØ k√Ω** ·ªü cu·ªëi ph·∫ßn Ch·ªØ k√Ω c√° nh√¢n\n"
        "7. H·ªá th·ªëng s·∫Ω l∆∞u ch·ªØ k√Ω v√† hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng\n"
        "8. Ch·ªØ k√Ω s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng t·ª± ƒë·ªông khi b·∫°n ƒëƒÉng k√Ω ch·∫•m c√¥ng ho·∫∑c ph√™ duy·ªát c√°c b·∫£n ghi\n\n"
        "KI·ªÇM TRA CH·ªÆ K√ù:\n"
        "9. B·∫°n c√≥ th·ªÉ click n√∫t **Ki·ªÉm tra ch·ªØ k√Ω tr√™n phi·∫øu tƒÉng ca** ƒë·ªÉ xem ch·ªØ k√Ω s·∫Ω hi·ªÉn th·ªã nh∆∞ th·∫ø n√†o tr√™n PDF\n\n"
        "**L∆∞u √Ω:**\n"
        "- Ch·ªØ k√Ω ch·ªâ c·∫ßn t·∫°o m·ªôt l·∫ßn, s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng cho t·∫•t c·∫£ c√°c l·∫ßn sau\n"
        "- C√≥ th·ªÉ c·∫≠p nh·∫≠t ch·ªØ k√Ω b·∫•t c·ª© l√∫c n√†o b·∫±ng c√°ch v·∫Ω l·∫°i ho·∫∑c upload ·∫£nh m·ªõi\n"
        "- Khi upload ·∫£nh, h·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√°ch ch·ªØ k√Ω v√† ƒëi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc\n\n"
        "=== 6. ƒêƒÇNG K√ù CH·∫§M C√îNG (Tr√™n Dashboard) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o menu **Trang ch·ªß** ho·∫∑c **Dashboard** ·ªü sidebar b√™n tr√°i\n"
        "2. Trong trang Dashboard, b·∫°n s·∫Ω th·∫•y form ch·∫•m c√¥ng ·ªü ph·∫ßn tr√™n (c√≥ n·ªÅn tr·∫Øng, vi·ªÅn xanh)\n"
        "3. ƒêi·ªÅn c√°c th√¥ng tin CHI TI·∫æT t·ª´ng tr∆∞·ªùng:\n\n"
        "TR∆Ø·ªúNG 1: Ng√†y ch·∫•m c√¥ng (B·∫Øt bu·ªôc, c√≥ d·∫•u *)\n"
        "- Click v√†o √¥ **Ng√†y**\n"
        "- Ch·ªçn ng√†y t·ª´ calendar (ch·ªâ ƒë∆∞·ª£c ch·ªçn ng√†y trong qu√° kh·ª© ho·∫∑c h√¥m nay, KH√îNG ƒë∆∞·ª£c ch·ªçn ng√†y t∆∞∆°ng lai)\n"
        "- **L∆∞u √Ω:** Kh√¥ng th·ªÉ ch·∫•m c√¥ng cho ng√†y trong t∆∞∆°ng lai\n\n"
        "**TR∆Ø·ªúNG 2: Lo·∫°i ng√†y** (B·∫Øt bu·ªôc, c√≥ d·∫•u *)\n"
        "   - Click v√†o dropdown **Lo·∫°i ng√†y**\n"
        "   - Ch·ªçn m·ªôt trong c√°c lo·∫°i:\n"
        "     ‚Ä¢ **Ng√†y th∆∞·ªùng** - Ng√†y l√†m vi·ªác b√¨nh th∆∞·ªùng\n"
        "     ‚Ä¢ **Cu·ªëi tu·∫ßn** - Th·ª© 7, Ch·ªß nh·∫≠t\n"
        "     ‚Ä¢ **L·ªÖ Vi·ªát Nam** - Ng√†y l·ªÖ Vi·ªát Nam (c√≥ th·ªÉ kh√¥ng ƒëi l√†m, v·∫´n ƒë∆∞·ª£c 8h c√¥ng)\n"
        "     ‚Ä¢ **L·ªÖ Nh·∫≠t B·∫£n** - Ng√†y l·ªÖ Nh·∫≠t B·∫£n\n"
        "   - **L∆∞u √Ω:**\n"
        "     - N·∫øu ch·ªçn **L·ªÖ Vi·ªát Nam** v√† kh√¥ng ƒëi l√†m: KH√îNG c·∫ßn nh·∫≠p gi·ªù v√†o/ra, h·ªá th·ªëng t·ª± ƒë·ªông cho 8h c√¥ng\n"
        "     - N·∫øu ch·ªçn **L·ªÖ Vi·ªát Nam** v√† c√≥ ƒëi l√†m: Ph·∫£i nh·∫≠p ƒë·∫ßy ƒë·ªß gi·ªù v√†o/ra\n"
        "     - **Cu·ªëi tu·∫ßn:** T·∫•t c·∫£ th·ªùi gian l√†m vi·ªác t√≠nh v√†o tƒÉng ca (kh√¥ng c√≥ gi·ªù c√¥ng th∆∞·ªùng)\n"
        "     - **L·ªÖ Nh·∫≠t:** T√≠nh gi·ªù c√¥ng th∆∞·ªùng v√† tƒÉng ca nh∆∞ ng√†y th∆∞·ªùng\n\n"
        "**TR∆Ø·ªúNG 3: Ca l√†m vi·ªác** (B·∫Øt bu·ªôc n·∫øu kh√¥ng ph·∫£i L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m, c√≥ d·∫•u *)\n"
        "   - Click v√†o dropdown **Ca l√†m vi·ªác**\n"
        "   - Ch·ªçn m·ªôt trong c√°c ca:\n"
        "     ‚Ä¢ **Ca 1** - 07:30 ƒë·∫øn 16:30\n"
        "     ‚Ä¢ **Ca 2** - 09:00 ƒë·∫øn 18:00\n"
        "     ‚Ä¢ **Ca 3** - 11:00 ƒë·∫øn 20:00\n"
        "     ‚Ä¢ **Ca 4** - 08:00 ƒë·∫øn 17:00\n"
        "     ‚Ä¢ **Ca 5** - Ca t·ª± do (cho ng√†y ngh·ªâ, kh√¥ng c√≥ gi·ªù c·ªë ƒë·ªãnh)\n"
        "   - Sau khi ch·ªçn ca, **Gi·ªù v√†o ca** v√† **Gi·ªù ra ca** s·∫Ω t·ª± ƒë·ªông hi·ªÉn th·ªã\n"
        "   - **L∆∞u √Ω:**\n"
        "     - N·∫øu ch·ªçn **L·ªÖ Vi·ªát Nam** v√† kh√¥ng ƒëi l√†m: KH√îNG c·∫ßn ch·ªçn ca\n"
        "     - **Ca 5** ch·ªâ d√πng cho ng√†y ngh·ªâ, cho ph√©p gi·ªù v√†o/ra linh ho·∫°t\n\n"
        "TR∆Ø·ªúNG 4: Gi·ªù v√†o (B·∫Øt bu·ªôc tr·ª´ L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m, c√≥ d·∫•u *)\n"
        "- Click v√†o √¥ **Gi·ªù v√†o**\n"
        "   - Nh·∫≠p ho·∫∑c ch·ªçn gi·ªù v√†o th·ª±c t·∫ø (v√≠ d·ª•: 08:00, 09:15)\n"
        "   - **L∆∞u √Ω:**\n"
        "     - Ph·∫£i nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng HH:MM (24 gi·ªù)\n"
        "     - N·∫øu tƒÉng ca qua ƒë√™m, c√≥ th·ªÉ nh·∫≠p gi·ªù v√†o ng√†y h√¥m tr∆∞·ªõc\n"
        "     - N·∫øu ch·ªçn **L·ªÖ Vi·ªát Nam** v√† kh√¥ng ƒëi l√†m: KH√îNG c·∫ßn nh·∫≠p\n\n"
        "TR∆Ø·ªúNG 5: Gi·ªù ra (B·∫Øt bu·ªôc tr·ª´ L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m, c√≥ d·∫•u *)\n"
        "- Click v√†o √¥ **Gi·ªù ra**\n"
        "   - Nh·∫≠p ho·∫∑c ch·ªçn gi·ªù ra th·ª±c t·∫ø (v√≠ d·ª•: 17:30, 20:45)\n"
        "   - **L∆∞u √Ω:**\n"
        "     - Ph·∫£i nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng HH:MM (24 gi·ªù)\n"
        "     - N·∫øu tƒÉng ca qua ƒë√™m (gi·ªù ra sau 00:00):\n"
        "       ‚Ä¢ T√¨m toggle **TƒÉng ca qua ng√†y m·ªõi** (c√≥ icon m·∫∑t trƒÉng üåô, ·ªü g√≥c tr√™n b√™n ph·∫£i c·ªßa √¥ gi·ªù ra)\n"
        "       ‚Ä¢ Click v√†o toggle ƒë·ªÉ B·∫¨T (toggle s·∫Ω chuy·ªÉn sang m√†u ƒë·ªè, icon m·∫∑t trƒÉng s·∫Ω s√°ng)\n"
        "       ‚Ä¢ Sau khi b·∫≠t toggle, nh·∫≠p gi·ªù ra c·ªßa ng√†y h√¥m sau v√†o √¥ **Gi·ªù ra** (v√≠ d·ª•: 01:30, 02:15)\n"
        "       ‚Ä¢ H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√≠nh ƒë√∫ng th·ªùi gian l√†m vi·ªác (t·ª´ gi·ªù v√†o ng√†y h√¥m tr∆∞·ªõc ƒë·∫øn gi·ªù ra ng√†y h√¥m sau)\n"
        "       ‚Ä¢ **V√≠ d·ª•:**\n"
        "         - Gi·ªù v√†o: 20:00 (ng√†y 1)\n"
        "         - B·∫≠t toggle \"TƒÉng ca qua ng√†y m·ªõi\"\n"
        "         - Gi·ªù ra: 02:00 (ng√†y 2)\n"
        "         - H·ªá th·ªëng s·∫Ω t√≠nh: 6 gi·ªù l√†m vi·ªác (t·ª´ 20:00 ng√†y 1 ƒë·∫øn 02:00 ng√†y 2)\n"
        "       ‚Ä¢ **L∆∞u √Ω:** T·∫Øt toggle n·∫øu gi·ªù ra c√πng ng√†y v·ªõi gi·ªù v√†o\n"
        "     - N·∫øu ch·ªçn **L·ªÖ Vi·ªát Nam** v√† kh√¥ng ƒëi l√†m: KH√îNG c·∫ßn nh·∫≠p\n\n"
        "TR∆Ø·ªúNG 6: Th·ªùi gian ngh·ªâ (B·∫Øt bu·ªôc, c√≥ d·∫•u *)\n"
        "- Click v√†o √¥ **Th·ªùi gian ngh·ªâ**\n"
        "   - Nh·∫≠p th·ªùi gian ngh·ªâ tr∆∞a/gi·∫£i lao (v√≠ d·ª•: 01:00 = 1 gi·ªù, 00:30 = 30 ph√∫t)\n"
        "   - **L∆∞u √Ω:**\n"
        "     - M·∫∑c ƒë·ªãnh: **01:00** (1 gi·ªù) cho ng√†y th∆∞·ªùng\n"
        "     - **L·ªÖ Vi·ªát Nam** kh√¥ng ƒëi l√†m: **00:00** (kh√¥ng c√≥ th·ªùi gian ngh·ªâ)\n"
        "     - **Cu·ªëi tu·∫ßn v√† L·ªÖ Vi·ªát Nam c√≥ ƒëi l√†m:** **01:00** (1 gi·ªù)\n"
        "     - Th·ªùi gian ngh·ªâ s·∫Ω ƒë∆∞·ª£c tr·ª´ v√†o t·ªïng gi·ªù l√†m vi·ªác\n\n"
        "TR∆Ø·ªúNG 7: Gi·ªù ƒë·ªëi ·ª©ng trong ca (Kh√¥ng b·∫Øt bu·ªôc, m·∫∑c ƒë·ªãnh 00:00)\n"
        "- Click v√†o √¥ **Gi·ªù ƒë·ªëi ·ª©ng trong ca**\n"
        "   - Nh·∫≠p s·ªë gi·ªù ƒë·ªëi ·ª©ng ƒë√£ d√πng trong ca l√†m vi·ªác (v√≠ d·ª•: 02:00 = 2 gi·ªù)\n"
        "   - **Gi·∫£i th√≠ch:** ƒê√¢y l√† gi·ªù ƒë·ªëi ·ª©ng (comp time) ƒë√£ s·ª≠ d·ª•ng trong ca l√†m vi·ªác ch√≠nh\n"
        "   - **L∆∞u √Ω:**\n"
        "     - Ch·ªâ √°p d·ª•ng cho **Ng√†y th∆∞·ªùng** v√† **L·ªÖ Nh·∫≠t**\n"
        "     - **Cu·ªëi tu·∫ßn** v√† **L·ªÖ Vi·ªát Nam:** KH√îNG tr·ª´ ƒë·ªëi ·ª©ng trong ca\n"
        "     - Gi·ªù ƒë·ªëi ·ª©ng s·∫Ω ƒë∆∞·ª£c tr·ª´ v√†o gi·ªù c√¥ng th∆∞·ªùng\n"
        "     - M·∫∑c ƒë·ªãnh: **00:00** (kh√¥ng c√≥ ƒë·ªëi ·ª©ng)\n\n"
        "TR∆Ø·ªúNG 8: Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca (Kh√¥ng b·∫Øt bu·ªôc, m·∫∑c ƒë·ªãnh 00:00)\n"
        "- Click v√†o √¥ **Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca**\n"
        "   - Nh·∫≠p t·ªïng s·ªë gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca ƒë√£ d√πng (v√≠ d·ª•: 01:30 = 1.5 gi·ªù)\n"
        "   - **Gi·∫£i th√≠ch:** ƒê√¢y l√† t·ªïng gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca (c·∫£ tr∆∞·ªõc v√† sau 22h)\n"
        "   - **L∆∞u √Ω:**\n"
        "     - √Åp d·ª•ng cho t·∫•t c·∫£ lo·∫°i ng√†y\n"
        "     - S·∫Ω ƒë∆∞·ª£c tr·ª´ v√†o t·ªïng tƒÉng ca\n"
        "     - M·∫∑c ƒë·ªãnh: **00:00** (kh√¥ng c√≥ ƒë·ªëi ·ª©ng)\n\n"
        "TR∆Ø·ªúNG 9: Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca tr∆∞·ªõc 22h (Kh√¥ng b·∫Øt bu·ªôc, m·∫∑c ƒë·ªãnh 00:00)\n"
        "- Click v√†o √¥ **Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca tr∆∞·ªõc 22h**\n"
        "   - Nh·∫≠p s·ªë gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca tr∆∞·ªõc 22:00 ƒë√£ d√πng (v√≠ d·ª•: 01:00)\n"
        "   - **Gi·∫£i th√≠ch:** ƒê√¢y l√† gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca trong kho·∫£ng th·ªùi gian tr∆∞·ªõc 22:00\n"
        "   - **L∆∞u √Ω:**\n"
        "     - √Åp d·ª•ng cho t·∫•t c·∫£ lo·∫°i ng√†y\n"
        "     - S·∫Ω ƒë∆∞·ª£c tr·ª´ v√†o tƒÉng ca tr∆∞·ªõc 22h\n"
        "     - M·∫∑c ƒë·ªãnh: **00:00** (kh√¥ng c√≥ ƒë·ªëi ·ª©ng)\n\n"
        "TR∆Ø·ªúNG 10: Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca sau 22h (Kh√¥ng b·∫Øt bu·ªôc, m·∫∑c ƒë·ªãnh 00:00)\n"
        "- Click v√†o √¥ **Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca sau 22h**\n"
        "   - Nh·∫≠p s·ªë gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca sau 22:00 ƒë√£ d√πng (v√≠ d·ª•: 02:00)\n"
        "   - **Gi·∫£i th√≠ch:** ƒê√¢y l√† gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca trong kho·∫£ng th·ªùi gian sau 22:00\n"
        "   - **L∆∞u √Ω:**\n"
        "     - √Åp d·ª•ng cho t·∫•t c·∫£ lo·∫°i ng√†y\n"
        "     - S·∫Ω ƒë∆∞·ª£c tr·ª´ v√†o tƒÉng ca sau 22h\n"
        "     - M·∫∑c ƒë·ªãnh: **00:00** (kh√¥ng c√≥ ƒë·ªëi ·ª©ng)\n\n"
        "TR∆Ø·ªúNG 11: Ghi ch√∫ (Kh√¥ng b·∫Øt bu·ªôc)\n"
        "- Click v√†o √¥ **Ghi ch√∫**\n"
        "   - Nh·∫≠p ghi ch√∫ b·ªï sung n·∫øu c·∫ßn (v√≠ d·ª•: \"ƒêi h·ªçp kh√°ch h√†ng\", \"L√†m vi·ªác t·∫°i nh√†\")\n"
        "   - **L∆∞u √Ω:** Ghi ch√∫ s·∫Ω hi·ªÉn th·ªã trong l·ªãch s·ª≠ ch·∫•m c√¥ng\n\n"
        "**B∆Ø·ªöC CU·ªêI: L∆∞u ch·∫•m c√¥ng**\n"
        "4. Sau khi ƒëi·ªÅn ƒë·∫ßy ƒë·ªß c√°c tr∆∞·ªùng b·∫Øt bu·ªôc, cu·ªôn xu·ªëng cu·ªëi form\n"
        "5. Click n√∫t **L∆∞u** (m√†u xanh, c√≥ icon save)\n"
        "6. H·ªá th·ªëng s·∫Ω:\n"
        "   - Ki·ªÉm tra validation (ng√†y kh√¥ng ƒë∆∞·ª£c l√† t∆∞∆°ng lai, gi·ªù v√†o/ra h·ª£p l·ªá...)\n"
        "   - T·ª± ƒë·ªông t√≠nh:\n"
        "     ‚Ä¢ **T·ªïng gi·ªù l√†m vi·ªác** (t·ª´ gi·ªù v√†o ƒë·∫øn gi·ªù ra, tr·ª´ th·ªùi gian ngh·ªâ v√† ƒë·ªëi ·ª©ng)\n"
        "     ‚Ä¢ **Gi·ªù c√¥ng th∆∞·ªùng** (t·ªëi ƒëa 8h, tr·ª´ ƒë·ªëi ·ª©ng trong ca)\n"
        "     ‚Ä¢ **TƒÉng ca tr∆∞·ªõc 22h** (ph·∫ßn l√†m vi·ªác sau ca nh∆∞ng tr∆∞·ªõc 22:00, tr·ª´ ƒë·ªëi ·ª©ng)\n"
        "     ‚Ä¢ **TƒÉng ca sau 22h** (ph·∫ßn l√†m vi·ªác sau 22:00, tr·ª´ ƒë·ªëi ·ª©ng)\n"
        "   - T·ª± ƒë·ªông l·∫•y ch·ªØ k√Ω t·ª´ database (n·∫øu ƒë√£ t·∫°o ch·ªØ k√Ω tr∆∞·ªõc ƒë√≥)\n"
        "   - Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng\n"
        "7. B·∫£n ghi ch·∫•m c√¥ng s·∫Ω ·ªü tr·∫°ng th√°i **pending** (ch·ªù ph√™ duy·ªát)\n\n"
        "**L∆∞u √Ω quan tr·ªçng v·ªÅ t√≠nh to√°n:**\n"
        "- **Ng√†y th∆∞·ªùng:**\n"
        "  ‚Ä¢ **T·ªïng gi·ªù l√†m vi·ªác** = (Gi·ªù ra - Gi·ªù v√†o) - Th·ªùi gian ngh·ªâ - T·∫•t c·∫£ gi·ªù ƒë·ªëi ·ª©ng\n"
        "  ‚Ä¢ **Gi·ªù c√¥ng th∆∞·ªùng** = th·ªùi gian trong ca (t·ªëi ƒëa 8h ho·∫∑c required_hours) - th·ªùi gian ngh·ªâ - ƒë·ªëi ·ª©ng trong ca\n"
        "  ‚Ä¢ **TƒÉng ca tr∆∞·ªõc 22h** = ph·∫ßn l√†m vi·ªác sau ca nh∆∞ng tr∆∞·ªõc 22:00 - ƒë·ªëi ·ª©ng tr∆∞·ªõc 22h\n"
        "  ‚Ä¢ **TƒÉng ca sau 22h** = ph·∫ßn l√†m vi·ªác sau 22:00 - ƒë·ªëi ·ª©ng sau 22h\n"
        "  ‚Ä¢ **V√≠ d·ª•:**\n"
        "    - Gi·ªù v√†o: 08:00, Gi·ªù ra: 17:00, Ngh·ªâ: 1h, ƒê·ªëi ·ª©ng trong ca: 0h\n"
        "    - T·ªïng gi·ªù l√†m: 9h - 1h = 8h\n"
        "    - Gi·ªù c√¥ng th∆∞·ªùng: 8h (trong ca 08:00-17:00) - 1h ngh·ªâ = 7h\n"
        "    - TƒÉng ca tr∆∞·ªõc 22h: 0h (kh√¥ng l√†m sau ca)\n"
        "    - TƒÉng ca sau 22h: 0h\n"
        "- **Cu·ªëi tu·∫ßn:**\n"
        "  ‚Ä¢ Gi·ªù c√¥ng th∆∞·ªùng = 0\n"
        "  ‚Ä¢ T·∫•t c·∫£ th·ªùi gian l√†m vi·ªác t√≠nh v√†o tƒÉng ca (ph√¢n chia tr∆∞·ªõc/sau 22h)\n"
        "- **L·ªÖ Vi·ªát Nam:**\n"
        "  ‚Ä¢ N·∫øu kh√¥ng ƒëi l√†m: T·ª± ƒë·ªông ƒë∆∞·ª£c 8h gi·ªù c√¥ng th∆∞·ªùng, kh√¥ng c√≥ tƒÉng ca\n"
        "  ‚Ä¢ N·∫øu c√≥ ƒëi l√†m: T√≠nh nh∆∞ ng√†y th∆∞·ªùng + tƒÉng ca\n"
        "- **L·ªÖ Nh·∫≠t:**\n"
        "  ‚Ä¢ T√≠nh gi·ªù c√¥ng th∆∞·ªùng v√† tƒÉng ca nh∆∞ ng√†y th∆∞·ªùng\n"
        "- **M·∫π c√≥ con <12 th√°ng (ca 1-4):**\n"
        "  ‚Ä¢ Ch√≠nh s√°ch ƒë·∫∑c bi·ªát: Ch·ªâ c·∫ßn l√†m 7 gi·ªù/ng√†y l√† ƒë·ªß c√¥ng (thay v√¨ 8 gi·ªù)\n"
        "  ‚Ä¢ ƒê∆∞·ª£c +1h bonus v√†o gi·ªù c√¥ng th∆∞·ªùng (t·ª©c l√†m 7h ƒë∆∞·ª£c t√≠nh 8h)\n"
        "  ‚Ä¢ N·∫øu t·ªïng > 8h: ph·∫ßn v∆∞·ª£t t√≠nh v√†o tƒÉng ca\n"
        "  ‚Ä¢ **L∆∞u √Ω:** Ch·ªâ √°p d·ª•ng cho ca 1-4, ng√†y th∆∞·ªùng, kh√¥ng √°p d·ª•ng cu·ªëi tu·∫ßn/l·ªÖ\n"
        "  ‚Ä¢ **V√≠ d·ª•:**\n"
        "    - L√†m 7h: Gi·ªù c√¥ng = 7h + 1h bonus = 8h (ƒë·ªß c√¥ng)\n"
        "    - L√†m 8h: Gi·ªù c√¥ng = 8h + 1h bonus = 9h ‚Üí 8h c√¥ng + 1h tƒÉng ca\n\n"
        "- **Gi·ªù c√¥ng t·ªëi thi·ªÉu (required_hours):**\n"
        "  ‚Ä¢ H·ªá th·ªëng t·ª± ƒë·ªông t√≠nh gi·ªù c√¥ng t·ªëi thi·ªÉu c·∫ßn ƒë·∫°t trong ng√†y\n"
        "  ‚Ä¢ M·∫∑c ƒë·ªãnh: 8 gi·ªù cho ng√†y th∆∞·ªùng\n"
        "  ‚Ä¢ M·∫π c√≥ con <12 th√°ng (ca 1-4): 7 gi·ªù\n"
        "  ‚Ä¢ L·ªÖ Vi·ªát Nam: 8 gi·ªù (d√π kh√¥ng ƒëi l√†m)\n"
        "  ‚Ä¢ Cu·ªëi tu·∫ßn: 0 gi·ªù (kh√¥ng c√≥ gi·ªù c√¥ng th∆∞·ªùng)\n"
        "  ‚Ä¢ **L∆∞u √Ω:** H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã required_hours trong k·∫øt qu·∫£ t√≠nh to√°n\n\n"
        "=== 7. XEM L·ªäCH S·ª¨ CH·∫§M C√îNG (Dashboard) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o menu **Trang ch·ªß** ho·∫∑c **Dashboard** ·ªü sidebar b√™n tr√°i\n"
        "2. Trang Dashboard s·∫Ω hi·ªÉn th·ªã:\n"
        "   - B·∫£ng l·ªãch s·ª≠ ch·∫•m c√¥ng v·ªõi c√°c c·ªôt:\n"
        "     ‚Ä¢ Ng√†y\n"
        "     ‚Ä¢ Gi·ªù v√†o\n"
        "     ‚Ä¢ Gi·ªù ra\n"
        "     ‚Ä¢ Ca\n"
        "     ‚Ä¢ Th·ªùi gian ngh·ªâ\n"
        "     ‚Ä¢ T·ªïng ƒë·ªëi ·ª©ng\n"
        "     ‚Ä¢ T·ªïng gi·ªù l√†m\n"
        "     ‚Ä¢ Gi·ªù c√¥ng th∆∞·ªùng\n"
        "     ‚Ä¢ TƒÉng ca <22h\n"
        "     ‚Ä¢ TƒÉng ca >22h\n"
        "     ‚Ä¢ Lo·∫°i ng√†y (L√†m vi·ªác, Ngh·ªâ l·ªÖ, Ch·ªß nh·∫≠t...)\n"
        "     ‚Ä¢ Tr·∫°ng th√°i (Ch·ªù ph√™ duy·ªát, ƒê√£ ph√™ duy·ªát, T·ª´ ch·ªëi)\n"
        "     ‚Ä¢ H√†nh ƒë·ªông (S·ª≠a, X√≥a, Xem chi ti·∫øt)\n"
        "   - B·ªô chuy·ªÉn vai tr√≤ ·ªü g√≥c tr√™n (n·∫øu b·∫°n c√≥ nhi·ªÅu vai tr√≤)\n"
        "   - C·∫£nh b√°o license/token n·∫øu c√≥ v·∫•n ƒë·ªÅ\n"
        "3. S·ª≠ d·ª•ng c√°c b·ªô l·ªçc ·ªü tr√™n b·∫£ng:\n"
        "   - Ch·ªçn th√°ng/nƒÉm ƒë·ªÉ xem l·ªãch s·ª≠ ch·∫•m c√¥ng\n"
        "   - T√¨m ki·∫øm theo t√™n/m√£ nh√¢n vi√™n (n·∫øu c√≥ quy·ªÅn)\n"
        "4. Click **√Åp d·ª•ng b·ªô l·ªçc** ƒë·ªÉ xem k·∫øt qu·∫£\n"
        "5. Trong c·ªôt **H√†nh ƒë·ªông**, b·∫°n c√≥ th·ªÉ:\n"
        "   - Click icon **m·∫Øt** (üëÅÔ∏è) ƒë·ªÉ xem chi ti·∫øt\n"
        "   - Click icon **b√∫t** (‚úèÔ∏è) ƒë·ªÉ s·ª≠a (ch·ªâ khi ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát)\n"
        "   - Click icon **th√πng r√°c** (üóëÔ∏è) ƒë·ªÉ x√≥a (ch·ªâ khi ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát)\n\n"
        "=== 7A. XEM CHI TI·∫æT CH·∫§M C√îNG ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o Dashboard ‚Üí T√¨m b·∫£n ghi ch·∫•m c√¥ng c·∫ßn xem\n"
        "2. Click icon **m·∫Øt** (üëÅÔ∏è) ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "3. Trang chi ti·∫øt s·∫Ω hi·ªÉn th·ªã:\n"
        "   - **Th√¥ng tin nh√¢n vi√™n:** T√™n, M√£ NV, Ph√≤ng ban\n"
        "   - **Th√¥ng tin ch·∫•m c√¥ng:**\n"
        "     ‚Ä¢ Ng√†y ch·∫•m c√¥ng\n"
        "     ‚Ä¢ Lo·∫°i ng√†y (Ng√†y th∆∞·ªùng, Cu·ªëi tu·∫ßn, L·ªÖ Vi·ªát Nam, L·ªÖ Nh·∫≠t B·∫£n)\n"
        "     ‚Ä¢ Ca l√†m vi·ªác (Ca 1, Ca 2, Ca 3, Ca 4, Ca 5)\n"
        "     ‚Ä¢ Gi·ªù v√†o ca / Gi·ªù ra ca (t·ª± ƒë·ªông t·ª´ ca l√†m vi·ªác)\n"
        "     ‚Ä¢ Gi·ªù v√†o th·ª±c t·∫ø / Gi·ªù ra th·ª±c t·∫ø\n"
        "     ‚Ä¢ Th·ªùi gian ngh·ªâ\n"
        "     ‚Ä¢ T·∫•t c·∫£ c√°c tr∆∞·ªùng gi·ªù ƒë·ªëi ·ª©ng\n"
        "     ‚Ä¢ Ghi ch√∫ (n·∫øu c√≥)\n"
        "   - **K·∫øt qu·∫£ t√≠nh to√°n:**\n"
        "     ‚Ä¢ T·ªïng gi·ªù l√†m vi·ªác\n"
        "     ‚Ä¢ Gi·ªù c√¥ng th∆∞·ªùng\n"
        "     ‚Ä¢ TƒÉng ca tr∆∞·ªõc 22h\n"
        "     ‚Ä¢ TƒÉng ca sau 22h\n"
        "     ‚Ä¢ Gi·ªù c√¥ng t·ªëi thi·ªÉu (required_hours)\n"
        "   - **Th√¥ng tin ph√™ duy·ªát:**\n"
        "     ‚Ä¢ Tr·∫°ng th√°i (Ch·ªù ph√™ duy·ªát, ƒê√£ ph√™ duy·ªát, T·ª´ ch·ªëi)\n"
        "     ‚Ä¢ Ng∆∞·ªùi ph√™ duy·ªát (Leader, Manager, Admin)\n"
        "     ‚Ä¢ Ng√†y ph√™ duy·ªát\n"
        "     ‚Ä¢ L√Ω do t·ª´ ch·ªëi (n·∫øu b·ªã t·ª´ ch·ªëi)\n"
        "     ‚Ä¢ Ch·ªØ k√Ω c·ªßa ng∆∞·ªùi ph√™ duy·ªát (n·∫øu ƒë√£ ph√™ duy·ªát)\n"
        "   - **C√°c n√∫t h√†nh ƒë·ªông:**\n"
        "     ‚Ä¢ **Xu·∫•t PDF** (n·∫øu ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát)\n"
        "     ‚Ä¢ **Test ch·ªØ k√Ω** (ch·ªâ Admin, n·∫øu ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát)\n"
        "     ‚Ä¢ **Ph√™ duy·ªát** (n·∫øu c√≥ quy·ªÅn v√† ƒëang ch·ªù ph√™ duy·ªát)\n"
        "     ‚Ä¢ **T·ª´ ch·ªëi** (n·∫øu c√≥ quy·ªÅn v√† ƒëang ch·ªù ph√™ duy·ªát)\n"
        "     ‚Ä¢ **S·ª≠a** (n·∫øu ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát v√† b·∫°n c√≥ quy·ªÅn)\n"
        "     ‚Ä¢ **X√≥a** (n·∫øu ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát v√† b·∫°n c√≥ quy·ªÅn)\n\n"
        "**L∆∞u √Ω:**\n"
        "- T·∫•t c·∫£ th√¥ng tin chi ti·∫øt ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß trong trang n√†y\n"
        "- C√≥ th·ªÉ scroll ƒë·ªÉ xem t·∫•t c·∫£ th√¥ng tin\n"
        "- C√°c n√∫t h√†nh ƒë·ªông s·∫Ω hi·ªÉn th·ªã/·∫©n t√πy theo quy·ªÅn v√† tr·∫°ng th√°i c·ªßa b·∫£n ghi\n\n"
        "=== 8. S·ª¨A CH·∫§M C√îNG ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o Dashboard ‚Üí T√¨m b·∫£n ghi ch·∫•m c√¥ng c·∫ßn s·ª≠a trong b·∫£ng l·ªãch s·ª≠\n"
        "2. Click icon **b√∫t** (‚úèÔ∏è) ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "3. **L∆∞u √Ω:** Ch·ªâ s·ª≠a ƒë∆∞·ª£c khi b·∫£n ghi ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát (tr·∫°ng th√°i **pending** ho·∫∑c **rejected**)\n"
        "4. Form s·ª≠a s·∫Ω hi·ªÉn th·ªã v·ªõi t·∫•t c·∫£ th√¥ng tin hi·ªán t·∫°i ƒë√£ ƒë∆∞·ª£c ƒëi·ªÅn s·∫µn\n"
        "5. S·ª≠a c√°c tr∆∞·ªùng c·∫ßn thay ƒë·ªïi (gi·ªëng nh∆∞ ƒëƒÉng k√Ω m·ªõi):\n"
        "   - Ng√†y ch·∫•m c√¥ng\n"
        "   - Lo·∫°i ng√†y\n"
        "   - Ca l√†m vi·ªác\n"
        "   - Gi·ªù v√†o/ra\n"
        "   - Th·ªùi gian ngh·ªâ\n"
        "   - C√°c tr∆∞·ªùng gi·ªù ƒë·ªëi ·ª©ng\n"
        "   - Ghi ch√∫\n"
        "6. Sau khi s·ª≠a xong, click n√∫t **L∆∞u** (m√†u xanh)\n"
        "7. H·ªá th·ªëng s·∫Ω:\n"
        "   - Ki·ªÉm tra validation\n"
        "   - T·ª± ƒë·ªông t√≠nh l·∫°i gi·ªù c√¥ng v√† tƒÉng ca\n"
        "   - C·∫≠p nh·∫≠t b·∫£n ghi\n"
        "   - Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng\n\n"
        "**L∆∞u √Ω:**\n"
        "- Kh√¥ng th·ªÉ s·ª≠a b·∫£n ghi ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát (tr·∫°ng th√°i **approved**)\n"
        "- N·∫øu b·∫£n ghi ·ªü tr·∫°ng th√°i **rejected**, sau khi s·ª≠a s·∫Ω chuy·ªÉn v·ªÅ **pending**\n"
        "- Ch·ªØ k√Ω s·∫Ω t·ª± ƒë·ªông l·∫•y t·ª´ database (n·∫øu ƒë√£ t·∫°o tr∆∞·ªõc ƒë√≥)\n\n"
        "=== 9. X√ìA CH·∫§M C√îNG ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o Dashboard ‚Üí T√¨m b·∫£n ghi ch·∫•m c√¥ng c·∫ßn x√≥a trong b·∫£ng l·ªãch s·ª≠\n"
        "2. Click icon **th√πng r√°c** (üóëÔ∏è) ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "3. **L∆∞u √Ω:** Ch·ªâ x√≥a ƒë∆∞·ª£c khi:\n"
        "   - B·∫£n ghi ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát (tr·∫°ng th√°i **pending** ho·∫∑c **rejected**)\n"
        "   - B·∫°n l√† ng∆∞·ªùi t·∫°o b·∫£n ghi ho·∫∑c c√≥ quy·ªÅn Admin\n"
        "4. H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã popup x√°c nh·∫≠n x√≥a\n"
        "5. Click **X√°c nh·∫≠n** ƒë·ªÉ x√≥a ho·∫∑c **H·ªßy** ƒë·ªÉ h·ªßy b·ªè\n"
        "6. Sau khi x√≥a, b·∫£n ghi s·∫Ω bi·∫øn m·∫•t kh·ªèi danh s√°ch\n\n"
        "**L∆∞u √Ω:**\n"
        "- Kh√¥ng th·ªÉ x√≥a b·∫£n ghi ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát\n"
        "- H√†nh ƒë·ªông x√≥a kh√¥ng th·ªÉ ho√†n t√°c, c·∫ßn c·∫©n th·∫≠n\n\n"
        "=== 10. S·ª¨A ƒê∆†N NGH·ªà PH√âP ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Theo d√µi t√¨nh tr·∫°ng** ‚Üí T√¨m ƒë∆°n ngh·ªâ ph√©p c·∫ßn s·ª≠a\n"
        "2. Click icon **m·∫Øt** (üëÅÔ∏è) ƒë·ªÉ xem chi ti·∫øt ƒë∆°n\n"
        "3. Trong trang chi ti·∫øt, n·∫øu ƒë∆°n c√≤n ·ªü tr·∫°ng th√°i **pending** ho·∫∑c **rejected**, s·∫Ω c√≥ n√∫t **S·ª≠a ƒë∆°n**\n"
        "4. Click n√∫t **S·ª≠a ƒë∆°n** (m√†u xanh, c√≥ icon edit)\n"
        "5. Form s·ª≠a s·∫Ω hi·ªÉn th·ªã v·ªõi t·∫•t c·∫£ th√¥ng tin hi·ªán t·∫°i ƒë√£ ƒë∆∞·ª£c ƒëi·ªÅn s·∫µn\n"
        "6. S·ª≠a c√°c tr∆∞·ªùng c·∫ßn thay ƒë·ªïi (gi·ªëng nh∆∞ t·∫°o ƒë∆°n m·ªõi):\n"
        "   - Lo·∫°i ƒë∆°n\n"
        "   - L√Ω do ngh·ªâ ph√©p\n"
        "   - Ch·ª©ng t·ª´ ƒë√≠nh k√®m (c√≥ th·ªÉ th√™m file m·ªõi, file c≈© v·∫´n gi·ªØ nguy√™n)\n"
        "   - Ca l√†m vi·ªác\n"
        "   - T·ª´ ng√†y/ƒê·∫øn ng√†y\n"
        "   - S·ªë ng√†y ngh·ªâ\n"
        "   - Ng∆∞·ªùi thay th·∫ø\n"
        "   - Ghi ch√∫\n"
        "7. Sau khi s·ª≠a xong, cu·ªôn xu·ªëng cu·ªëi form\n"
        "8. Click n√∫t **C·∫≠p nh·∫≠t** (m√†u xanh gradient, c√≥ icon save)\n"
        "9. H·ªá th·ªëng s·∫Ω:\n"
        "   - Ki·ªÉm tra validation\n"
        "   - C·∫≠p nh·∫≠t ƒë∆°n\n"
        "   - N·∫øu ƒë∆°n ·ªü tr·∫°ng th√°i **rejected**, s·∫Ω chuy·ªÉn v·ªÅ **pending** (ch·ªù ph√™ duy·ªát l·∫°i)\n"
        "   - Hi·ªÉn th·ªã popup x√°c nh·∫≠n g·ª≠i email (n·∫øu mu·ªën)\n"
        "   - Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng\n\n"
        "**L∆∞u √Ω:**\n"
        "- Ch·ªâ s·ª≠a ƒë∆∞·ª£c ƒë∆°n ·ªü tr·∫°ng th√°i **pending** ho·∫∑c **rejected**\n"
        "- Kh√¥ng th·ªÉ s·ª≠a ƒë∆°n ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát (tr·∫°ng th√°i **approved**)\n"
        "- File ƒë√≠nh k√®m m·ªõi s·∫Ω ƒë∆∞·ª£c th√™m v√†o danh s√°ch file c≈© (kh√¥ng thay th·∫ø)\n"
        "- N·∫øu s·ª≠a ƒë∆°n b·ªã t·ª´ ch·ªëi, ƒë∆°n s·∫Ω chuy·ªÉn v·ªÅ tr·∫°ng th√°i **pending** v√† c·∫ßn ph√™ duy·ªát l·∫°i\n\n"
        "=== 16. PH√ä DUY·ªÜT CH·∫§M C√îNG (D√†nh cho Leader/Manager/Admin) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o Dashboard ‚Üí S·ª≠ d·ª•ng b·ªô l·ªçc ƒë·ªÉ t√¨m c√°c b·∫£n ghi ch·∫•m c√¥ng c·∫ßn ph√™ duy·ªát\n"
        "2. T√¨m b·∫£n ghi c√≥ tr·∫°ng th√°i **Ch·ªù ph√™ duy·ªát** (pending)\n"
        "3. Click icon **m·∫Øt** (üëÅÔ∏è) ·ªü c·ªôt **H√†nh ƒë·ªông** ƒë·ªÉ xem chi ti·∫øt\n"
        "4. Trong trang chi ti·∫øt (ho·∫∑c modal), b·∫°n s·∫Ω th·∫•y:\n"
        "   - T·∫•t c·∫£ th√¥ng tin ch·∫•m c√¥ng (ng√†y, gi·ªù v√†o/ra, ca, lo·∫°i ng√†y...)\n"
        "   - K·∫øt qu·∫£ t√≠nh to√°n (gi·ªù c√¥ng th∆∞·ªùng, tƒÉng ca...)\n"
        "   - N√∫t **Ph√™ duy·ªát** (m√†u xanh)\n"
        "   - N√∫t **T·ª´ ch·ªëi** (m√†u ƒë·ªè)\n"
        "5. ƒê·ªÉ ph√™ duy·ªát:\n"
        "   - Click n√∫t **Ph√™ duy·ªát**\n"
        "   - H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông l·∫•y ch·ªØ k√Ω t·ª´ database (n·∫øu ƒë√£ t·∫°o ch·ªØ k√Ω tr∆∞·ªõc ƒë√≥)\n"
        "   - N·∫øu ch∆∞a c√≥ ch·ªØ k√Ω, s·∫Ω y√™u c·∫ßu v·∫Ω ho·∫∑c upload ch·ªØ k√Ω\n"
        "   - Sau khi c√≥ ch·ªØ k√Ω, click **X√°c nh·∫≠n ph√™ duy·ªát**\n"
        "   - B·∫£n ghi s·∫Ω chuy·ªÉn sang tr·∫°ng th√°i **ƒê√£ ph√™ duy·ªát** (approved)\n"
        "6. ƒê·ªÉ t·ª´ ch·ªëi:\n"
        "   - Click n√∫t **T·ª´ ch·ªëi**\n"
        "   - Nh·∫≠p l√Ω do t·ª´ ch·ªëi v√†o √¥ textarea (b·∫Øt bu·ªôc)\n"
        "   - Click **X√°c nh·∫≠n t·ª´ ch·ªëi**\n"
        "   - B·∫£n ghi s·∫Ω chuy·ªÉn sang tr·∫°ng th√°i **T·ª´ ch·ªëi** (rejected)\n"
        "7. Ng∆∞·ªùi t·∫°o b·∫£n ghi s·∫Ω nh·∫≠n ƒë∆∞·ª£c email th√¥ng b√°o k·∫øt qu·∫£ (n·∫øu c√≥ c·∫•u h√¨nh email)\n\n"
        "8. **Ph√™ duy·ªát h√†ng lo·∫°t (n·∫øu c√≥ t√≠nh nƒÉng n√†y):**\n"
        "   - V√†o Dashboard ‚Üí S·ª≠ d·ª•ng b·ªô l·ªçc ƒë·ªÉ t√¨m c√°c b·∫£n ghi c·∫ßn ph√™ duy·ªát\n"
        "   - Ch·ªçn nhi·ªÅu b·∫£n ghi b·∫±ng c√°ch:\n"
        "     ‚Ä¢ Click checkbox ·ªü ƒë·∫ßu m·ªói d√≤ng b·∫£n ghi c·∫ßn ph√™ duy·ªát\n"
        "     ‚Ä¢ Ho·∫∑c click checkbox \"Ch·ªçn t·∫•t c·∫£\" (n·∫øu c√≥) ƒë·ªÉ ch·ªçn t·∫•t c·∫£ b·∫£n ghi trong trang hi·ªán t·∫°i\n"
        "   - Sau khi ch·ªçn xong, click n√∫t **Ph√™ duy·ªát t·∫•t c·∫£** ho·∫∑c **Approve All** (m√†u xanh, c√≥ icon check)\n"
        "   - H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã popup x√°c nh·∫≠n:\n"
        "     ‚Ä¢ S·ªë l∆∞·ª£ng b·∫£n ghi s·∫Ω ƒë∆∞·ª£c ph√™ duy·ªát\n"
        "     ‚Ä¢ C·∫£nh b√°o: T·∫•t c·∫£ b·∫£n ghi ƒë√£ ch·ªçn s·∫Ω ƒë∆∞·ª£c ph√™ duy·ªát c√πng l√∫c\n"
        "   - Click **X√°c nh·∫≠n ph√™ duy·ªát** ƒë·ªÉ x√°c nh·∫≠n\n"
        "   - H·ªá th·ªëng s·∫Ω:\n"
        "     ‚Ä¢ T·ª± ƒë·ªông l·∫•y ch·ªØ k√Ω t·ª´ database cho t·ª´ng b·∫£n ghi (n·∫øu ƒë√£ c√≥ ch·ªØ k√Ω)\n"
        "     ‚Ä¢ Ph√™ duy·ªát t·∫•t c·∫£ b·∫£n ghi ƒë√£ ch·ªçn c√πng l√∫c\n"
        "     ‚Ä¢ C·∫≠p nh·∫≠t tr·∫°ng th√°i t·∫•t c·∫£ b·∫£n ghi th√†nh **ƒê√£ ph√™ duy·ªát** (approved)\n"
        "     ‚Ä¢ Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng v·ªõi s·ªë l∆∞·ª£ng b·∫£n ghi ƒë√£ ph√™ duy·ªát\n"
        "   - **L∆∞u √Ω:**\n"
        "     ‚Ä¢ Ch·ªâ ph√™ duy·ªát ƒë∆∞·ª£c c√°c b·∫£n ghi ·ªü tr·∫°ng th√°i **pending** (ch·ªù ph√™ duy·ªát)\n"
        "     ‚Ä¢ B·∫£n ghi ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát ho·∫∑c b·ªã t·ª´ ch·ªëi s·∫Ω kh√¥ng ƒë∆∞·ª£c ch·ªçn\n"
        "     ‚Ä¢ Ph√™ duy·ªát h√†ng lo·∫°t ti·∫øt ki·ªám th·ªùi gian khi c√≥ nhi·ªÅu b·∫£n ghi c·∫ßn ph√™ duy·ªát\n"
        "     ‚Ä¢ N√™n ki·ªÉm tra k·ªπ c√°c b·∫£n ghi tr∆∞·ªõc khi ph√™ duy·ªát h√†ng lo·∫°t\n"
        "     ‚Ä¢ Ng∆∞·ªùi t·∫°o b·∫£n ghi s·∫Ω nh·∫≠n ƒë∆∞·ª£c email th√¥ng b√°o (n·∫øu c√≥ c·∫•u h√¨nh email)\n\n"
        "**L∆∞u √Ω:**\n"
        "- Quy tr√¨nh ph√™ duy·ªát: Employee ‚Üí Leader ‚Üí Manager ‚Üí Admin (t√πy theo c·∫•u h√¨nh)\n"
        "- M·ªói c·∫•p ch·ªâ c√≥ th·ªÉ ph√™ duy·ªát b·∫£n ghi c·ªßa c·∫•p d∆∞·ªõi trong ph√≤ng ban c·ªßa m√¨nh\n"
        "- Ch·ªØ k√Ω s·∫Ω ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông v√†o database sau khi ph√™ duy·ªát\n"
        "- K·∫øt qu·∫£ ph√™ duy·ªát c√≥ th·ªÉ xem l·∫°i ·ªü Dashboard\n\n"
        "=== 17. PH√ä DUY·ªÜT ƒê∆†N NGH·ªà PH√âP (D√†nh cho Leader/Manager/Admin) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o menu **Theo d√µi t√¨nh tr·∫°ng** ·ªü sidebar b√™n tr√°i\n"
        "2. S·ª≠ d·ª•ng b·ªô l·ªçc **Tr·∫°ng th√°i** ƒë·ªÉ t√¨m c√°c ƒë∆°n c·∫ßn ph√™ duy·ªát:\n"
        "   - Leader: Ch·ªçn tr·∫°ng th√°i **pending**\n"
        "   - Manager: Ch·ªçn tr·∫°ng th√°i **pending_manager**\n"
        "   - Admin: Ch·ªçn tr·∫°ng th√°i **pending_admin**\n"
        "3. Click **√Åp d·ª•ng b·ªô l·ªçc** ƒë·ªÉ xem danh s√°ch ƒë∆°n c·∫ßn ph√™ duy·ªát\n"
        "4. Click icon **m·∫Øt** (üëÅÔ∏è) ·ªü c·ªôt **H√†nh ƒë·ªông** ƒë·ªÉ xem chi ti·∫øt ƒë∆°n\n"
        "5. Trong trang chi ti·∫øt, b·∫°n s·∫Ω th·∫•y:\n"
        "   - T·∫•t c·∫£ th√¥ng tin ƒë∆°n ngh·ªâ ph√©p\n"
        "   - File ƒë√≠nh k√®m (n·∫øu c√≥)\n"
        "   - N√∫t **Ph√™ duy·ªát** (m√†u xanh)\n"
        "   - N√∫t **T·ª´ ch·ªëi** (m√†u ƒë·ªè)\n"
        "6. ƒê·ªÉ ph√™ duy·ªát:\n"
        "   - Click n√∫t **Ph√™ duy·ªát**\n"
        "   - Nh·∫≠p nh·∫≠n x√©t (n·∫øu mu·ªën) v√†o √¥ textarea\n"
        "   - Click **X√°c nh·∫≠n ph√™ duy·ªát**\n"
        "7. ƒê·ªÉ t·ª´ ch·ªëi:\n"
        "   - Click n√∫t **T·ª´ ch·ªëi**\n"
        "   - Nh·∫≠p l√Ω do t·ª´ ch·ªëi v√†o √¥ textarea (b·∫Øt bu·ªôc)\n"
        "   - Click **X√°c nh·∫≠n t·ª´ ch·ªëi**\n"
        "8. Sau khi ph√™ duy·ªát/t·ª´ ch·ªëi, ƒë∆°n s·∫Ω chuy·ªÉn sang tr·∫°ng th√°i ti·∫øp theo ho·∫∑c ho√†n t·∫•t\n"
        "9. Ng∆∞·ªùi t·∫°o ƒë∆°n s·∫Ω nh·∫≠n ƒë∆∞·ª£c email th√¥ng b√°o k·∫øt qu·∫£\n\n"
        "**L∆∞u √Ω:**\n"
        "- Quy tr√¨nh ph√™ duy·ªát: Employee ‚Üí Leader ‚Üí Manager ‚Üí Admin (t√πy theo c·∫•u h√¨nh)\n"
        "- M·ªói c·∫•p ch·ªâ c√≥ th·ªÉ ph√™ duy·ªát ƒë∆°n ·ªü tr·∫°ng th√°i t∆∞∆°ng ·ª©ng\n"
        "- K·∫øt qu·∫£ ph√™ duy·ªát c√≥ th·ªÉ xem l·∫°i ·ªü **L·ªãch s·ª≠ ngh·ªâ ph√©p**\n\n"
        "=== 18. XU·∫§T EXCEL L·ªäCH S·ª¨ NGH·ªà PH√âP (Ch·ªâ Admin) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o menu **L·ªãch s·ª≠ ngh·ªâ ph√©p** ·ªü sidebar b√™n tr√°i\n"
        "2. S·ª≠ d·ª•ng c√°c b·ªô l·ªçc ƒë·ªÉ ch·ªçn d·ªØ li·ªáu mu·ªën xu·∫•t (n·∫øu c·∫ßn):\n"
        "   - T√¨m ki·∫øm theo t√™n/m√£ nh√¢n vi√™n\n"
        "   - L·ªçc theo ph√≤ng ban\n"
        "   - L·ªçc theo lo·∫°i ƒë∆°n\n"
        "   - L·ªçc theo tr·∫°ng th√°i\n"
        "   - L·ªçc theo kho·∫£ng th·ªùi gian (T·ª´ ng√†y - ƒê·∫øn ng√†y)\n"
        "3. Click **√Åp d·ª•ng b·ªô l·ªçc** ƒë·ªÉ xem d·ªØ li·ªáu ƒë√£ l·ªçc\n"
        "4. Click n√∫t **T·∫£i Excel** ·ªü g√≥c tr√™n b√™n ph·∫£i b·∫£ng\n"
        "5. File Excel s·∫Ω ƒë∆∞·ª£c t·∫£i v·ªÅ m√°y t√≠nh v·ªõi t√™n file ch·ª©a ng√†y xu·∫•t (v√≠ d·ª•: `leave_history_20240115.xlsx`)\n"
        "6. M·ªü file Excel ƒë·ªÉ xem d·ªØ li·ªáu ƒë√£ xu·∫•t\n\n"
        "**QUAN TR·ªåNG V·ªÄ ƒê·ªäNH D·∫†NG EXCEL:**\n\n"
        "1. **Excel t√°ch t·ª´ng ng√†y ri√™ng bi·ªát:**\n"
        "   - N·∫øu ngh·ªâ t·ª´ **1/1 ƒë·∫øn 3/1** (3 ng√†y) ‚Üí Excel s·∫Ω c√≥ **3 d√≤ng**, m·ªói d√≤ng 1 ng√†y\n"
        "   - M·ªói d√≤ng = 1 ng√†y ngh·ªâ ri√™ng bi·ªát\n"
        "   - V√≠ d·ª• c·ª• th·ªÉ:\n"
        "     ‚Ä¢ D√≤ng 1: Ng√†y 1/1, S√°ng, 0.5 ng√†y ngh·ªâ ph√©p nƒÉm, L√Ω do: \"Ngh·ªâ ph√©p\"\n"
        "     ‚Ä¢ D√≤ng 2: Ng√†y 2/1, C·∫£ ng√†y, 1 ng√†y ngh·ªâ ph√©p nƒÉm, L√Ω do: \"Ngh·ªâ ph√©p\"\n"
        "     ‚Ä¢ D√≤ng 3: Ng√†y 3/1, Chi·ªÅu, 0.5 ng√†y ngh·ªâ ph√©p nƒÉm, L√Ω do: \"Ngh·ªâ ph√©p\"\n\n"
        "2. **C√°c c·ªôt trong Excel:**\n"
        "   - **Nh√¢n vi√™n:** T√™n ƒë·∫ßy ƒë·ªß c·ªßa nh√¢n vi√™n\n"
        "   - **M√£ NV:** M√£ nh√¢n vi√™n\n"
        "   - **Ph√≤ng ban:** Ph√≤ng ban c·ªßa nh√¢n vi√™n\n"
        "   - **Ng√†y ngh·ªâ:** Ng√†y c·ª• th·ªÉ (t·ª´ng ng√†y ri√™ng, format: DD/MM/YYYY)\n"
        "   - **Th·ªùi gian ngh·ªâ:** S√°ng/Chi·ªÅu/C·∫£ ng√†y\n"
        "   - **L√Ω do:** L√Ω do ngh·ªâ ph√©p (t·ª´ ƒë∆°n ngh·ªâ ph√©p)\n"
        "   - **Lo·∫°i ngh·ªâ:** Ngh·ªâ ph√©p nƒÉm / Ngh·ªâ kh√¥ng l∆∞∆°ng / Ngh·ªâ ƒë·∫∑c bi·ªát\n"
        "   - **S·ªë ng√†y:** S·ªë ng√†y ngh·ªâ (0.5, 1, 1.5, 2...)\n"
        "   - **Ng√†y t·∫°o:** Ng√†y t·∫°o ƒë∆°n ngh·ªâ ph√©p\n"
        "   - **Tr·∫°ng th√°i:** ƒê√£ ph√™ duy·ªát / T·ª´ ch·ªëi / Ch·ªù ph√™ duy·ªát\n\n"
        "3. **L·ªçc d·ªØ li·ªáu tr∆∞·ªõc khi xu·∫•t:**\n"
        "   - Excel s·∫Ω ch·ªâ ch·ª©a d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c l·ªçc tr√™n trang web\n"
        "   - V√≠ d·ª•: L·ªçc theo ph√≤ng ban \"SCOPE\" ‚Üí Excel ch·ªâ c√≥ nh√¢n vi√™n ph√≤ng ban SCOPE\n"
        "   - V√≠ d·ª•: L·ªçc t·ª´ 1/1/2024 ƒë·∫øn 31/1/2024 ‚Üí Excel ch·ªâ c√≥ ƒë∆°n trong th√°ng 1/2024\n\n"
        "**L∆∞u √Ω:**\n"
        "- Excel t√°ch t·ª´ng ng√†y ƒë·ªÉ d·ªÖ t√≠nh to√°n v√† ki·ªÉm tra chi ti·∫øt\n"
        "- N·∫øu mu·ªën xem t·ªïng h·ª£p theo ƒë∆°n (kh√¥ng t√°ch ng√†y), xem **Section 34: Xu·∫•t Excel tr∆∞·ªùng h·ª£p ngh·ªâ ph√©p**\n"
        "- Ch·ªâ Admin m·ªõi c√≥ quy·ªÅn xu·∫•t Excel\n"
        "- File Excel c√≥ th·ªÉ m·ªü b·∫±ng Microsoft Excel, Google Sheets, LibreOffice Calc\n"
        "- File Excel c√≥ th·ªÉ ƒë∆∞·ª£c d√πng ƒë·ªÉ b√°o c√°o, th·ªëng k√™, ho·∫∑c import v√†o h·ªá th·ªëng kh√°c\n\n"
        "=== 20. QUY T·∫ÆC VALIDATION V√Ä X·ª¨ L√ù L·ªñI ===\n\n"
        "**VALIDATION CHO ƒêƒÇNG K√ù CH·∫§M C√îNG:**\n\n"
        "1. **Ng√†y ch·∫•m c√¥ng:**\n"
        "   - KH√îNG ƒë∆∞·ª£c ch·ªçn ng√†y trong t∆∞∆°ng lai\n"
        "   - Ch·ªâ ƒë∆∞·ª£c ch·ªçn ng√†y trong qu√° kh·ª© ho·∫∑c h√¥m nay\n"
        "   - L·ªói: \"Kh√¥ng th·ªÉ ch·∫•m c√¥ng cho ng√†y trong t∆∞∆°ng lai!\"\n\n"
        "2. **Gi·ªù v√†o/ra:**\n"
        "   - B·∫Øt bu·ªôc ph·∫£i nh·∫≠p (tr·ª´ L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m)\n"
        "   - ƒê·ªãnh d·∫°ng: HH:MM (24 gi·ªù, v√≠ d·ª•: 08:00, 17:30)\n"
        "   - Gi·ªù ra ph·∫£i > gi·ªù v√†o (ho·∫∑c qua ƒë√™m n·∫øu b·∫≠t toggle)\n"
        "   - L·ªói: \"Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß gi·ªù v√†o v√† gi·ªù ra h·ª£p l·ªá\"\n\n"
        "3. **Ca l√†m vi·ªác:**\n"
        "   - B·∫Øt bu·ªôc ph·∫£i ch·ªçn (tr·ª´ L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m)\n"
        "   - L·ªói: \"Vui l√≤ng ch·ªçn ca l√†m vi·ªác h·ª£p l·ªá!\"\n\n"
        "4. **Th·ªùi gian ngh·ªâ:**\n"
        "   - ƒê·ªãnh d·∫°ng: HH:MM (v√≠ d·ª•: 01:00 = 1 gi·ªù, 00:30 = 30 ph√∫t)\n"
        "   - M·∫∑c ƒë·ªãnh: 01:00 (1 gi·ªù) cho ng√†y th∆∞·ªùng\n"
        "   - L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m: 00:00\n"
        "   - L·ªói: \"Th·ªùi gian ngh·ªâ ph·∫£i ·ªü ƒë·ªãnh d·∫°ng HH:MM\"\n\n"
        "5. **Gi·ªù ƒë·ªëi ·ª©ng:**\n"
        "   - T·∫•t c·∫£ c√°c tr∆∞·ªùng ƒë·ªëi ·ª©ng: ƒê·ªãnh d·∫°ng HH:MM\n"
        "   - M·∫∑c ƒë·ªãnh: 00:00 (kh√¥ng c√≥ ƒë·ªëi ·ª©ng)\n"
        "   - L·ªói: \"Gi·ªù ƒë·ªëi ·ª©ng ph·∫£i ·ªü ƒë·ªãnh d·∫°ng HH:MM\"\n\n"
        "6. **Tr√πng l·∫∑p:**\n"
        "   - Kh√¥ng th·ªÉ ch·∫•m c√¥ng 2 l·∫ßn trong 1 ng√†y\n"
        "   - L·ªói: \"B·∫°n ƒë√£ ch·∫•m c√¥ng cho ng√†y n√†y r·ªìi, kh√¥ng th·ªÉ ch·∫•m c√¥ng 2 l·∫ßn trong 1 ng√†y.\"\n"
        "   - **Gi·∫£i ph√°p:** X√≥a b·∫£n ghi c≈© ho·∫∑c s·ª≠a b·∫£n ghi c≈©\n\n"
        "**VALIDATION CHO ƒêƒÇNG K√ù NGH·ªà PH√âP:**\n\n"
        "1. **Lo·∫°i ƒë∆°n:**\n"
        "   - B·∫Øt bu·ªôc ph·∫£i ch·ªçn\n"
        "   - L·ª±a ch·ªçn: Ngh·ªâ ph√©p, ƒêi tr·ªÖ/V·ªÅ s·ªõm, Ngh·ªâ 30 ph√∫t\n\n"
        "2. **L√Ω do ngh·ªâ ph√©p:**\n"
        "   - B·∫Øt bu·ªôc ph·∫£i nh·∫≠p (kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng)\n"
        "   - Ph·∫£i m√¥ t·∫£ chi ti·∫øt, r√µ r√†ng\n"
        "   - L·ªói: \"Vui l√≤ng nh·∫≠p l√Ω do ngh·ªâ ph√©p\"\n\n"
        "3. **Lo·∫°i (n·∫øu ch·ªçn ƒêi tr·ªÖ/V·ªÅ s·ªõm):**\n"
        "   - B·∫Øt bu·ªôc ph·∫£i ch·ªçn: ƒêi tr·ªÖ ho·∫∑c V·ªÅ s·ªõm\n"
        "   - L·ªói: \"Vui l√≤ng ch·ªçn lo·∫°i ƒëi tr·ªÖ/v·ªÅ s·ªõm\"\n\n"
        "4. **Ca l√†m vi·ªác:**\n"
        "   - B·∫Øt bu·ªôc ph·∫£i ch·ªçn\n"
        "   - L·ªói: \"Vui l√≤ng ch·ªçn ca l√†m vi·ªác\"\n\n"
        "5. **T·ª´ ng√†y/ƒê·∫øn ng√†y:**\n"
        "   - B·∫Øt bu·ªôc ph·∫£i ch·ªçn ng√†y v√† gi·ªù\n"
        "   - ƒê·∫øn ng√†y ph·∫£i >= T·ª´ ng√†y\n"
        "   - L·ªói: \"Vui l√≤ng ch·ªçn ƒë·∫ßy ƒë·ªß t·ª´ ng√†y v√† ƒë·∫øn ng√†y\"\n\n"
        "6. **S·ªë ng√†y ngh·ªâ:**\n"
        "   - B·∫Øt bu·ªôc ph·∫£i nh·∫≠p (√≠t nh·∫•t 1 tr∆∞·ªùng ph·∫£i > 0)\n"
        "   - Ph·∫£i l√† b·ªôi s·ªë c·ªßa 0.5 (0.5, 1, 1.5, 2...)\n"
        "   - T·ªïng s·ªë ng√†y ngh·ªâ PH·∫¢I B·∫∞NG CH√çNH X√ÅC kho·∫£ng th·ªùi gian th·ª±c t·∫ø\n"
        "   - L·ªói: \"S·ªë ng√†y ngh·ªâ kh√¥ng kh·ªõp v·ªõi kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn\"\n"
        "   - **Gi·∫£i ph√°p:**\n"
        "     ‚Ä¢ T√≠nh l·∫°i s·ªë ng√†y ngh·ªâ theo ca l√†m vi·ªác\n"
        "     ‚Ä¢ N·ª≠a ng√†y s√°ng = 0.5, n·ª≠a ng√†y chi·ªÅu = 0.5, c·∫£ ng√†y = 1\n"
        "     ‚Ä¢ Nhi·ªÅu ng√†y: T√≠nh t·ªïng s·ªë ng√†y trong kho·∫£ng th·ªùi gian\n\n"
        "7. **File ƒë√≠nh k√®m:**\n"
        "   - Kh√¥ng b·∫Øt bu·ªôc, nh∆∞ng khuy·∫øn kh√≠ch\n"
        "   - ƒê·ªãnh d·∫°ng: PDF, JPG, JPEG, PNG, DOC, DOCX\n"
        "   - T·ªëi ƒëa 10MB m·ªói file\n"
        "   - L·ªói: \"File qu√° l·ªõn (t·ªëi ƒëa 10MB)\" ho·∫∑c \"ƒê·ªãnh d·∫°ng file kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£\"\n\n"
        "**C√ÅC L·ªñI TH∆Ø·ªúNG G·∫∂P V√Ä C√ÅCH X·ª¨ L√ù:**\n\n"
        "1. **L·ªói: \"B·∫°n ƒë√£ ch·∫•m c√¥ng cho ng√†y n√†y r·ªìi\"**\n"
        "   - **Nguy√™n nh√¢n:** ƒê√£ c√≥ b·∫£n ghi ch·∫•m c√¥ng cho ng√†y n√†y\n"
        "   - **Gi·∫£i ph√°p:**\n"
        "     ‚Ä¢ V√†o Dashboard ‚Üí T√¨m b·∫£n ghi c≈© ‚Üí Click icon **b√∫t** (‚úèÔ∏è) ƒë·ªÉ s·ª≠a\n"
        "     ‚Ä¢ Ho·∫∑c click icon **th√πng r√°c** (üóëÔ∏è) ƒë·ªÉ x√≥a r·ªìi t·∫°o m·ªõi\n"
        "     ‚Ä¢ **L∆∞u √Ω:** Ch·ªâ s·ª≠a/x√≥a ƒë∆∞·ª£c khi b·∫£n ghi ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát\n\n"
        "2. **L·ªói: \"S·ªë ng√†y ngh·ªâ kh√¥ng kh·ªõp v·ªõi kho·∫£ng th·ªùi gian\"**\n"
        "   - **Nguy√™n nh√¢n:** T·ªïng s·ªë ng√†y ngh·ªâ kh√¥ng b·∫±ng kho·∫£ng th·ªùi gian th·ª±c t·∫ø\n"
        "   - **Gi·∫£i ph√°p:**\n"
        "     ‚Ä¢ Ki·ªÉm tra l·∫°i **T·ª´ ng√†y** v√† **ƒê·∫øn ng√†y**\n"
        "     ‚Ä¢ T√≠nh l·∫°i s·ªë ng√†y ngh·ªâ:\n"
        "       - N·ª≠a ng√†y s√°ng (t·ª´ ƒë·∫ßu ca ƒë·∫øn 11:59) = 0.5 ng√†y\n"
        "       - N·ª≠a ng√†y chi·ªÅu (t·ª´ 12:00 ƒë·∫øn h·∫øt ca) = 0.5 ng√†y\n"
        "       - C·∫£ ng√†y (t·ª´ ƒë·∫ßu ca ƒë·∫øn h·∫øt ca) = 1 ng√†y\n"
        "       - Nhi·ªÅu ng√†y: ƒê·∫øm s·ªë ng√†y trong kho·∫£ng th·ªùi gian\n"
        "     ‚Ä¢ Nh·∫≠p l·∫°i s·ªë ng√†y ngh·ªâ cho ƒë√∫ng\n\n"
        "3. **L·ªói: \"Kh√¥ng th·ªÉ ch·∫•m c√¥ng cho ng√†y trong t∆∞∆°ng lai\"**\n"
        "   - **Nguy√™n nh√¢n:** ƒê√£ ch·ªçn ng√†y trong t∆∞∆°ng lai\n"
        "   - **Gi·∫£i ph√°p:** Ch·ªçn l·∫°i ng√†y trong qu√° kh·ª© ho·∫∑c h√¥m nay\n\n"
        "4. **L·ªói: \"Vui l√≤ng ch·ªçn ca l√†m vi·ªác h·ª£p l·ªá\"**\n"
        "   - **Nguy√™n nh√¢n:** Ch∆∞a ch·ªçn ca l√†m vi·ªác (tr·ª´ L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m)\n"
        "   - **Gi·∫£i ph√°p:** Ch·ªçn ca l√†m vi·ªác t·ª´ dropdown\n\n"
        "5. **L·ªói: \"File qu√° l·ªõn\"**\n"
        "   - **Nguy√™n nh√¢n:** File ƒë√≠nh k√®m > 10MB\n"
        "   - **Gi·∫£i ph√°p:**\n"
        "     ‚Ä¢ N√©n file ho·∫∑c chia nh·ªè file\n"
        "     ‚Ä¢ Ho·∫∑c upload file nh·ªè h∆°n 10MB\n\n"
        "6. **Kh√¥ng th·∫•y n√∫t/menu:**\n"
        "   - **Nguy√™n nh√¢n:** Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p\n"
        "   - **Gi·∫£i ph√°p:**\n"
        "     ‚Ä¢ Ki·ªÉm tra vai tr√≤ c·ªßa b·∫°n (Employee, Leader, Manager, Admin)\n"
        "     ‚Ä¢ Li√™n h·ªá Admin ƒë·ªÉ ƒë∆∞·ª£c c·∫•p quy·ªÅn\n\n"
        "7. **Ch·∫•m c√¥ng nh∆∞ng kh√¥ng t√≠nh tƒÉng ca:**\n"
        "   - **Nguy√™n nh√¢n:**\n"
        "     ‚Ä¢ Gi·ªù ra ch∆∞a v∆∞·ª£t qu√° gi·ªù ra ca\n"
        "     ‚Ä¢ Ho·∫∑c ƒë√£ nh·∫≠p gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca\n"
        "   - **Gi·∫£i ph√°p:**\n"
        "     ‚Ä¢ Ki·ªÉm tra l·∫°i gi·ªù v√†o/ra v√† ca l√†m vi·ªác\n"
        "     ‚Ä¢ Ki·ªÉm tra l·∫°i gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca\n\n"
        "8. **S·ªë ng√†y ngh·ªâ kh√¥ng ƒë√∫ng:**\n"
        "   - **Nguy√™n nh√¢n:** T√≠nh sai s·ªë ng√†y ngh·ªâ\n"
        "   - **Gi·∫£i ph√°p:**\n"
        "     ‚Ä¢ Xem l·∫°i h∆∞·ªõng d·∫´n t√≠nh s·ªë ng√†y ngh·ªâ ·ªü tr√™n\n"
        "     ‚Ä¢ S·ª≠ d·ª•ng c√¥ng c·ª• t√≠nh t·ª± ƒë·ªông c·ªßa h·ªá th·ªëng (√¥ **T·ªïng**)\n"
        "     ‚Ä¢ H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√≠nh v√† hi·ªÉn th·ªã s·ªë ng√†y c·∫ßn nh·∫≠p trong √¥ **T·ªïng**\n"
        "     ‚Ä¢ Ch·ªâ c·∫ßn nh·∫≠p ƒë√∫ng s·ªë ng√†y hi·ªÉn th·ªã trong √¥ **T·ªïng**\n\n"
        "9. **Kh√¥ng hi·ªÉu c√°ch t√≠nh s·ªë ng√†y ngh·ªâ:**\n"
        "   - **Gi·∫£i ph√°p:**\n"
        "     ‚Ä¢ H·ªá th·ªëng t·ª± ƒë·ªông t√≠nh d·ª±a tr√™n ca l√†m vi·ªác v√† kho·∫£ng th·ªùi gian\n"
        "     ‚Ä¢ Xem √¥ **T·ªïng** ƒë·ªÉ bi·∫øt s·ªë ng√†y c·∫ßn nh·∫≠p\n"
        "     ‚Ä¢ **Quy t·∫Øc:**\n"
        "       - N·ª≠a ng√†y s√°ng (t·ª´ ƒë·∫ßu ca ƒë·∫øn 11:59) = 0.5 ng√†y\n"
        "       - N·ª≠a ng√†y chi·ªÅu (t·ª´ 12:00 ƒë·∫øn h·∫øt ca) = 0.5 ng√†y\n"
        "       - C·∫£ ng√†y (t·ª´ ƒë·∫ßu ca ƒë·∫øn h·∫øt ca) = 1 ng√†y\n"
        "       - Nhi·ªÅu ng√†y: ƒê·∫øm s·ªë ng√†y trong kho·∫£ng th·ªùi gian\n\n"
        "10. **Kh√¥ng hi·ªÉu ch√≠nh s√°ch m·∫π <12 th√°ng:**\n"
        "    - **Gi·∫£i ph√°p:**\n"
        "      ‚Ä¢ Ch·ªâ √°p d·ª•ng cho nh√¢n vi√™n n·ªØ c√≥ con <12 th√°ng\n"
        "      ‚Ä¢ Ch·ªâ c·∫ßn l√†m 7 gi·ªù/ng√†y l√† ƒë·ªß c√¥ng (thay v√¨ 8 gi·ªù)\n"
        "      ‚Ä¢ ƒê∆∞·ª£c +1h bonus v√†o gi·ªù c√¥ng (l√†m 7h ƒë∆∞·ª£c t√≠nh 8h)\n"
        "      ‚Ä¢ Ch·ªâ √°p d·ª•ng ca 1-4, ng√†y th∆∞·ªùng\n"
        "      ‚Ä¢ Kh√¥ng √°p d·ª•ng cu·ªëi tu·∫ßn/l·ªÖ\n"
        "      ‚Ä¢ H·ªá th·ªëng t·ª± ƒë·ªông √°p d·ª•ng, kh√¥ng c·∫ßn c·∫•u h√¨nh g√¨ th√™m\n\n"
        "=== 21. QUY T·∫ÆC TR·∫¢ L·ªúI ===\n\n"
        "1. Lu√¥n h∆∞·ªõng d·∫´n T·ª™NG B∆Ø·ªöC M·ªòT, kh√¥ng b·ªè qua chi ti·∫øt n√†o\n"
        "2. Ch·ªâ r√µ V·ªä TR√ç c·ªßa t·ª´ng n√∫t, menu, tr∆∞·ªùng nh·∫≠p li·ªáu\n"
        "3. Gi·∫£i th√≠ch R√ï R√ÄNG t·ª´ng b∆∞·ªõc, kh√¥ng d√πng t·ª´ ng·ªØ m∆° h·ªì\n"
        "4. Khi ng∆∞·ªùi d√πng h·ªèi v·ªÅ m·ªôt tr∆∞·ªùng c·ª• th·ªÉ:\n"
        "   - Gi·∫£i th√≠ch CHI TI·∫æT tr∆∞·ªùng ƒë√≥ l√† g√¨\n"
        "   - C√°ch ƒëi·ªÅn/nh·∫≠p nh∆∞ th·∫ø n√†o\n"
        "   - C√≥ b·∫Øt bu·ªôc hay kh√¥ng\n"
        "   - C√°c l∆∞u √Ω quan tr·ªçng\n"
        "   - V√≠ d·ª• c·ª• th·ªÉ\n"
        "5. Khi ng∆∞·ªùi d√πng g·∫∑p l·ªói:\n"
        "   - Gi·∫£i th√≠ch nguy√™n nh√¢n l·ªói\n"
        "   - ƒê∆∞a ra gi·∫£i ph√°p C·ª§ TH·ªÇ t·ª´ng b∆∞·ªõc\n"
        "   - H∆∞·ªõng d·∫´n c√°ch s·ª≠a l·ªói\n"
        "6. N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ t√≠nh nƒÉng kh√¥ng t·ªìn t·∫°i, tr·∫£ l·ªùi trung th·ª±c: \"M√¨nh ch∆∞a th·∫•y t√≠nh nƒÉng n√†y tr√™n giao di·ªán hi·ªán t·∫°i. B·∫°n vui l√≤ng ki·ªÉm tra l·∫°i menu ho·∫∑c li√™n h·ªá Admin ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.\"\n"
        "7. Lu√¥n nh·∫Øc ng∆∞·ªùi d√πng ki·ªÉm tra quy·ªÅn truy c·∫≠p n·∫øu h·ªç kh√¥ng th·∫•y n√∫t/menu n√†o ƒë√≥\n"
        "8. N·∫øu c√≥ nhi·ªÅu c√°ch th·ª±c hi·ªán, li·ªát k√™ T·∫§T C·∫¢ c√°c c√°ch\n"
        "9. Lu√¥n th√™m **L∆∞u √Ω** n·∫øu c√≥ ƒëi·ªÅu ki·ªán ƒë·∫∑c bi·ªát ho·∫∑c quy t·∫Øc quan tr·ªçng\n"
        "10. Khi ng∆∞·ªùi d√πng h·ªèi s√¢u v·ªÅ m·ªôt v·∫•n ƒë·ªÅ:\n"
        "    - T·∫≠p trung v√†o v·∫•n ƒë·ªÅ h·ªç ƒëang h·ªèi\n"
        "    - Gi·∫£i th√≠ch CHI TI·∫æT, S√ÇU H∆†N\n"
        "    - ƒê∆∞a ra v√≠ d·ª• c·ª• th·ªÉ\n"
        "    - Li√™n h·ªá v·ªõi c√°c tr∆∞·ªùng h·ª£p t∆∞∆°ng t·ª±\n"
        "11. Lu√¥n ∆∞u ti√™n h∆∞·ªõng d·∫´n TH·ª∞C H√ÄNH, gi√∫p ng∆∞·ªùi d√πng ho√†n th√†nh ƒë∆∞·ª£c ngay\n"
        "12. N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ c√°ch t√≠nh to√°n:\n"
        "    - Gi·∫£i th√≠ch c√¥ng th·ª©c t√≠nh\n"
        "    - ƒê∆∞a ra v√≠ d·ª• c·ª• th·ªÉ v·ªõi s·ªë li·ªáu\n"
        "    - H∆∞·ªõng d·∫´n c√°ch ki·ªÉm tra k·∫øt qu·∫£\n\n"
        "=== 12. CHUY·ªÇN VAI TR√í (D√†nh cho ng∆∞·ªùi c√≥ nhi·ªÅu vai tr√≤) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Dashboard** (Trang ch·ªß)\n"
        "2. ·ªû g√≥c tr√™n b√™n ph·∫£i, b·∫°n s·∫Ω th·∫•y **B·ªô chuy·ªÉn vai tr√≤** (dropdown ho·∫∑c button group)\n"
        "3. Click v√†o dropdown vai tr√≤ hi·ªán t·∫°i (v√≠ d·ª•: \"Employee\", \"Leader\", \"Manager\", \"Admin\")\n"
        "4. Ch·ªçn vai tr√≤ mu·ªën chuy·ªÉn sang t·ª´ danh s√°ch\n"
        "5. H·ªá th·ªëng s·∫Ω:\n"
        "   - Chuy·ªÉn ƒë·ªïi vai tr√≤ ngay l·∫≠p t·ª©c\n"
        "   - C·∫≠p nh·∫≠t menu sidebar theo vai tr√≤ m·ªõi\n"
        "   - C·∫≠p nh·∫≠t quy·ªÅn truy c·∫≠p v√† d·ªØ li·ªáu hi·ªÉn th·ªã\n"
        "   - Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng\n\n"
        "**L∆∞u √Ω:**\n"
        "- Ch·ªâ c√≥ th·ªÉ chuy·ªÉn sang c√°c vai tr√≤ m√† b·∫°n ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn\n"
        "- M·ªói l·∫ßn chuy·ªÉn vai tr√≤ c√≥ th·ªÉ c√≥ gi·ªõi h·∫°n th·ªùi gian (v√≠ d·ª•: 30 gi√¢y) ƒë·ªÉ tr√°nh spam\n"
        "- Vai tr√≤ hi·ªán t·∫°i s·∫Ω ƒë∆∞·ª£c l∆∞u trong session v√† √°p d·ª•ng cho t·∫•t c·∫£ c√°c trang\n"
        "- Khi chuy·ªÉn vai tr√≤, b·∫°n s·∫Ω th·∫•y menu v√† d·ªØ li·ªáu t∆∞∆°ng ·ª©ng v·ªõi vai tr√≤ m·ªõi\n"
        "- N·∫øu kh√¥ng th·∫•y b·ªô chuy·ªÉn vai tr√≤, c√≥ nghƒ©a l√† b·∫°n ch·ªâ c√≥ 1 vai tr√≤ duy nh·∫•t\n\n"
        "=== 13. QU·∫¢N L√ù NG∆Ø·ªúI D√ôNG (Ch·ªâ Admin) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o menu **Qu·∫£n l√Ω ng∆∞·ªùi d√πng** ·ªü sidebar b√™n tr√°i (ch·ªâ Admin m·ªõi th·∫•y)\n"
        "2. Trang s·∫Ω hi·ªÉn th·ªã b·∫£ng danh s√°ch t·∫•t c·∫£ ng∆∞·ªùi d√πng v·ªõi c√°c c·ªôt:\n"
        "   - T√™n\n"
        "   - M√£ nh√¢n vi√™n\n"
        "   - Email\n"
        "   - Ph√≤ng ban\n"
        "   - Vai tr√≤\n"
        "   - Tr·∫°ng th√°i (Ho·∫°t ƒë·ªông/Kh√¥ng ho·∫°t ƒë·ªông)\n"
        "   - Ch√≠nh s√°ch m·∫π <12 th√°ng (n·∫øu c√≥)\n"
        "   - H√†nh ƒë·ªông (S·ª≠a, X√≥a)\n"
        "3. S·ª≠ d·ª•ng c√°c b·ªô l·ªçc ·ªü tr√™n b·∫£ng:\n"
        "   - **T√¨m ki·∫øm:** Nh·∫≠p t√™n ho·∫∑c m√£ nh√¢n vi√™n\n"
        "   - **Ph√≤ng ban:** Ch·ªçn ph√≤ng ban t·ª´ dropdown\n"
        "   - **Ch√≠nh s√°ch m·∫π:** L·ªçc theo nh√¢n vi√™n ƒëang √°p d·ª•ng ch√≠nh s√°ch m·∫π <12 th√°ng\n"
        "4. Click **√Åp d·ª•ng b·ªô l·ªçc** ƒë·ªÉ xem k·∫øt qu·∫£\n"
        "5. **T·∫°o ng∆∞·ªùi d√πng m·ªõi:**\n"
        "   - Click n√∫t **T·∫°o ng∆∞·ªùi d√πng m·ªõi** (m√†u xanh)\n"
        "   - ƒêi·ªÅn c√°c th√¥ng tin:\n"
        "     ‚Ä¢ **T√™n:** T√™n ƒë·∫ßy ƒë·ªß\n"
        "     ‚Ä¢ **M√£ nh√¢n vi√™n:** M√£ nh√¢n vi√™n (unique)\n"
        "     ‚Ä¢ **Email:** Email ƒëƒÉng nh·∫≠p\n"
        "     ‚Ä¢ **M·∫≠t kh·∫©u:** M·∫≠t kh·∫©u ban ƒë·∫ßu\n"
        "     ‚Ä¢ **Ph√≤ng ban:** Ch·ªçn ph√≤ng ban t·ª´ dropdown\n"
        "     ‚Ä¢ **Vai tr√≤:** Ch·ªçn m·ªôt ho·∫∑c nhi·ªÅu vai tr√≤ (Employee, Leader, Manager, Admin)\n"
        "     ‚Ä¢ **Tr·∫°ng th√°i:** Ho·∫°t ƒë·ªông ho·∫∑c Kh√¥ng ho·∫°t ƒë·ªông\n"
        "     ‚Ä¢ **Ch√≠nh s√°ch m·∫π <12 th√°ng:** (N·∫øu √°p d·ª•ng) Ch·ªçn checkbox v√† ƒëi·ªÅn ng√†y b·∫Øt ƒë·∫ßu/k·∫øt th√∫c\n"
        "   - Click **L∆∞u** ƒë·ªÉ t·∫°o\n\n"
        "6. **S·ª≠a ng∆∞·ªùi d√πng:**\n"
        "   - Click icon **b√∫t** (‚úèÔ∏è) ho·∫∑c n√∫t **S·ª≠a** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "   - S·ª≠a c√°c th√¥ng tin c·∫ßn thay ƒë·ªïi (gi·ªëng nh∆∞ t·∫°o m·ªõi)\n"
        "   - Click **C·∫≠p nh·∫≠t** ƒë·ªÉ l∆∞u\n\n"
        "7. **X√≥a ng∆∞·ªùi d√πng:**\n"
        "   - Click icon **th√πng r√°c** (üóëÔ∏è) ho·∫∑c n√∫t **X√≥a** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "   - X√°c nh·∫≠n x√≥a trong popup\n"
        "   - **L∆∞u √Ω:** X√≥a ng∆∞·ªùi d√πng l√† soft delete (·∫©n kh·ªèi danh s√°ch, kh√¥ng x√≥a d·ªØ li·ªáu)\n\n"
        "8. **K√≠ch ho·∫°t/V√¥ hi·ªáu h√≥a ng∆∞·ªùi d√πng:**\n"
        "   - Click icon **toggle** (üîÑ) ho·∫∑c n√∫t **K√≠ch ho·∫°t/V√¥ hi·ªáu h√≥a** ·ªü c·ªôt **H√†nh ƒë·ªông** ho·∫∑c c·ªôt **Tr·∫°ng th√°i**\n"
        "   - **K√≠ch ho·∫°t:** Ng∆∞·ªùi d√πng c√≥ th·ªÉ ƒëƒÉng nh·∫≠p v√† s·ª≠ d·ª•ng h·ªá th·ªëng b√¨nh th∆∞·ªùng\n"
        "   - **V√¥ hi·ªáu h√≥a:** Ng∆∞·ªùi d√πng s·∫Ω kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p (t√†i kho·∫£n b·ªã kh√≥a t·∫°m th·ªùi)\n"
        "   - Tr·∫°ng th√°i s·∫Ω hi·ªÉn th·ªã trong c·ªôt **Tr·∫°ng th√°i**: \"Ho·∫°t ƒë·ªông\" (m√†u xanh) ho·∫∑c \"Kh√¥ng ho·∫°t ƒë·ªông\" (m√†u ƒë·ªè/x√°m)\n"
        "   - C√≥ th·ªÉ k√≠ch ho·∫°t l·∫°i b·∫•t c·ª© l√∫c n√†o b·∫±ng c√°ch click toggle m·ªôt l·∫ßn n·ªØa\n"
        "   - **L∆∞u √Ω:**\n"
        "     ‚Ä¢ V√¥ hi·ªáu h√≥a kh√¥ng x√≥a d·ªØ li·ªáu, ch·ªâ ngƒÉn ƒëƒÉng nh·∫≠p\n"
        "     ‚Ä¢ D·ªØ li·ªáu ch·∫•m c√¥ng v√† ƒë∆°n ngh·ªâ ph√©p v·∫´n ƒë∆∞·ª£c gi·ªØ nguy√™n\n"
        "     ‚Ä¢ D√πng ƒë·ªÉ t·∫°m th·ªùi kh√≥a t√†i kho·∫£n (v√≠ d·ª•: nh√¢n vi√™n ngh·ªâ vi·ªác t·∫°m th·ªùi)\n\n"
        "**L∆∞u √Ω:**\n"
        "- Ch·ªâ Admin m·ªõi c√≥ quy·ªÅn truy c·∫≠p trang n√†y\n"
        "- M√£ nh√¢n vi√™n ph·∫£i unique (kh√¥ng tr√πng v·ªõi ng∆∞·ªùi d√πng kh√°c)\n"
        "- Email ph·∫£i unique (kh√¥ng tr√πng v·ªõi ng∆∞·ªùi d√πng kh√°c)\n"
        "- C√≥ th·ªÉ g√°n nhi·ªÅu vai tr√≤ cho m·ªôt ng∆∞·ªùi d√πng (v√≠ d·ª•: v·ª´a l√† Leader v·ª´a l√† Manager)\n"
        "- Ch√≠nh s√°ch m·∫π <12 th√°ng: Ch·ªâ √°p d·ª•ng cho nh√¢n vi√™n n·ªØ c√≥ con <12 th√°ng, cho ph√©p l√†m 7h/ng√†y thay v√¨ 8h\n\n"
        "=== 14. QU·∫¢N L√ù PH√íNG BAN (Ch·ªâ Admin) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o menu **Qu·∫£n l√Ω ph√≤ng ban** ·ªü sidebar b√™n tr√°i (ch·ªâ Admin m·ªõi th·∫•y)\n"
        "2. Trang s·∫Ω hi·ªÉn th·ªã b·∫£ng danh s√°ch t·∫•t c·∫£ ph√≤ng ban v·ªõi c√°c c·ªôt:\n"
        "   - T√™n ph√≤ng ban\n"
        "   - File Timesheet (Google Sheet)\n"
        "   - Tr·∫°ng th√°i (Ho·∫°t ƒë·ªông/Kh√¥ng ho·∫°t ƒë·ªông)\n"
        "   - H√†nh ƒë·ªông (S·ª≠a, X√≥a)\n"
        "3. **Th√™m ph√≤ng ban m·ªõi:**\n"
        "   - Click n√∫t **Th√™m ph√≤ng ban** (m√†u xanh)\n"
        "   - ƒêi·ªÅn c√°c th√¥ng tin:\n"
        "     ‚Ä¢ **T√™n ph√≤ng ban:** T√™n ph√≤ng ban (v√≠ d·ª•: \"SCOPE\", \"YORK\")\n"
        "     ‚Ä¢ **File Timesheet:** T√™n file Google Sheet t∆∞∆°ng ·ª©ng (v√≠ d·ª•: \"DMI-SCOPE-Timesheet\")\n"
        "   - Click **L∆∞u** ƒë·ªÉ t·∫°o\n\n"
        "4. **S·ª≠a ph√≤ng ban:**\n"
        "   - Click icon **b√∫t** (‚úèÔ∏è) ho·∫∑c n√∫t **S·ª≠a** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "   - S·ª≠a t√™n ph√≤ng ban ho·∫∑c file timesheet\n"
        "   - Click **C·∫≠p nh·∫≠t** ƒë·ªÉ l∆∞u\n\n"
        "5. **X√≥a ph√≤ng ban:**\n"
        "   - Click icon **th√πng r√°c** (üóëÔ∏è) ho·∫∑c n√∫t **X√≥a** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "   - X√°c nh·∫≠n x√≥a trong popup\n"
        "   - **L∆∞u √Ω:** Ch·ªâ x√≥a ƒë∆∞·ª£c khi kh√¥ng c√≤n ng∆∞·ªùi d√πng n√†o thu·ªôc ph√≤ng ban ƒë√≥\n\n"
        "**L∆∞u √Ω:**\n"
        "- Ch·ªâ Admin m·ªõi c√≥ quy·ªÅn truy c·∫≠p trang n√†y\n"
        "- T√™n ph√≤ng ban ph·∫£i unique (kh√¥ng tr√πng)\n"
        "- File Timesheet d√πng ƒë·ªÉ mapping v·ªõi Google Sheet khi c·∫≠p nh·∫≠t d·ªØ li·ªáu ch·∫•m c√¥ng\n"
        "- Ph√≤ng ban ƒë∆∞·ª£c d√πng ƒë·ªÉ ph√¢n quy·ªÅn v√† l·ªçc d·ªØ li·ªáu\n\n"
        "=== 15. QU·∫¢N L√ù NG√ÄY L·ªÑ (Ch·ªâ Admin) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. Click v√†o menu **Qu·∫£n l√Ω ng√†y l·ªÖ** ·ªü sidebar b√™n tr√°i (ch·ªâ Admin m·ªõi th·∫•y)\n"
        "2. Trang s·∫Ω hi·ªÉn th·ªã b·∫£ng danh s√°ch t·∫•t c·∫£ ng√†y l·ªÖ v·ªõi c√°c c·ªôt:\n"
        "   - Ng√†y\n"
        "   - Lo·∫°i l·ªÖ (L·ªÖ Vi·ªát Nam / L·ªÖ Nh·∫≠t B·∫£n)\n"
        "   - T√™n l·ªÖ\n"
        "   - M√¥ t·∫£\n"
        "   - H√†nh ƒë·ªông (S·ª≠a, X√≥a)\n"
        "3. **Th√™m ng√†y l·ªÖ m·ªõi:**\n"
        "   - Click n√∫t **Th√™m ng√†y l·ªÖ** (m√†u xanh)\n"
        "   - ƒêi·ªÅn c√°c th√¥ng tin:\n"
        "     ‚Ä¢ **Ng√†y:** Ch·ªçn ng√†y t·ª´ calendar (v√≠ d·ª•: 01/01/2024)\n"
        "     ‚Ä¢ **Lo·∫°i l·ªÖ:** Ch·ªçn \"L·ªÖ Vi·ªát Nam\" ho·∫∑c \"L·ªÖ Nh·∫≠t B·∫£n\"\n"
        "     ‚Ä¢ **T√™n l·ªÖ:** T√™n ng√†y l·ªÖ (v√≠ d·ª•: \"T·∫øt D∆∞∆°ng l·ªãch\", \"Ng√†y Qu·ªëc kh√°nh\")\n"
        "     ‚Ä¢ **M√¥ t·∫£:** M√¥ t·∫£ chi ti·∫øt (kh√¥ng b·∫Øt bu·ªôc)\n"
        "   - Click **L∆∞u** ƒë·ªÉ t·∫°o\n\n"
        "4. **S·ª≠a ng√†y l·ªÖ:**\n"
        "   - Click icon **b√∫t** (‚úèÔ∏è) ho·∫∑c n√∫t **S·ª≠a** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "   - S·ª≠a c√°c th√¥ng tin c·∫ßn thay ƒë·ªïi\n"
        "   - Click **C·∫≠p nh·∫≠t** ƒë·ªÉ l∆∞u\n\n"
        "5. **X√≥a ng√†y l·ªÖ:**\n"
        "   - Click icon **th√πng r√°c** (üóëÔ∏è) ho·∫∑c n√∫t **X√≥a** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "   - X√°c nh·∫≠n x√≥a trong popup\n\n"
        "**L∆∞u √Ω:**\n"
        "- Ch·ªâ Admin m·ªõi c√≥ quy·ªÅn truy c·∫≠p trang n√†y\n"
        "- Ng√†y l·ªÖ Vi·ªát Nam: N·∫øu kh√¥ng ƒëi l√†m, t·ª± ƒë·ªông ƒë∆∞·ª£c 8h c√¥ng (kh√¥ng c·∫ßn ch·∫•m c√¥ng)\n"
        "  N·∫øu c√≥ ƒëi l√†m, t√≠nh nh∆∞ ng√†y th∆∞·ªùng + tƒÉng ca\n"
        "- Ng√†y l·ªÖ Nh·∫≠t B·∫£n: T√≠nh gi·ªù c√¥ng th∆∞·ªùng v√† tƒÉng ca nh∆∞ ng√†y th∆∞·ªùng\n"
        "- C·∫ßn c·∫•u h√¨nh ƒë·∫ßy ƒë·ªß ng√†y l·ªÖ cho nƒÉm hi·ªán t·∫°i tr∆∞·ªõc khi ch·∫°y b·∫£ng ch·∫•m c√¥ng\n"
        "- H·ªá th·ªëng s·∫Ω c·∫£nh b√°o n·∫øu ch∆∞a c·∫•u h√¨nh ng√†y l·ªÖ cho nƒÉm hi·ªán t·∫°i\n\n"
        "=== 19. QUY TR√åNH PH√ä DUY·ªÜT CHI TI·∫æT ===\n\n"
        "**QUY TR√åNH PH√ä DUY·ªÜT CH·∫§M C√îNG:**\n\n"
        "1. **Nh√¢n vi√™n (Employee)** t·∫°o b·∫£n ghi ch·∫•m c√¥ng ‚Üí Tr·∫°ng th√°i: **pending**\n"
        "2. **Leader** ph√™ duy·ªát ‚Üí Tr·∫°ng th√°i: **pending_manager** (n·∫øu c√≥ Manager)\n"
        "   Ho·∫∑c ‚Üí Tr·∫°ng th√°i: **pending_admin** (n·∫øu kh√¥ng c√≥ Manager)\n"
        "   Ho·∫∑c ‚Üí Tr·∫°ng th√°i: **approved** (n·∫øu kh√¥ng c√≥ Manager v√† Admin)\n"
        "3. **Manager** ph√™ duy·ªát ‚Üí Tr·∫°ng th√°i: **pending_admin** (n·∫øu c√≥ Admin)\n"
        "   Ho·∫∑c ‚Üí Tr·∫°ng th√°i: **approved** (n·∫øu kh√¥ng c√≥ Admin)\n"
        "4. **Admin** ph√™ duy·ªát ‚Üí Tr·∫°ng th√°i: **approved** (ho√†n t·∫•t)\n\n"
        "**QUY TR√åNH PH√ä DUY·ªÜT ƒê∆†N NGH·ªà PH√âP:**\n\n"
        "1. **Nh√¢n vi√™n (Employee)** t·∫°o ƒë∆°n ngh·ªâ ph√©p ‚Üí Tr·∫°ng th√°i: **pending**\n"
        "2. **Leader** ph√™ duy·ªát ‚Üí Tr·∫°ng th√°i: **pending_manager** (n·∫øu c√≥ Manager)\n"
        "   Ho·∫∑c ‚Üí Tr·∫°ng th√°i: **pending_admin** (n·∫øu kh√¥ng c√≥ Manager)\n"
        "   Ho·∫∑c ‚Üí Tr·∫°ng th√°i: **approved** (n·∫øu kh√¥ng c√≥ Manager v√† Admin)\n"
        "3. **Manager** ph√™ duy·ªát ‚Üí Tr·∫°ng th√°i: **pending_admin** (n·∫øu c√≥ Admin)\n"
        "   Ho·∫∑c ‚Üí Tr·∫°ng th√°i: **approved** (n·∫øu kh√¥ng c√≥ Admin)\n"
        "4. **Admin** ph√™ duy·ªát ‚Üí Tr·∫°ng th√°i: **approved** (ho√†n t·∫•t)\n\n"
        "**L∆∞u √Ω:**\n"
        "- M·ªói c·∫•p ch·ªâ c√≥ th·ªÉ ph√™ duy·ªát b·∫£n ghi/ƒë∆°n ·ªü tr·∫°ng th√°i t∆∞∆°ng ·ª©ng\n"
        "- N·∫øu b·∫•t k·ª≥ c·∫•p n√†o t·ª´ ch·ªëi, tr·∫°ng th√°i chuy·ªÉn th√†nh **rejected**\n"
        "- Ng∆∞·ªùi t·∫°o c√≥ th·ªÉ s·ª≠a l·∫°i b·∫£n ghi/ƒë∆°n b·ªã t·ª´ ch·ªëi v√† g·ª≠i l·∫°i (tr·∫°ng th√°i quay v·ªÅ **pending**)\n"
        "- Ch·ªâ c√≥ th·ªÉ s·ª≠a/x√≥a khi b·∫£n ghi/ƒë∆°n ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát (tr·∫°ng th√°i **pending** ho·∫∑c **rejected**)\n"
        "- Admin c√≥ th·ªÉ ph√™ duy·ªát/t·ª´ ch·ªëi b·∫•t k·ª≥ b·∫£n ghi/ƒë∆°n n√†o ·ªü b·∫•t k·ª≥ tr·∫°ng th√°i n√†o\n\n"
        "=== 22. XU·∫§T PDF PHI·∫æU TƒÇNG CA ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o Dashboard ‚Üí T√¨m b·∫£n ghi ch·∫•m c√¥ng ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát (tr·∫°ng th√°i **approved**)\n"
        "2. Click icon **m·∫Øt** (üëÅÔ∏è) ƒë·ªÉ xem chi ti·∫øt b·∫£n ghi\n"
        "3. Trong trang chi ti·∫øt, click n√∫t **Xu·∫•t PDF** ho·∫∑c **Export PDF** (m√†u xanh, c√≥ icon file-pdf)\n"
        "4. File PDF s·∫Ω ƒë∆∞·ª£c t·∫£i v·ªÅ m√°y t√≠nh v·ªõi t√™n: `tangca_[T√™n]_[M√£NV]_[Ng√†y].pdf`\n"
        "5. PDF bao g·ªìm:\n"
        "   - Th√¥ng tin nh√¢n vi√™n (T√™n, M√£ NV, Ph√≤ng ban)\n"
        "   - Ng√†y ch·∫•m c√¥ng\n"
        "   - Gi·ªù v√†o/ra, Ca l√†m vi·ªác\n"
        "   - Gi·ªù c√¥ng th∆∞·ªùng, TƒÉng ca tr∆∞·ªõc 22h, TƒÉng ca sau 22h\n"
        "   - Ch·ªØ k√Ω c·ªßa Leader v√† Manager (n·∫øu ƒë√£ ph√™ duy·ªát)\n"
        "   - Ng√†y ph√™ duy·ªát\n\n"
        "**XU·∫§T PDF H√ÄNG LO·∫†T (BULK EXPORT):**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o Dashboard ‚Üí S·ª≠ d·ª•ng b·ªô l·ªçc ƒë·ªÉ ch·ªçn c√°c b·∫£n ghi mu·ªën xu·∫•t PDF\n"
        "2. Ch·ªçn nhi·ªÅu b·∫£n ghi b·∫±ng c√°ch:\n"
        "   - Click checkbox ·ªü ƒë·∫ßu m·ªói d√≤ng (n·∫øu c√≥)\n"
        "   - Ho·∫∑c ch·ªçn t·∫•t c·∫£ b·∫±ng checkbox \"Ch·ªçn t·∫•t c·∫£\" (n·∫øu c√≥)\n"
        "3. Click n√∫t **Xu·∫•t PDF h√†ng lo·∫°t** ho·∫∑c **Export Bulk PDF** (m√†u xanh, c√≥ icon file-pdf)\n"
        "4. H·ªá th·ªëng s·∫Ω:\n"
        "   - T·∫°o file ZIP ch·ª©a t·∫•t c·∫£ c√°c file PDF\n"
        "   - M·ªói file PDF t∆∞∆°ng ·ª©ng v·ªõi 1 b·∫£n ghi ch·∫•m c√¥ng\n"
        "   - File ZIP c√≥ t√™n: `tangca_bulk_[Ng√†y xu·∫•t].zip`\n"
        "5. T·∫£i file ZIP v·ªÅ m√°y t√≠nh v√† gi·∫£i n√©n ƒë·ªÉ xem c√°c file PDF\n\n"
        "**L∆∞u √Ω:**\n"
        "- Ch·ªâ xu·∫•t ƒë∆∞·ª£c PDF cho b·∫£n ghi ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát (tr·∫°ng th√°i **approved**)\n"
        "- PDF c√≥ ch·ªØ k√Ω t·ª± ƒë·ªông t·ª´ database (n·∫øu ƒë√£ c√≥ ch·ªØ k√Ω)\n"
        "- Admin c√≥ th·ªÉ test ch·ªØ k√Ω tr√™n PDF b·∫±ng c√°ch click **Test ch·ªØ k√Ω** (n·∫øu c√≥)\n\n"
        "**TEST CH·ªÆ K√ù TR√äN PDF (Ch·ªâ Admin):**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o Dashboard ‚Üí T√¨m b·∫£n ghi ch·∫•m c√¥ng ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát\n"
        "2. Click icon **m·∫Øt** (üëÅÔ∏è) ƒë·ªÉ xem chi ti·∫øt b·∫£n ghi\n"
        "3. Trong trang chi ti·∫øt, t√¨m n√∫t **Test ch·ªØ k√Ω** ho·∫∑c **Test Signature PDF** (m√†u xanh, c√≥ icon file-pdf)\n"
        "4. Click n√∫t ƒë·ªÉ t·∫°o file PDF test v·ªõi ch·ªØ k√Ω\n"
        "5. File PDF s·∫Ω ƒë∆∞·ª£c t·∫£i v·ªÅ v·ªõi ch·ªØ k√Ω hi·ªÉn th·ªã ƒë·ªÉ ki·ªÉm tra\n"
        "6. Ki·ªÉm tra:\n"
        "   - Ch·ªØ k√Ω c√≥ hi·ªÉn th·ªã ƒë√∫ng v·ªã tr√≠ kh√¥ng\n"
        "   - Ch·ªØ k√Ω c√≥ r√µ r√†ng, kh√¥ng b·ªã m·ªù kh√¥ng\n"
        "   - K√≠ch th∆∞·ªõc ch·ªØ k√Ω c√≥ ph√π h·ª£p kh√¥ng\n"
        "7. N·∫øu ch∆∞a h√†i l√≤ng, quay l·∫°i **C√†i ƒë·∫∑t** ‚Üí **Ch·ªØ k√Ω c√° nh√¢n** ƒë·ªÉ ch·ªânh s·ª≠a l·∫°i\n\n"
        "**L∆∞u √Ω:**\n"
        "- Test ch·ªØ k√Ω ch·ªâ d√†nh cho Admin ƒë·ªÉ ki·ªÉm tra ch·∫•t l∆∞·ª£ng ch·ªØ k√Ω tr√™n PDF\n"
        "- PDF test s·∫Ω hi·ªÉn th·ªã ch·ªØ k√Ω gi·ªëng nh∆∞ PDF th·ª±c t·∫ø\n"
        "- C√≥ th·ªÉ test nhi·ªÅu l·∫ßn ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªØ k√Ω hi·ªÉn th·ªã ƒë√∫ng\n\n"
        "- Xu·∫•t h√†ng lo·∫°t c√≥ th·ªÉ m·∫•t th·ªùi gian n·∫øu ch·ªçn nhi·ªÅu b·∫£n ghi\n"
        "- File ZIP c√≥ th·ªÉ l·ªõn n·∫øu xu·∫•t nhi·ªÅu PDF, c·∫ßn ƒë·∫£m b·∫£o c√≥ ƒë·ªß dung l∆∞·ª£ng\n\n"
        "=== 23. T·∫¢I XU·ªêNG/T·∫¢I L√äN NG∆Ø·ªúI D√ôNG (Ch·ªâ Admin) ===\n\n"
        "**T·∫¢I XU·ªêNG DANH S√ÅCH NG∆Ø·ªúI D√ôNG:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Qu·∫£n l√Ω ng∆∞·ªùi d√πng** ‚Üí Click n√∫t **T·∫£i Excel** ho·∫∑c **Download** (m√†u xanh, c√≥ icon download)\n"
        "2. File Excel s·∫Ω ƒë∆∞·ª£c t·∫£i v·ªÅ v·ªõi t√™n `users_YYYYMMDD.xlsx`\n"
        "3. File Excel ch·ª©a c√°c c·ªôt:\n"
        "   - M√£ NV\n"
        "   - H·ªç v√† T√™n\n"
        "   - Ph√≤ng Ban\n"
        "   - Vai Tr√≤\n"
        "   - Email\n"
        "   - (Kh√¥ng c√≥ m·∫≠t kh·∫©u - ƒë·ªÉ b·∫£o m·∫≠t)\n\n"
        "**T·∫¢I L√äN NG∆Ø·ªúI D√ôNG T·ª™ FILE:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Qu·∫£n l√Ω ng∆∞·ªùi d√πng** ‚Üí Click n√∫t **T·∫£i l√™n ng∆∞·ªùi d√πng** ho·∫∑c **Upload** (m√†u xanh, c√≥ icon upload)\n"
        "2. Ch·ªçn file t·ª´ m√°y t√≠nh:\n"
        "   - **ƒê·ªãnh d·∫°ng TXT:** M·ªói d√≤ng 1 nh√¢n vi√™n, format: `M√£ NV|H·ªç v√† T√™n|Ph√≤ng Ban|Vai Tr√≤|Email|M·∫≠t kh·∫©u`\n"
        "     V√≠ d·ª•: `1395|Nguy·ªÖn VƒÉn A|OFFICE|EMPLOYEE|email@dmi.com|123456`\n"
        "   - **ƒê·ªãnh d·∫°ng XLSX:**\n"
        "     ‚Ä¢ C·ªôt A: M√£ NV\n"
        "     ‚Ä¢ C·ªôt B: H·ªç v√† T√™n\n"
        "     ‚Ä¢ C·ªôt C: Ph√≤ng Ban\n"
        "     ‚Ä¢ C·ªôt D: Vai Tr√≤ (nhi·ªÅu vai tr√≤ c√°ch nhau b·∫±ng d·∫•u ph·∫©y: `EMPLOYEE,TEAM_LEADER`)\n"
        "     ‚Ä¢ C·ªôt E: Email (t√πy ch·ªçn, c√≥ th·ªÉ ƒë·ªÉ tr·ªëng)\n"
        "     ‚Ä¢ C·ªôt F: M·∫≠t kh·∫©u (t√πy ch·ªçn, c√≥ th·ªÉ ƒë·ªÉ tr·ªëng)\n"
        "     ‚Ä¢ H√†ng ƒë·∫ßu ti√™n c√≥ th·ªÉ l√† header (s·∫Ω t·ª± ƒë·ªông b·ªè qua)\n"
        "3. Click **T·∫£i l√™n** ho·∫∑c **Upload**\n"
        "4. H·ªá th·ªëng s·∫Ω:\n"
        "   - Ki·ªÉm tra ƒë·ªãnh d·∫°ng file\n"
        "   - Ki·ªÉm tra tr√πng l·∫∑p (m√£ NV, email)\n"
        "   - Hi·ªÉn th·ªã danh s√°ch xung ƒë·ªôt (n·∫øu c√≥)\n"
        "   - Cho ph√©p gi·∫£i quy·∫øt xung ƒë·ªôt:\n"
        "     ‚Ä¢ **B·ªè qua** - Kh√¥ng t·∫°o ng∆∞·ªùi d√πng n√†y\n"
        "     ‚Ä¢ **Ghi ƒë√®** - C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng hi·ªán c√≥\n"
        "     ‚Ä¢ **T·∫°o m·ªõi** - T·∫°o ng∆∞·ªùi d√πng m·ªõi (n·∫øu c√≥ th·ªÉ)\n"
        "5. Click **X√°c nh·∫≠n** ƒë·ªÉ ho√†n t·∫•t\n"
        "6. H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã k·∫øt qu·∫£: S·ªë ng∆∞·ªùi d√πng ƒë√£ t·∫°o, s·ªë l·ªói, s·ªë xung ƒë·ªôt\n\n"
        "**L∆∞u √Ω:**\n"
        "- Email v√† M·∫≠t kh·∫©u l√† t√πy ch·ªçn (c√≥ th·ªÉ ƒë·ªÉ tr·ªëng)\n"
        "- N·∫øu kh√¥ng c√≥ email, ng∆∞·ªùi d√πng s·∫Ω kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p (c·∫ßn c·∫≠p nh·∫≠t sau)\n"
        "- N·∫øu kh√¥ng c√≥ m·∫≠t kh·∫©u, h·ªá th·ªëng s·∫Ω t·∫°o m·∫≠t kh·∫©u m·∫∑c ƒë·ªãnh (c·∫ßn ƒë·ªïi sau khi ƒëƒÉng nh·∫≠p)\n"
        "- Nhi·ªÅu vai tr√≤ c√°ch nhau b·∫±ng d·∫•u ph·∫©y, kh√¥ng c√≥ kho·∫£ng tr·∫Øng: `EMPLOYEE,TEAM_LEADER`\n"
        "- M√£ NV v√† Email ph·∫£i unique (kh√¥ng tr√πng v·ªõi ng∆∞·ªùi d√πng kh√°c)\n\n"
        "=== 24. T√çCH H·ª¢P GOOGLE SHEET (T·ª± ƒë·ªông c·∫≠p nh·∫≠t Timesheet) ===\n\n"
        "**C√ÅCH HO·∫†T ƒê·ªòNG:**\n\n"
        "1. H·ªá th·ªëng t·ª± ƒë·ªông c·∫≠p nh·∫≠t Google Sheet khi:\n"
        "   - B·∫£n ghi ch·∫•m c√¥ng ƒë∆∞·ª£c ph√™ duy·ªát (tr·∫°ng th√°i **approved**)\n"
        "   - Th√¥ng tin ƒë∆∞·ª£c c·∫≠p nh·∫≠t: Ng√†y, Gi·ªù v√†o, Gi·ªù ra, Gi·ªù c√¥ng th∆∞·ªùng, TƒÉng ca...\n"
        "   - C·∫≠p nh·∫≠t v√†o file Google Sheet t∆∞∆°ng ·ª©ng v·ªõi ph√≤ng ban c·ªßa nh√¢n vi√™n\n"
        "   - T√¨m sheet theo m√£ nh√¢n vi√™n v√† c·∫≠p nh·∫≠t v√†o d√≤ng t∆∞∆°ng ·ª©ng\n\n"
        "2. **Mapping ph√≤ng ban v·ªõi Google Sheet:**\n"
        "   - M·ªói ph√≤ng ban c√≥ 1 file Google Sheet t∆∞∆°ng ·ª©ng\n"
        "   - ƒê∆∞·ª£c c·∫•u h√¨nh trong **Qu·∫£n l√Ω ph√≤ng ban** ‚Üí Tr∆∞·ªùng **File Timesheet**\n"
        "   - V√≠ d·ª•: Ph√≤ng ban \"SCOPE\" ‚Üí File \"DMI-SCOPE-Timesheet\"\n"
        "   - Admin c√≥ th·ªÉ s·ª≠a mapping n√†y trong **Qu·∫£n l√Ω ph√≤ng ban**\n\n"
        "3. **C·∫≠p nh·∫≠t th·ªß c√¥ng Google Sheet (Admin/Manager):**\n"
        "   - V√†o trang qu·∫£n l√Ω (n·∫øu c√≥) ho·∫∑c s·ª≠ d·ª•ng API\n"
        "   - Ch·ªçn file Google Sheet\n"
        "   - Ch·ªçn sheet v√† cell c·∫ßn c·∫≠p nh·∫≠t\n"
        "   - Nh·∫≠p gi√° tr·ªã m·ªõi\n"
        "   - Click **C·∫≠p nh·∫≠t**\n\n"
        "4. **Test k·∫øt n·ªëi Google API (Admin - Debug):**\n"
        "   - V√†o trang test (n·∫øu c√≥) ho·∫∑c truy c·∫≠p route `/test-google-api`\n"
        "   - Click n√∫t **Test Google API** ho·∫∑c **Ki·ªÉm tra k·∫øt n·ªëi** (m√†u xanh)\n"
        "   - H·ªá th·ªëng s·∫Ω:\n"
        "     ‚Ä¢ Ki·ªÉm tra k·∫øt n·ªëi v·ªõi Google Drive API\n"
        "     ‚Ä¢ Ki·ªÉm tra k·∫øt n·ªëi v·ªõi Google Sheets API\n"
        "     ‚Ä¢ Ki·ªÉm tra credentials c√≥ h·ª£p l·ªá kh√¥ng\n"
        "     ‚Ä¢ Ki·ªÉm tra quy·ªÅn truy c·∫≠p v√†o Google Drive/Sheets\n"
        "   - K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã:\n"
        "     ‚Ä¢ **Th√†nh c√¥ng** (m√†u xanh): K·∫øt n·ªëi OK, c√≥ th·ªÉ c·∫≠p nh·∫≠t Google Sheet\n"
        "     ‚Ä¢ **L·ªói** (m√†u ƒë·ªè): K·∫øt n·ªëi th·∫•t b·∫°i, k√®m th√¥ng b√°o l·ªói chi ti·∫øt\n"
        "   - **D√πng ƒë·ªÉ:**\n"
        "     ‚Ä¢ Debug khi Google Sheet kh√¥ng t·ª± ƒë·ªông c·∫≠p nh·∫≠t\n"
        "     ‚Ä¢ Ki·ªÉm tra credentials c√≥ ƒë√∫ng kh√¥ng\n"
        "     ‚Ä¢ Ki·ªÉm tra quy·ªÅn truy c·∫≠p c√≥ ƒë·ªß kh√¥ng\n"
        "     ‚Ä¢ X√°c minh k·∫øt n·ªëi Google API tr∆∞·ªõc khi s·ª≠ d·ª•ng\n"
        "   - **L∆∞u √Ω:**\n"
        "     ‚Ä¢ Ch·ªâ Admin m·ªõi c√≥ quy·ªÅn test Google API\n"
        "     ‚Ä¢ N·∫øu test th·∫•t b·∫°i, c·∫ßn ki·ªÉm tra l·∫°i c·∫•u h√¨nh Google API credentials\n"
        "     ‚Ä¢ C√≥ th·ªÉ c·∫ßn refresh token ho·∫∑c c·∫•u h√¨nh l·∫°i quy·ªÅn truy c·∫≠p\n\n"
        "**L∆∞u √Ω:**\n"
        "- C·∫ßn c·∫•u h√¨nh Google API credentials tr∆∞·ªõc khi s·ª≠ d·ª•ng\n"
        "- H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√¨m file Google Sheet d·ª±a tr√™n mapping ph√≤ng ban\n"
        "- N·∫øu kh√¥ng t√¨m th·∫•y file ho·∫∑c sheet, h·ªá th·ªëng s·∫Ω b√°o l·ªói (kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn ch·∫•m c√¥ng)\n"
        "- C·∫≠p nh·∫≠t Google Sheet ch·∫°y n·ªÅn (background), kh√¥ng ch·∫∑n qu√° tr√¨nh ph√™ duy·ªát\n\n"
        "=== 25. RESET M·∫¨T KH·∫®U CHO NG∆Ø·ªúI D√ôNG (Ch·ªâ Admin) ===\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Qu·∫£n l√Ω ng∆∞·ªùi d√πng** ‚Üí T√¨m ng∆∞·ªùi d√πng c·∫ßn reset m·∫≠t kh·∫©u\n"
        "2. Click icon **kh√≥a** (üîí) ho·∫∑c n√∫t **Reset m·∫≠t kh·∫©u** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "3. Nh·∫≠p m·∫≠t kh·∫©u m·ªõi v√†o √¥ input (t·ªëi thi·ªÉu 6 k√Ω t·ª±)\n"
        "4. Nh·∫≠p l·∫°i m·∫≠t kh·∫©u m·ªõi ƒë·ªÉ x√°c nh·∫≠n\n"
        "5. Click **X√°c nh·∫≠n** ho·∫∑c **Reset** ƒë·ªÉ l∆∞u\n"
        "6. H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng\n"
        "7. Ng∆∞·ªùi d√πng s·∫Ω ph·∫£i ƒëƒÉng nh·∫≠p l·∫°i v·ªõi m·∫≠t kh·∫©u m·ªõi\n\n"
        "**L∆∞u √Ω:**\n"
        "- Ch·ªâ Admin m·ªõi c√≥ quy·ªÅn reset m·∫≠t kh·∫©u\n"
        "- M·∫≠t kh·∫©u m·ªõi ph·∫£i c√≥ ƒë·ªô d√†i t·ªëi thi·ªÉu 6 k√Ω t·ª±\n"
        "- Ng∆∞·ªùi d√πng s·∫Ω nh·∫≠n ƒë∆∞·ª£c th√¥ng b√°o (n·∫øu c√≥ c·∫•u h√¨nh email)\n"
        "- N√™n th√¥ng b√°o tr∆∞·ªõc v·ªõi ng∆∞·ªùi d√πng tr∆∞·ªõc khi reset\n\n"
        "=== 26. X√ìA M·ªÄM/KH√îI PH·ª§C NG∆Ø·ªúI D√ôNG (Ch·ªâ Admin) ===\n\n"
        "**X√ìA M·ªÄM NG∆Ø·ªúI D√ôNG:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Qu·∫£n l√Ω ng∆∞·ªùi d√πng** ‚Üí T√¨m ng∆∞·ªùi d√πng c·∫ßn x√≥a\n"
        "2. Click icon **th√πng r√°c** (üóëÔ∏è) ho·∫∑c n√∫t **X√≥a** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "3. H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã popup x√°c nh·∫≠n x√≥a m·ªÅm\n"
        "4. Click **X√°c nh·∫≠n** ƒë·ªÉ x√≥a m·ªÅm\n"
        "5. Ng∆∞·ªùi d√πng s·∫Ω b·ªã ·∫©n kh·ªèi danh s√°ch ch√≠nh (kh√¥ng x√≥a d·ªØ li·ªáu)\n"
        "6. D·ªØ li·ªáu ch·∫•m c√¥ng v√† ƒë∆°n ngh·ªâ ph√©p v·∫´n ƒë∆∞·ª£c gi·ªØ nguy√™n\n\n"
        "**XEM NG∆Ø·ªúI D√ôNG ƒê√É X√ìA:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Qu·∫£n l√Ω ng∆∞·ªùi d√πng** ‚Üí Click tab **Ng∆∞·ªùi d√πng ƒë√£ x√≥a** ho·∫∑c menu t∆∞∆°ng ·ª©ng\n"
        "2. Trang s·∫Ω hi·ªÉn th·ªã danh s√°ch t·∫•t c·∫£ ng∆∞·ªùi d√πng ƒë√£ b·ªã x√≥a m·ªÅm\n"
        "3. C√≥ th·ªÉ t√¨m ki·∫øm, l·ªçc theo ph√≤ng ban (t∆∞∆°ng t·ª± danh s√°ch ch√≠nh)\n\n"
        "**KH√îI PH·ª§C NG∆Ø·ªúI D√ôNG:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Ng∆∞·ªùi d√πng ƒë√£ x√≥a** ‚Üí T√¨m ng∆∞·ªùi d√πng c·∫ßn kh√¥i ph·ª•c\n"
        "2. Click icon **kh√¥i ph·ª•c** (‚Ü©Ô∏è) ho·∫∑c n√∫t **Kh√¥i ph·ª•c** ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "3. H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã popup x√°c nh·∫≠n\n"
        "4. Click **X√°c nh·∫≠n** ƒë·ªÉ kh√¥i ph·ª•c\n"
        "5. Ng∆∞·ªùi d√πng s·∫Ω ƒë∆∞·ª£c kh√¥i ph·ª•c v√† hi·ªÉn th·ªã l·∫°i trong danh s√°ch ch√≠nh\n\n"
        "**X√ìA Vƒ®NH VI·ªÑN:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Ng∆∞·ªùi d√πng ƒë√£ x√≥a** ‚Üí T√¨m ng∆∞·ªùi d√πng c·∫ßn x√≥a vƒ©nh vi·ªÖn\n"
        "2. Click icon **x√≥a vƒ©nh vi·ªÖn** (‚ö†Ô∏è) ho·∫∑c n√∫t **X√≥a vƒ©nh vi·ªÖn** (m√†u ƒë·ªè)\n"
        "3. H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã c·∫£nh b√°o nguy hi·ªÉm (h√†nh ƒë·ªông kh√¥ng th·ªÉ ho√†n t√°c)\n"
        "4. Nh·∫≠p \"X√ìA\" ho·∫∑c x√°c nh·∫≠n ƒë·∫∑c bi·ªát ƒë·ªÉ x√°c nh·∫≠n\n"
        "5. Click **X√°c nh·∫≠n x√≥a vƒ©nh vi·ªÖn**\n"
        "6. D·ªØ li·ªáu s·∫Ω b·ªã x√≥a ho√†n to√†n, kh√¥ng th·ªÉ kh√¥i ph·ª•c\n\n"
        "**L∆∞u √Ω:**\n"
        "- X√≥a m·ªÅm ch·ªâ ·∫©n ng∆∞·ªùi d√πng, kh√¥ng x√≥a d·ªØ li·ªáu\n"
        "- C√≥ th·ªÉ kh√¥i ph·ª•c ng∆∞·ªùi d√πng ƒë√£ x√≥a m·ªÅm b·∫•t c·ª© l√∫c n√†o\n"
        "- X√≥a vƒ©nh vi·ªÖn l√† h√†nh ƒë·ªông nguy hi·ªÉm, kh√¥ng th·ªÉ ho√†n t√°c\n"
        "- N√™n x√≥a vƒ©nh vi·ªÖn ch·ªâ khi ch·∫Øc ch·∫Øn kh√¥ng c·∫ßn d·ªØ li·ªáu n·ªØa\n\n"
        "=== 27. T·∫¢I XU·ªêNG FILE ƒê√çNH K√àM ƒê∆†N NGH·ªà PH√âP ===\n\n"
        "**T·∫¢I XU·ªêNG T·ª™NG FILE:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **Theo d√µi t√¨nh tr·∫°ng** ho·∫∑c **L·ªãch s·ª≠ ngh·ªâ ph√©p**\n"
        "2. T√¨m ƒë∆°n ngh·ªâ ph√©p c√≥ file ƒë√≠nh k√®m\n"
        "3. Click icon **t·∫£i xu·ªëng** (‚¨áÔ∏è) ·ªü c·ªôt **H√†nh ƒë·ªông**\n"
        "4. File s·∫Ω ƒë∆∞·ª£c t·∫£i v·ªÅ m√°y t√≠nh v·ªõi t√™n g·ªëc\n"
        "5. Ho·∫∑c click icon **m·∫Øt** (üëÅÔ∏è) ƒë·ªÉ xem chi ti·∫øt ƒë∆°n ‚Üí Click t√™n file ƒë·ªÉ t·∫£i xu·ªëng\n\n"
        "**T·∫¢I XU·ªêNG T·∫§T C·∫¢ FILE (ZIP):**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o chi ti·∫øt ƒë∆°n ngh·ªâ ph√©p (click icon **m·∫Øt**)\n"
        "2. Trong ph·∫ßn **File ƒë√≠nh k√®m**, click n√∫t **T·∫£i t·∫•t c·∫£** ho·∫∑c **Download All** (m√†u xanh)\n"
        "3. T·∫•t c·∫£ file ƒë√≠nh k√®m s·∫Ω ƒë∆∞·ª£c n√©n th√†nh file ZIP v√† t·∫£i v·ªÅ\n"
        "4. File ZIP c√≥ t√™n: `attachments_[M√£NV]_[Ng√†y].zip`\n"
        "5. Gi·∫£i n√©n file ZIP ƒë·ªÉ xem c√°c file ƒë√≠nh k√®m\n\n"
        "**L∆∞u √Ω:**\n"
        "- Ch·ªâ t·∫£i ƒë∆∞·ª£c file c·ªßa ƒë∆°n ngh·ªâ ph√©p\n"
        "- File ƒë∆∞·ª£c l∆∞u v·ªõi t√™n g·ªëc (kh√¥ng ƒë·ªïi t√™n)\n"
        "- C√≥ th·ªÉ t·∫£i nhi·ªÅu file c√πng l√∫c b·∫±ng c√°ch t·∫£i t·∫•t c·∫£ (ZIP)\n"
        "- File ZIP c√≥ th·ªÉ ch·ª©a nhi·ªÅu ƒë·ªãnh d·∫°ng: PDF, JPG, PNG, DOC, DOCX\n\n"
        "=== 28. TH√îNG B√ÅO EMAIL T·ª∞ ƒê·ªòNG ===\n\n"
        "**KHI N√ÄO EMAIL ƒê∆Ø·ª¢C G·ª¨I:**\n\n"
        "1. **Khi t·∫°o ƒë∆°n ngh·ªâ ph√©p:**\n"
        "   - Email ƒë∆∞·ª£c g·ª≠i ƒë·∫øn Leader/Manager/Admin (ng∆∞·ªùi ph√™ duy·ªát)\n"
        "   - N·ªôi dung: Th√¥ng b√°o c√≥ ƒë∆°n ngh·ªâ ph√©p m·ªõi c·∫ßn ph√™ duy·ªát\n"
        "   - Ch·ªâ g·ª≠i n·∫øu ng∆∞·ªùi d√πng ch·ªçn **C√≥, g·ª≠i email** trong popup x√°c nh·∫≠n\n\n"
        "2. **Khi ƒë∆°n ngh·ªâ ph√©p ƒë∆∞·ª£c ph√™ duy·ªát:**\n"
        "   - Email ƒë∆∞·ª£c g·ª≠i ƒë·∫øn ng∆∞·ªùi t·∫°o ƒë∆°n\n"
        "   - N·ªôi dung: Th√¥ng b√°o ƒë∆°n ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát, k√®m nh·∫≠n x√©t (n·∫øu c√≥)\n"
        "   - T·ª± ƒë·ªông g·ª≠i, kh√¥ng c·∫ßn x√°c nh·∫≠n\n\n"
        "3. **Khi ƒë∆°n ngh·ªâ ph√©p b·ªã t·ª´ ch·ªëi:**\n"
        "   - Email ƒë∆∞·ª£c g·ª≠i ƒë·∫øn ng∆∞·ªùi t·∫°o ƒë∆°n\n"
        "   - N·ªôi dung: Th√¥ng b√°o ƒë∆°n b·ªã t·ª´ ch·ªëi, k√®m l√Ω do t·ª´ ch·ªëi\n"
        "   - T·ª± ƒë·ªông g·ª≠i, kh√¥ng c·∫ßn x√°c nh·∫≠n\n\n"
        "4. **Khi ch·∫•m c√¥ng ƒë∆∞·ª£c ph√™ duy·ªát:**\n"
        "   - Email ƒë∆∞·ª£c g·ª≠i ƒë·∫øn ng∆∞·ªùi t·∫°o b·∫£n ghi ch·∫•m c√¥ng\n"
        "   - N·ªôi dung: Th√¥ng b√°o ch·∫•m c√¥ng ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát\n"
        "   - T·ª± ƒë·ªông g·ª≠i (n·∫øu c√≥ c·∫•u h√¨nh email)\n\n"
        "5. **Khi ch·∫•m c√¥ng b·ªã t·ª´ ch·ªëi:**\n"
        "   - Email ƒë∆∞·ª£c g·ª≠i ƒë·∫øn ng∆∞·ªùi t·∫°o b·∫£n ghi ch·∫•m c√¥ng\n"
        "   - N·ªôi dung: Th√¥ng b√°o ch·∫•m c√¥ng b·ªã t·ª´ ch·ªëi, k√®m l√Ω do\n"
        "   - T·ª± ƒë·ªông g·ª≠i (n·∫øu c√≥ c·∫•u h√¨nh email)\n\n"
        "**KI·ªÇM TRA TR·∫†NG TH√ÅI EMAIL:**\n\n"
        "1. V√†o **Theo d√µi t√¨nh tr·∫°ng** ho·∫∑c **L·ªãch s·ª≠ ngh·ªâ ph√©p**\n"
        "2. Click icon **m·∫Øt** (üëÅÔ∏è) ƒë·ªÉ xem chi ti·∫øt ƒë∆°n\n"
        "3. Trong trang chi ti·∫øt, t√¨m ph·∫ßn **Tr·∫°ng th√°i email** ho·∫∑c **Email Status**\n"
        "4. S·∫Ω hi·ªÉn th·ªã:\n"
        "   - **ƒê√£ g·ª≠i** (m√†u xanh) - Email ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng\n"
        "   - **G·ª≠i th·∫•t b·∫°i** (m√†u ƒë·ªè) - Email kh√¥ng g·ª≠i ƒë∆∞·ª£c, k√®m l√Ω do\n"
        "   - **Ch∆∞a g·ª≠i** (m√†u x√°m) - Ch∆∞a g·ª≠i email (ng∆∞·ªùi d√πng ch·ªçn kh√¥ng g·ª≠i)\n"
        "   - **ƒêang g·ª≠i** (m√†u v√†ng) - Email ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω\n\n"
        "**L∆∞u √Ω:**\n"
        "- Email ch·ªâ ƒë∆∞·ª£c g·ª≠i n·∫øu h·ªá th·ªëng ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh email server\n"
        "- N·∫øu email g·ª≠i th·∫•t b·∫°i, c√≥ th·ªÉ th·ª≠ g·ª≠i l·∫°i (n·∫øu c√≥ n√∫t **G·ª≠i l·∫°i**)\n"
        "- Tr·∫°ng th√°i email ƒë∆∞·ª£c l∆∞u trong database v√† c√≥ th·ªÉ xem l·∫°i b·∫•t c·ª© l√∫c n√†o\n"
        "- Email ƒë∆∞·ª£c g·ª≠i b·∫•t ƒë·ªìng b·ªô (background), kh√¥ng ch·∫∑n qu√° tr√¨nh ph√™ duy·ªát\n\n"
        "=== 29. QU·∫¢N L√ù PHI√äN ƒêƒÇNG NH·∫¨P (SESSION) ===\n\n"
        "**TH·ªúI GIAN PHI√äN ƒêƒÇNG NH·∫¨P:**\n\n"
        "1. **Session th√¥ng th∆∞·ªùng:**\n"
        "   - Session h·∫øt h·∫°n sau m·ªôt kho·∫£ng th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông (th∆∞·ªùng l√† 30 ph√∫t - 2 gi·ªù)\n"
        "   - N·∫øu kh√¥ng c√≥ ho·∫°t ƒë·ªông trong th·ªùi gian n√†y, h·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông ƒëƒÉng xu·∫•t\n"
        "   - Khi session h·∫øt h·∫°n, b·∫°n s·∫Ω th·∫•y th√¥ng b√°o \"Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n\"\n"
        "   - C·∫ßn ƒëƒÉng nh·∫≠p l·∫°i ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng\n\n"
        "2. **Token \"Ghi nh·ªõ\" (Remember Me):**\n"
        "   - N·∫øu ch·ªçn **Ghi nh·ªõ** khi ƒëƒÉng nh·∫≠p, token s·∫Ω c√≥ th·ªùi h·∫°n 30 ng√†y\n"
        "   - Token t·ª± ƒë·ªông ƒëƒÉng nh·∫≠p l·∫°i khi m·ªü tr√¨nh duy·ªát (trong v√≤ng 30 ng√†y)\n"
        "   - Sau 30 ng√†y, token h·∫øt h·∫°n, c·∫ßn ƒëƒÉng nh·∫≠p l·∫°i\n"
        "   - Token s·∫Ω b·ªã x√≥a khi ƒëƒÉng xu·∫•t th·ªß c√¥ng\n\n"
        "**L∆ØU √ù V·ªÄ B·∫¢O M·∫¨T:**\n"
        "- N√™n ƒëƒÉng xu·∫•t khi s·ª≠ d·ª•ng m√°y t√≠nh c√¥ng c·ªông\n"
        "- Kh√¥ng n√™n ch·ªçn **Ghi nh·ªõ** tr√™n m√°y t√≠nh c√¥ng c·ªông\n"
        "- N·∫øu qu√™n ƒëƒÉng xu·∫•t, c√≥ th·ªÉ ƒëƒÉng xu·∫•t t·ª´ xa b·∫±ng c√°ch ƒë·ªïi m·∫≠t kh·∫©u (Admin)\n"
        "- Session s·∫Ω t·ª± ƒë·ªông h·∫øt h·∫°n sau th·ªùi gian kh√¥ng ho·∫°t ƒë·ªông\n\n"
        "=== 30. DASHBOARD - T·ªîNG QUAN V√Ä TH·ªêNG K√ä ===\n\n"
        "**C√ÅC TH√îNG TIN HI·ªÇN TH·ªä TR√äN DASHBOARD:**\n\n"
        "1. **Form ch·∫•m c√¥ng:**\n"
        "   - ·ªû ph·∫ßn tr√™n Dashboard, cho ph√©p ƒëƒÉng k√Ω ch·∫•m c√¥ng m·ªõi\n"
        "   - T·∫•t c·∫£ c√°c tr∆∞·ªùng c·∫ßn ƒëi·ªÅn (xem chi ti·∫øt ·ªü ph·∫ßn 6)\n\n"
        "2. **B·∫£ng l·ªãch s·ª≠ ch·∫•m c√¥ng:**\n"
        "   - Hi·ªÉn th·ªã t·∫•t c·∫£ b·∫£n ghi ch·∫•m c√¥ng v·ªõi c√°c c·ªôt chi ti·∫øt\n"
        "   - C√≥ th·ªÉ l·ªçc theo th√°ng/nƒÉm, t√¨m ki·∫øm theo t√™n/m√£ nh√¢n vi√™n\n"
        "   - C√°c c·ªôt: Ng√†y, Gi·ªù v√†o/ra, Ca, Th·ªùi gian ngh·ªâ, T·ªïng ƒë·ªëi ·ª©ng, T·ªïng gi·ªù l√†m, Gi·ªù c√¥ng th∆∞·ªùng, TƒÉng ca <22h, TƒÉng ca >22h, Lo·∫°i ng√†y, Tr·∫°ng th√°i, H√†nh ƒë·ªông\n\n"
        "3. **B·ªô chuy·ªÉn vai tr√≤:**\n"
        "   - ·ªû g√≥c tr√™n Dashboard (n·∫øu b·∫°n c√≥ nhi·ªÅu vai tr√≤)\n"
        "   - Cho ph√©p chuy·ªÉn ƒë·ªïi gi·ªØa c√°c vai tr√≤: Employee, Leader, Manager, Admin\n"
        "   - Menu v√† d·ªØ li·ªáu s·∫Ω thay ƒë·ªïi theo vai tr√≤ ƒë∆∞·ª£c ch·ªçn\n\n"
        "4. **C·∫£nh b√°o h·ªá th·ªëng:**\n"
        "   - C·∫£nh b√°o license/token n·∫øu c√≥ v·∫•n ƒë·ªÅ (m√†u v√†ng ho·∫∑c ƒë·ªè)\n"
        "   - C·∫£nh b√°o c·∫•u h√¨nh Google Sheet n·∫øu ch∆∞a ƒë√∫ng\n"
        "   - C·∫£nh b√°o ng√†y l·ªÖ ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh cho nƒÉm hi·ªán t·∫°i\n\n"
        "5. **Th·ªëng k√™ t·ªïng quan (n·∫øu c√≥):**\n"
        "   - T·ªïng s·ªë gi·ªù c√¥ng trong th√°ng\n"
        "   - T·ªïng s·ªë gi·ªù tƒÉng ca\n"
        "   - S·ªë ƒë∆°n ngh·ªâ ph√©p ƒëang ch·ªù ph√™ duy·ªát\n"
        "   - S·ªë b·∫£n ghi ch·∫•m c√¥ng ch·ªù ph√™ duy·ªát\n\n"
        "**C√ÅCH S·ª¨ D·ª§NG B·ªò L·ªåC:**\n"
        "1. Ch·ªçn **Th√°ng/NƒÉm** t·ª´ dropdown ƒë·ªÉ xem d·ªØ li·ªáu theo th√°ng\n"
        "2. Nh·∫≠p **T√™n/M√£ nh√¢n vi√™n** v√†o √¥ t√¨m ki·∫øm (n·∫øu c√≥ quy·ªÅn)\n"
        "3. Click **√Åp d·ª•ng b·ªô l·ªçc** ƒë·ªÉ xem k·∫øt qu·∫£\n"
        "4. B·∫£ng s·∫Ω t·ª± ƒë·ªông c·∫≠p nh·∫≠t v·ªõi d·ªØ li·ªáu ƒë√£ l·ªçc\n\n"
        "**L∆∞u √Ω:**\n"
        "- Dashboard l√† trang ch√≠nh, hi·ªÉn th·ªã ngay sau khi ƒëƒÉng nh·∫≠p\n"
        "- D·ªØ li·ªáu ƒë∆∞·ª£c c·∫≠p nh·∫≠t theo th·ªùi gian th·ª±c khi c√≥ thay ƒë·ªïi\n"
        "- C√≥ th·ªÉ refresh trang ƒë·ªÉ c·∫≠p nh·∫≠t d·ªØ li·ªáu m·ªõi nh·∫•t\n\n"
        "=== 31. T√çNH NƒÇNG T√åM KI·∫æM V√Ä L·ªåC N√ÇNG CAO ===\n\n"
        "**T√åM KI·∫æM:**\n\n"
        "1. **T√¨m ki·∫øm c∆° b·∫£n:**\n"
        "   - Nh·∫≠p t·ª´ kh√≥a v√†o √¥ **T√¨m ki·∫øm**\n"
        "   - H·ªá th·ªëng s·∫Ω t√¨m theo t√™n ho·∫∑c m√£ nh√¢n vi√™n\n"
        "   - T√¨m ki·∫øm kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng\n"
        "   - C√≥ th·ªÉ t√¨m m·ªôt ph·∫ßn c·ªßa t√™n (v√≠ d·ª•: \"Nguy·ªÖn\" s·∫Ω t√¨m t·∫•t c·∫£ ng∆∞·ªùi c√≥ h·ªç Nguy·ªÖn)\n\n"
        "2. **K·∫øt h·ª£p b·ªô l·ªçc:**\n"
        "   - C√≥ th·ªÉ k·∫øt h·ª£p nhi·ªÅu b·ªô l·ªçc c√πng l√∫c:\n"
        "     ‚Ä¢ T√¨m ki·∫øm + Ph√≤ng ban + Tr·∫°ng th√°i\n"
        "     ‚Ä¢ T√¨m ki·∫øm + Lo·∫°i ƒë∆°n + Kho·∫£ng th·ªùi gian\n"
        "     ‚Ä¢ Ph√≤ng ban + Tr·∫°ng th√°i + Kho·∫£ng th·ªùi gian\n"
        "   - Click **√Åp d·ª•ng b·ªô l·ªçc** ƒë·ªÉ √°p d·ª•ng t·∫•t c·∫£ b·ªô l·ªçc ƒë√£ ch·ªçn\n"
        "   - Click **X√≥a b·ªô l·ªçc** (n·∫øu c√≥) ƒë·ªÉ reset v·ªÅ m·∫∑c ƒë·ªãnh\n\n"
        "3. **L∆∞u √Ω:**\n"
        "   - B·ªô l·ªçc ƒë∆∞·ª£c √°p d·ª•ng ngay l·∫≠p t·ª©c sau khi click **√Åp d·ª•ng b·ªô l·ªçc**\n"
        "   - C√≥ th·ªÉ thay ƒë·ªïi b·ªô l·ªçc b·∫•t c·ª© l√∫c n√†o\n"
        "   - B·ªô l·ªçc kh√¥ng ƒë∆∞·ª£c l∆∞u gi·ªØa c√°c l·∫ßn ƒëƒÉng nh·∫≠p (reset v·ªÅ m·∫∑c ƒë·ªãnh)\n\n"
        "=== 32. H·ªñ TR·ª¢ TR√åNH DUY·ªÜT V√Ä THI·∫æT B·ªä ===\n\n"
        "**TR√åNH DUY·ªÜT ƒê∆Ø·ª¢C H·ªñ TR·ª¢:**\n\n"
        "1. **Tr√¨nh duy·ªát khuy·∫øn ngh·ªã:**\n"
        "   - Google Chrome (phi√™n b·∫£n m·ªõi nh·∫•t)\n"
        "   - Microsoft Edge (phi√™n b·∫£n m·ªõi nh·∫•t)\n"
        "   - Mozilla Firefox (phi√™n b·∫£n m·ªõi nh·∫•t)\n"
        "   - Safari (phi√™n b·∫£n m·ªõi nh·∫•t)\n\n"
        "2. **Y√™u c·∫ßu t·ªëi thi·ªÉu:**\n"
        "   - Tr√¨nh duy·ªát ph·∫£i h·ªó tr·ª£ HTML5, CSS3, JavaScript ES6+\n"
        "   - Ph·∫£i b·∫≠t JavaScript\n"
        "   - Ph·∫£i cho ph√©p cookies\n"
        "   - Khuy·∫øn ngh·ªã ƒë·ªô ph√¢n gi·∫£i m√†n h√¨nh t·ªëi thi·ªÉu: 1280x720\n\n"
        "3. **H·ªó tr·ª£ mobile:**\n"
        "   - H·ªá th·ªëng h·ªó tr·ª£ responsive design, c√≥ th·ªÉ s·ª≠ d·ª•ng tr√™n mobile/tablet\n"
        "   - Giao di·ªán s·∫Ω t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh theo k√≠ch th∆∞·ªõc m√†n h√¨nh\n"
        "   - M·ªôt s·ªë t√≠nh nƒÉng c√≥ th·ªÉ c·∫ßn cu·ªôn ngang tr√™n m√†n h√¨nh nh·ªè\n"
        "   - Khuy·∫øn ngh·ªã s·ª≠ d·ª•ng tr√¨nh duy·ªát mobile m·ªõi nh·∫•t\n\n"
        "4. **L∆∞u √Ω:**\n"
        "   - N·∫øu g·∫∑p l·ªói hi·ªÉn th·ªã, th·ª≠ refresh trang (F5 ho·∫∑c Ctrl+R)\n"
        "   - N·∫øu v·∫´n l·ªói, th·ª≠ x√≥a cache v√† cookies c·ªßa tr√¨nh duy·ªát\n"
        "   - N√™n s·ª≠ d·ª•ng tr√¨nh duy·ªát m·ªõi nh·∫•t ƒë·ªÉ c√≥ tr·∫£i nghi·ªám t·ªët nh·∫•t\n"
        "   - M·ªôt s·ªë t√≠nh nƒÉng c√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông tr√™n tr√¨nh duy·ªát c≈©\n\n"
        "=== 33. C·∫¨P NH·∫¨T D·ªÆ LI·ªÜU THEO TH·ªúI GIAN TH·ª∞C ===\n\n"
        "**C√ÅCH H·ªÜ TH·ªêNG C·∫¨P NH·∫¨T:**\n\n"
        "1. **T·ª± ƒë·ªông refresh:**\n"
        "   - M·ªôt s·ªë trang s·∫Ω t·ª± ƒë·ªông refresh sau m·ªôt kho·∫£ng th·ªùi gian (v√≠ d·ª•: 30 gi√¢y - 1 ph√∫t)\n"
        "   - D·ªØ li·ªáu m·ªõi s·∫Ω t·ª± ƒë·ªông hi·ªÉn th·ªã m√† kh√¥ng c·∫ßn refresh th·ªß c√¥ng\n"
        "   - C√≥ th·ªÉ th·∫•y th√¥ng b√°o \"ƒêang t·∫£i d·ªØ li·ªáu...\" khi ƒëang refresh\n\n"
        "2. **Refresh th·ªß c√¥ng:**\n"
        "   - Click n√∫t **Refresh** (n·∫øu c√≥) ho·∫∑c nh·∫•n F5 ho·∫∑c Ctrl+R\n"
        "   - Trang s·∫Ω t·∫£i l·∫°i v√† hi·ªÉn th·ªã d·ªØ li·ªáu m·ªõi nh·∫•t\n\n"
        "3. **Th√¥ng b√°o real-time:**\n"
        "   - Khi c√≥ ƒë∆°n ngh·ªâ ph√©p m·ªõi c·∫ßn ph√™ duy·ªát, c√≥ th·ªÉ c√≥ th√¥ng b√°o (n·∫øu ƒë∆∞·ª£c c·∫•u h√¨nh)\n"
        "   - Th√¥ng b√°o s·∫Ω hi·ªÉn th·ªã ·ªü g√≥c m√†n h√¨nh (toast notification)\n"
        "   - Click v√†o th√¥ng b√°o ƒë·ªÉ xem chi ti·∫øt\n\n"
        "**L∆∞u √Ω:**\n"
        "   - D·ªØ li·ªáu ƒë∆∞·ª£c c·∫≠p nh·∫≠t t·ª´ server, ƒë·∫£m b·∫£o t√≠nh ch√≠nh x√°c\n"
        "   - N·∫øu th·∫•y d·ªØ li·ªáu c≈©, th·ª≠ refresh trang\n"
        "   - M·ªôt s·ªë thao t√°c (nh∆∞ ph√™ duy·ªát, t·ª´ ch·ªëi) s·∫Ω c·∫≠p nh·∫≠t ngay l·∫≠p t·ª©c\n\n"
        "=== 34. XU·∫§T EXCEL TR∆Ø·ªúNG H·ª¢P NGH·ªà PH√âP (CH·ªà ADMIN) ===\n\n"
        "**KH√ÅC BI·ªÜT V·ªöI L·ªäCH S·ª¨ NGH·ªà PH√âP:**\n\n"
        "1. **L·ªãch s·ª≠ ngh·ªâ ph√©p (Section 18):**\n"
        "   - Xu·∫•t Excel **T√ÅCH T·ª™NG NG√ÄY RI√äNG BI·ªÜT**\n"
        "   - V√≠ d·ª•: Ngh·ªâ t·ª´ 1/1 ƒë·∫øn 3/1 (3 ng√†y) ‚Üí Excel s·∫Ω c√≥ **3 d√≤ng**, m·ªói d√≤ng 1 ng√†y\n"
        "   - M·ªói d√≤ng hi·ªÉn th·ªã: Ng√†y ngh·ªâ, Th·ªùi gian ngh·ªâ (s√°ng/chi·ªÅu/c·∫£ ng√†y), L√Ω do, Lo·∫°i ngh·ªâ, S·ªë ng√†y\n\n"
        "2. **Tr∆∞·ªùng h·ª£p ngh·ªâ ph√©p (Section n√†y):**\n"
        "   - Xu·∫•t Excel **T·ªîNG H·ª¢P THEO ƒê∆†N** (kh√¥ng t√°ch ng√†y)\n"
        "   - V√≠ d·ª•: Ngh·ªâ t·ª´ 1/1 ƒë·∫øn 3/1 (3 ng√†y) ‚Üí Excel s·∫Ω c√≥ **1 d√≤ng** cho c·∫£ ƒë∆°n\n"
        "   - M·ªói d√≤ng hi·ªÉn th·ªã: T√™n nh√¢n vi√™n, T·ª´ ng√†y - ƒê·∫øn ng√†y, T·ªïng s·ªë ng√†y ngh·ªâ, L√Ω do, Lo·∫°i ngh·ªâ\n"
        "   - D√πng ƒë·ªÉ xem t·ªïng quan c√°c tr∆∞·ªùng h·ª£p ngh·ªâ ph√©p\n\n"
        "**C√ÅCH XU·∫§T EXCEL TR∆Ø·ªúNG H·ª¢P NGH·ªà PH√âP:**\n\n"
        "C√°c b∆∞·ªõc CHI TI·∫æT:\n"
        "1. V√†o **L·ªãch s·ª≠ ngh·ªâ ph√©p** ho·∫∑c trang t∆∞∆°ng ·ª©ng (ch·ªâ Admin)\n"
        "2. T√¨m n√∫t **Xu·∫•t Excel tr∆∞·ªùng h·ª£p ngh·ªâ ph√©p** ho·∫∑c **Export Leave Cases** (n·∫øu c√≥)\n"
        "3. Click n√∫t ƒë·ªÉ xu·∫•t Excel\n"
        "4. File Excel s·∫Ω ƒë∆∞·ª£c t·∫£i v·ªÅ v·ªõi t√™n: `leave_cases_YYYYMMDD.xlsx`\n"
        "5. File Excel ch·ª©a:\n"
        "   - M·ªói d√≤ng = 1 ƒë∆°n ngh·ªâ ph√©p (kh√¥ng t√°ch ng√†y)\n"
        "   - C√°c c·ªôt: T√™n nh√¢n vi√™n, M√£ NV, Ph√≤ng ban, T·ª´ ng√†y, ƒê·∫øn ng√†y, T·ªïng s·ªë ng√†y, L√Ω do, Lo·∫°i ngh·ªâ, Tr·∫°ng th√°i\n\n"
        "**L∆∞u √Ω:**\n"
        "   - T√≠nh nƒÉng n√†y kh√°c v·ªõi **Xu·∫•t Excel l·ªãch s·ª≠ ngh·ªâ ph√©p** (Section 18)\n"
        "   - D√πng ƒë·ªÉ xem t·ªïng quan, kh√¥ng d√πng ƒë·ªÉ t√≠nh to√°n chi ti·∫øt t·ª´ng ng√†y\n"
        "   - Ch·ªâ Admin m·ªõi c√≥ quy·ªÅn xu·∫•t Excel tr∆∞·ªùng h·ª£p ngh·ªâ ph√©p\n\n"
        "=== 35. RESET NƒÇM (YEARLY RESET) - T·ª∞ ƒê·ªòNG ===\n\n"
        "**C√ÅCH HO·∫†T ƒê·ªòNG:**\n\n"
        "1. **Reset t·ª± ƒë·ªông:**\n"
        "   - H·ªá th·ªëng t·ª± ƒë·ªông reset v√†o **00:00 ng√†y 1/1** h√†ng nƒÉm\n"
        "   - X√≥a t·∫•t c·∫£ d·ªØ li·ªáu ch·∫•m c√¥ng c·ªßa **nƒÉm tr∆∞·ªõc** (kh√¥ng ph·∫£i nƒÉm hi·ªán t·∫°i)\n"
        "   - V√≠ d·ª•: Ng√†y 1/1/2024 ‚Üí X√≥a d·ªØ li·ªáu nƒÉm 2023\n"
        "   - Reset ch·∫°y t·ª± ƒë·ªông, kh√¥ng c·∫ßn can thi·ªáp th·ªß c√¥ng\n\n"
        "2. **Th√¥ng b√°o tr∆∞·ªõc khi reset:**\n"
        "   - H·ªá th·ªëng s·∫Ω g·ª≠i th√¥ng b√°o nh·∫Øc nh·ªü Admin:\n"
        "     ‚Ä¢ **7 ng√†y tr∆∞·ªõc** ng√†y reset (25/12)\n"
        "     ‚Ä¢ **3 ng√†y tr∆∞·ªõc** ng√†y reset (29/12)\n"
        "     ‚Ä¢ **1 ng√†y tr∆∞·ªõc** ng√†y reset (31/12)\n"
        "   - Th√¥ng b√°o bao g·ªìm:\n"
        "     ‚Ä¢ C·∫£nh b√°o h·ªá th·ªëng s·∫Ω x√≥a d·ªØ li·ªáu nƒÉm c≈©\n"
        "     ‚Ä¢ Nh·∫Øc nh·ªü sao l∆∞u d·ªØ li·ªáu quan tr·ªçng\n"
        "     ‚Ä¢ Ki·ªÉm tra d·ªØ li·ªáu th√°ng 12 ƒë√£ ƒë·∫ßy ƒë·ªß ch∆∞a\n"
        "     ‚Ä¢ Danh s√°ch nh√¢n vi√™n ch∆∞a nh·∫≠p ƒë·∫ßy ƒë·ªß d·ªØ li·ªáu th√°ng 12 (n·∫øu c√≥)\n\n"
        "3. **Ki·ªÉm tra d·ªØ li·ªáu th√°ng 12:**\n"
        "   - H·ªá th·ªëng t·ª± ƒë·ªông ki·ªÉm tra d·ªØ li·ªáu th√°ng 12 tr∆∞·ªõc khi reset\n"
        "   - B√°o c√°o s·ªë nh√¢n vi√™n ƒë√£ nh·∫≠p ƒë·∫ßy ƒë·ªß / t·ªïng s·ªë nh√¢n vi√™n\n"
        "   - Li·ªát k√™ nh√¢n vi√™n ch∆∞a nh·∫≠p ƒë·∫ßy ƒë·ªß (n·∫øu c√≥)\n"
        "   - Admin n√™n ki·ªÉm tra v√† nh·∫Øc nh·ªü nh√¢n vi√™n ho√†n t·∫•t d·ªØ li·ªáu\n\n"
        "4. **Sau khi reset:**\n"
        "   - H·ªá th·ªëng s·∫Ω g·ª≠i th√¥ng b√°o x√°c nh·∫≠n:\n"
        "     ‚Ä¢ ƒê√£ ho√†n t·∫•t reset l·ªãch\n"
        "     ‚Ä¢ S·ªë b·∫£n ghi ch·∫•m c√¥ng ƒë√£ x√≥a\n"
        "     ‚Ä¢ H·ªá th·ªëng ƒë√£ s·∫µn s√†ng cho nƒÉm m·ªõi\n"
        "   - D·ªØ li·ªáu nƒÉm m·ªõi b·∫Øt ƒë·∫ßu t·ª´ ng√†y 1/1\n\n"
        "**L∆∞u √Ω quan tr·ªçng:**\n"
        "- **Reset x√≥a d·ªØ li·ªáu ch·∫•m c√¥ng c·ªßa nƒÉm tr∆∞·ªõc**, kh√¥ng x√≥a ƒë∆°n ngh·ªâ ph√©p\n"
        "- **Kh√¥ng th·ªÉ kh√¥i ph·ª•c** d·ªØ li·ªáu ƒë√£ b·ªã x√≥a sau khi reset\n"
        "- **N√™n sao l∆∞u d·ªØ li·ªáu** tr∆∞·ªõc ng√†y 1/1 h√†ng nƒÉm\n"
        "- **Nh·∫Øc nh·ªü nh√¢n vi√™n** ho√†n t·∫•t nh·∫≠p d·ªØ li·ªáu th√°ng 12 tr∆∞·ªõc ng√†y reset\n"
        "- Reset ch·∫°y t·ª± ƒë·ªông, Admin kh√¥ng c·∫ßn thao t√°c g√¨\n"
        "- N·∫øu c·∫ßn reset th·ªß c√¥ng, li√™n h·ªá developer ho·∫∑c xem API documentation\n\n"
        "=== 36. XU·∫§T EXCEL L·ªäCH S·ª¨ NGH·ªà PH√âP - CHI TI·∫æT B·ªî SUNG ===\n\n"
        "**QUAN TR·ªåNG V·ªÄ ƒê·ªäNH D·∫†NG EXCEL:**\n\n"
        "1. **Excel t√°ch t·ª´ng ng√†y ri√™ng bi·ªát:**\n"
        "   - N·∫øu ngh·ªâ t·ª´ **1/1 ƒë·∫øn 3/1** (3 ng√†y) ‚Üí Excel s·∫Ω c√≥ **3 d√≤ng**\n"
        "   - M·ªói d√≤ng = 1 ng√†y ngh·ªâ\n"
        "   - V√≠ d·ª•:\n"
        "     ‚Ä¢ D√≤ng 1: Ng√†y 1/1, S√°ng, 0.5 ng√†y, L√Ω do: \"Ngh·ªâ ph√©p\"\n"
        "     ‚Ä¢ D√≤ng 2: Ng√†y 2/1, C·∫£ ng√†y, 1 ng√†y, L√Ω do: \"Ngh·ªâ ph√©p\"\n"
        "     ‚Ä¢ D√≤ng 3: Ng√†y 3/1, Chi·ªÅu, 0.5 ng√†y, L√Ω do: \"Ngh·ªâ ph√©p\"\n\n"
        "2. **C√°c c·ªôt trong Excel:**\n"
        "   - **Nh√¢n vi√™n:** T√™n ƒë·∫ßy ƒë·ªß\n"
        "   - **M√£ NV:** M√£ nh√¢n vi√™n\n"
        "   - **Ph√≤ng ban:** Ph√≤ng ban c·ªßa nh√¢n vi√™n\n"
        "   - **Ng√†y ngh·ªâ:** Ng√†y c·ª• th·ªÉ (t·ª´ng ng√†y ri√™ng)\n"
        "   - **Th·ªùi gian ngh·ªâ:** S√°ng/Chi·ªÅu/C·∫£ ng√†y\n"
        "   - **L√Ω do:** L√Ω do ngh·ªâ ph√©p\n"
        "   - **Lo·∫°i ngh·ªâ:** Ngh·ªâ ph√©p nƒÉm / Ngh·ªâ kh√¥ng l∆∞∆°ng / Ngh·ªâ ƒë·∫∑c bi·ªát\n"
        "   - **S·ªë ng√†y:** S·ªë ng√†y ngh·ªâ (0.5, 1, 1.5, 2...)\n"
        "   - **Ng√†y t·∫°o:** Ng√†y t·∫°o ƒë∆°n ngh·ªâ ph√©p\n"
        "   - **Tr·∫°ng th√°i:** ƒê√£ ph√™ duy·ªát / T·ª´ ch·ªëi / Ch·ªù ph√™ duy·ªát\n\n"
        "3. **L·ªçc d·ªØ li·ªáu tr∆∞·ªõc khi xu·∫•t:**\n"
        "   - C√≥ th·ªÉ s·ª≠ d·ª•ng c√°c b·ªô l·ªçc tr√™n trang **L·ªãch s·ª≠ ngh·ªâ ph√©p** tr∆∞·ªõc khi xu·∫•t\n"
        "   - Excel s·∫Ω ch·ªâ ch·ª©a d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c l·ªçc\n"
        "   - V√≠ d·ª•: L·ªçc theo ph√≤ng ban ‚Üí Excel ch·ªâ c√≥ nh√¢n vi√™n ph√≤ng ban ƒë√≥\n"
        "   - V√≠ d·ª•: L·ªçc theo kho·∫£ng th·ªùi gian ‚Üí Excel ch·ªâ c√≥ ƒë∆°n trong kho·∫£ng th·ªùi gian ƒë√≥\n\n"
        "**L∆∞u √Ω:**\n"
        "- Excel t√°ch t·ª´ng ng√†y ƒë·ªÉ d·ªÖ t√≠nh to√°n v√† ki·ªÉm tra\n"
        "- N·∫øu mu·ªën xem t·ªïng h·ª£p theo ƒë∆°n (kh√¥ng t√°ch ng√†y), d√πng **Xu·∫•t Excel tr∆∞·ªùng h·ª£p ngh·ªâ ph√©p** (Section 34)\n"
        "- Ch·ªâ Admin m·ªõi c√≥ quy·ªÅn xu·∫•t Excel\n"
        "- File Excel c√≥ th·ªÉ m·ªü b·∫±ng Microsoft Excel, Google Sheets, LibreOffice Calc\n"
        "- File Excel c√≥ th·ªÉ ƒë∆∞·ª£c d√πng ƒë·ªÉ b√°o c√°o, th·ªëng k√™, ho·∫∑c import v√†o h·ªá th·ªëng kh√°c\n\n"
        "=== 37. X√ìA D·ªÆ LI·ªÜU H·ªÜ TH·ªêNG (CH·ªà ADMIN - C·∫¢NH B√ÅO NGUY HI·ªÇM) ===\n\n"
        "**‚ö†Ô∏è C·∫¢NH B√ÅO QUAN TR·ªåNG:**\n"
        "- T√≠nh nƒÉng n√†y **NGUY HI·ªÇM** v√† **KH√îNG TH·ªÇ HO√ÄN T√ÅC**\n"
        "- Ch·ªâ d√πng trong tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát: Test h·ªá th·ªëng, Reset ho√†n to√†n, Development\n"
        "- **PH·∫¢I SAO L∆ØU D·ªÆ LI·ªÜU** tr∆∞·ªõc khi th·ª±c hi·ªán\n"
        "- Ch·ªâ Admin m·ªõi c√≥ quy·ªÅn th·ª±c hi·ªán\n\n"
        "**C√ÅC LO·∫†I X√ìA D·ªÆ LI·ªÜU:**\n\n"
        "1. **X√≥a t·∫•t c·∫£ d·ªØ li·ªáu:**\n"
        "   - X√≥a: Ch·∫•m c√¥ng, ƒê∆°n ngh·ªâ ph√©p, Ng∆∞·ªùi d√πng (tr·ª´ admin Nguy·ªÖn C√¥ng ƒê·∫°t), Ph√≤ng ban, Ng√†y l·ªÖ, Audit logs...\n"
        "   - **Gi·ªØ l·∫°i:** Admin Nguy·ªÖn C√¥ng ƒê·∫°t (ƒë·ªÉ c√≥ th·ªÉ ƒëƒÉng nh·∫≠p l·∫°i)\n"
        "   - Y√™u c·∫ßu nh·∫≠p m·∫≠t kh·∫©u Admin ƒë·ªÉ x√°c nh·∫≠n\n"
        "   - X√°c nh·∫≠n nhi·ªÅu l·∫ßn (c·∫£nh b√°o nguy hi·ªÉm)\n\n"
        "2. **X√≥a ch·ªâ ch·∫•m c√¥ng:**\n"
        "   - Ch·ªâ x√≥a t·∫•t c·∫£ b·∫£n ghi ch·∫•m c√¥ng\n"
        "   - Gi·ªØ l·∫°i: ƒê∆°n ngh·ªâ ph√©p, Ng∆∞·ªùi d√πng, Ph√≤ng ban, Ng√†y l·ªÖ\n\n"
        "3. **X√≥a ch·ªâ ƒë∆°n ngh·ªâ ph√©p:**\n"
        "   - Ch·ªâ x√≥a t·∫•t c·∫£ ƒë∆°n ngh·ªâ ph√©p\n"
        "   - Gi·ªØ l·∫°i: Ch·∫•m c√¥ng, Ng∆∞·ªùi d√πng, Ph√≤ng ban, Ng√†y l·ªÖ\n\n"
        "4. **X√≥a ch·ªâ b·∫£n ghi (Records only):**\n"
        "   - X√≥a: Ch·∫•m c√¥ng v√† ƒê∆°n ngh·ªâ ph√©p\n"
        "   - Gi·ªØ l·∫°i: Ng∆∞·ªùi d√πng, Ph√≤ng ban, Ng√†y l·ªÖ\n\n"
        "**C√ÅCH TH·ª∞C HI·ªÜN (N·∫øu c√≥ giao di·ªán):**\n\n"
        "1. V√†o trang qu·∫£n l√Ω h·ªá th·ªëng (n·∫øu c√≥) ho·∫∑c s·ª≠ d·ª•ng API\n"
        "2. Ch·ªçn lo·∫°i x√≥a mu·ªën th·ª±c hi·ªán\n"
        "3. Nh·∫≠p m·∫≠t kh·∫©u Admin ƒë·ªÉ x√°c nh·∫≠n\n"
        "4. ƒê·ªçc k·ªπ c·∫£nh b√°o nguy hi·ªÉm\n"
        "5. Click **X√°c nh·∫≠n x√≥a** (m√†u ƒë·ªè, c√≥ icon c·∫£nh b√°o)\n"
        "6. H·ªá th·ªëng s·∫Ω x√≥a d·ªØ li·ªáu v√† hi·ªÉn th·ªã th√¥ng b√°o k·∫øt qu·∫£\n\n"
        "**L∆∞u √Ω c·ª±c k·ª≥ quan tr·ªçng:**\n"
        "- **KH√îNG TH·ªÇ KH√îI PH·ª§C** d·ªØ li·ªáu sau khi x√≥a\n"
        "- **PH·∫¢I SAO L∆ØU** tr∆∞·ªõc khi th·ª±c hi·ªán\n"
        "- Ch·ªâ d√πng trong m√¥i tr∆∞·ªùng test ho·∫∑c khi th·ª±c s·ª± c·∫ßn thi·∫øt\n"
        "- N·∫øu kh√¥ng ch·∫Øc ch·∫Øn, **KH√îNG N√äN** s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y\n"
        "- N√™n li√™n h·ªá developer ho·∫∑c qu·∫£n tr·ªã vi√™n h·ªá th·ªëng tr∆∞·ªõc khi x√≥a\n"
        "- T√≠nh nƒÉng n√†y c√≥ th·ªÉ kh√¥ng c√≥ giao di·ªán, ch·ªâ c√≥ API (d√†nh cho developer)\n\n"
    )


def _get_chatbot_embedder():
    """Lazy-load sentence-transformers ƒë·ªÉ nh√∫ng c√¢u h·ªèi / context."""
    global _chatbot_embedder
    if _chatbot_embedder is not None:
        return _chatbot_embedder
    try:
        from sentence_transformers import SentenceTransformer
        with _chatbot_rag_lock:
            if _chatbot_embedder is None:
                _chatbot_embedder = SentenceTransformer(
                    CHATBOT_EMBED_MODEL, device="cpu"
                )
        return _chatbot_embedder
    except Exception as e:
        try:
            print(f"[CHATBOT] Kh√¥ng load ƒë∆∞·ª£c embedder: {e}")
        except Exception:
            pass
        return None


def _get_chatbot_collection():
    """Lazy-load Chroma collection (persistent) cho RAG."""
    global _chatbot_collection
    if _chatbot_collection is not None:
        return _chatbot_collection
    try:
        import chromadb
        with _chatbot_rag_lock:
            if _chatbot_collection is None:
                # T·∫Øt telemetry khi t·∫°o client (bi·∫øn m√¥i tr∆∞·ªùng ƒë√£ ƒë∆∞·ª£c set ·ªü tr√™n)
                try:
                    client = chromadb.PersistentClient(
                        path=CHATBOT_KB_PATH,
                        settings=chromadb.Settings(anonymized_telemetry=False)
                    )
                except TypeError:
                    # N·∫øu Settings kh√¥ng h·ªó tr·ª£ anonymized_telemetry, d√πng c√°ch kh√°c
                    client = chromadb.PersistentClient(path=CHATBOT_KB_PATH)
                _chatbot_collection = client.get_or_create_collection(
                    name=CHATBOT_KB_COLLECTION
                )
        return _chatbot_collection
    except Exception as e:
        try:
            print(f"[CHATBOT] Kh√¥ng m·ªü ƒë∆∞·ª£c knowledge store: {e}")
        except Exception:
            pass
        return None


def _run_chatbot_index_now():
    """G·ªçi script index n·∫øu c√≥, tr√°nh crash n·∫øu thi·∫øu ph·ª• thu·ªôc."""
    with _chatbot_index_lock:
        try:
            import scripts.index_knowledge as kb

            kb.main()
            try:
                print("[CHATBOT] ƒê√£ index knowledge store.")
            except Exception:
                pass
        except Exception as e:
            try:
                print(f"[CHATBOT] Kh√¥ng th·ªÉ index t·ª± ƒë·ªông: {e}")
            except Exception:
                pass


def _ensure_chatbot_kb_ready():
    """
    Ki·ªÉm tra store ƒë√£ c√≥ d·ªØ li·ªáu; n·∫øu tr·ªëng th√¨ th·ª≠ index t·ª± ƒë·ªông (n·∫øu b·∫≠t).
    """
    global _chatbot_kb_ready
    if _chatbot_kb_ready:
        return
    coll = _get_chatbot_collection()
    if not coll:
        return
    try:
        count = coll.count()
    except Exception:
        count = 0

    if count == 0 and CHATBOT_AUTO_INDEX == '1':
        _run_chatbot_index_now()
        try:
            count = coll.count()
        except Exception:
            count = 0
    _chatbot_kb_ready = count > 0


def _chatbot_kb_scheduler(interval_hours: int = 24):
    """
    Thread n·ªÅn: re-index ƒë·ªãnh k·ª≥ ƒë·ªÉ c·∫≠p nh·∫≠t thay ƒë·ªïi UI/logic.
    """
    if CHATBOT_AUTO_INDEX != '1':
        return
    # Kh·ªüi ƒë·ªông tr·ªÖ v√†i gi√¢y ƒë·ªÉ tr√°nh c·∫°nh tranh khi app m·ªõi l√™n
    time.sleep(10)
    while True:
        try:
            _run_chatbot_index_now()
        except Exception:
            pass
        # Ch·ªù l·∫ßn sau
        time.sleep(interval_hours * 3600)


def _retrieve_chatbot_context(question: str, top_k: int = CHATBOT_TOP_K, max_chars: int = 1500) -> str:
    """
    Truy v·∫•n vector store ƒë·ªÉ l·∫•y ng·ªØ c·∫£nh n·ªôi b·ªô, gh√©p v√†o prompt.
    """
    if not question:
        return ""
    embedder = _get_chatbot_embedder()
    collection = _get_chatbot_collection()
    if not embedder or not collection:
        return ""

    _ensure_chatbot_kb_ready()

    try:
        q_emb = embedder.encode([question], normalize_embeddings=True).tolist()[0]
    except Exception as e:
        try:
            print(f"[CHATBOT] L·ªói encode c√¢u h·ªèi: {e}")
        except Exception:
            pass
        return ""

    try:
        res = collection.query(
            query_embeddings=[q_emb],
            n_results=top_k,
            include=["documents", "metadatas", "distances"],
        )
    except Exception as e:
        try:
            print(f"[CHATBOT] L·ªói truy v·∫•n knowledge store: {e}")
        except Exception:
            pass
        return ""

    docs = (res.get("documents") or [[]])[0]
    metas = (res.get("metadatas") or [[]])[0]
    if not docs:
        return ""

    lines = []
    remaining = max_chars
    for doc, meta in zip(docs, metas):
        path = (meta or {}).get("path", "unknown")
        snippet = (doc or "").strip()
        if not snippet:
            continue
        if len(snippet) > remaining:
            snippet = snippet[: remaining - 3] + "..."
        if remaining <= 0:
            break
        lines.append(f"- [{path}] {snippet}")
        remaining -= len(snippet)

    if not lines:
        return ""
    return "Ng·ªØ c·∫£nh n·ªôi b·ªô (t√≥m t·∫Øt):\n" + "\n".join(lines)


# Cache cho chatbot - l∆∞u c√¢u tr·∫£ l·ªùi th∆∞·ªùng g·∫∑p
_chatbot_cache = {}
_chatbot_cache_lock = threading.Lock()
CHATBOT_CACHE_SIZE = 100  # Gi·ªØ t·ªëi ƒëa 100 c√¢u h·ªèi trong cache
_CHATBOT_CLARIFY_MESSAGE = "T√¥i kh√¥ng hi·ªÉu b·∫°n ƒëang n√≥i g√¨. B·∫°n vui l√≤ng m√¥ t·∫£ k·ªπ v√† chi ti·∫øt h∆°n (m·ª•c ti√™u b·∫°n mu·ªën l√†m, trang b·∫°n ƒëang ·ªü, c√°c n√∫t ho·∫∑c tr∆∞·ªùng b·∫°n th·∫•y)."

def _sanitize_chatbot_output(content: str) -> str:
    """
    Lo·∫°i b·ªè ph·∫ßn m·ªü ƒë·∫ßu mang t√≠nh t·ª± s·ª±, gi·ªØ l·∫°i ph·∫ßn h∆∞·ªõng d·∫´n/b∆∞·ªõc h√†nh ƒë·ªông.
    """
    try:
        if not isinstance(content, str) or not content:
            return content

        skip_phrases = [
            "ƒë·∫ßu ti√™n, t√¥i x√°c ƒë·ªãnh",
            "t√¥i x√°c ƒë·ªãnh",
            "t√¥i c·∫ßn",
            "t√¥i s·∫Ω",
            "m√¨nh s·∫Ω",
            "m√¨nh c·∫ßn",
            "t√¥i th·∫•y",
            "t√¥i hi·ªÉu",
            "t√¥i s·∫Ω h∆∞·ªõng d·∫´n",
            "t√¥i c·∫ßn h∆∞·ªõng d·∫´n",
        ]

        cleaned_lines = []
        for raw_line in content.splitlines():
            line = raw_line.strip()
            if not line:
                continue
            lower_line = line.lower()
            if any(phrase in lower_line for phrase in skip_phrases):
                continue
            cleaned_lines.append(line)

        if not cleaned_lines:
            return content.strip()

        # B·ªè ph·∫ßn m·ªü ƒë·∫ßu tr∆∞·ªõc d√≤ng ƒë·∫ßu ti√™n l√† bullet/b∆∞·ªõc
        import re
        first_idx = 0
        for idx, ln in enumerate(cleaned_lines):
            if re.match(r"^(\d+\.|\-|‚Ä¢)", ln):
                first_idx = idx
                break
        cleaned_lines = cleaned_lines[first_idx:]

        cleaned = "\n".join(cleaned_lines).strip()
        return cleaned or content.strip()
    except Exception:
        return content.strip() if isinstance(content, str) else content

def _get_fallback_answer(user_message: str) -> str:
    """
    Tr·∫£ v·ªÅ c√¢u tr·∫£ l·ªùi m·∫∑c ƒë·ªãnh khi Ollama kh√¥ng kh·∫£ d·ª•ng.
    D·ª±a v√†o t·ª´ kh√≥a trong c√¢u h·ªèi ƒë·ªÉ tr·∫£ l·ªùi ph√π h·ª£p.
    """
    message_lower = user_message.lower()
    answer = ""
    
    # C√¢u tr·∫£ l·ªùi m·∫∑c ƒë·ªãnh cho c√°c c√¢u h·ªèi th∆∞·ªùng g·∫∑p
    # L∆∞u √Ω: N·∫øu Ollama kh√¥ng kh·∫£ d·ª•ng, tr·∫£ v·ªÅ h∆∞·ªõng d·∫´n chi ti·∫øt t·ª´ system prompt
    if any(keyword in message_lower for keyword in ['ƒë∆°n ngh·ªâ', 't·∫°o ƒë∆°n', 'ngh·ªâ ph√©p', 'xin ngh·ªâ', 'h∆∞·ªõng d·∫´n t·∫°o']):
        # Tr·∫£ v·ªÅ h∆∞·ªõng d·∫´n chi ti·∫øt t·ª´ system prompt thay v√¨ c√¢u tr·∫£ l·ªùi ng·∫Øn g·ªçn
        system_prompt = _build_chatbot_system_prompt()
        # T√¨m ph·∫ßn h∆∞·ªõng d·∫´n t·∫°o ƒë∆°n ngh·ªâ ph√©p trong system prompt
        if "=== 1. ƒêƒÇNG K√ù NGH·ªà PH√âP" in system_prompt:
            start_idx = system_prompt.find("=== 1. ƒêƒÇNG K√ù NGH·ªà PH√âP")
            # T√¨m ph·∫ßn k·∫øt th√∫c (ph·∫ßn ti·∫øp theo b·∫Øt ƒë·∫ßu b·∫±ng "===")
            next_section = system_prompt.find("\n===", start_idx + 50)
            if next_section > 0:
                leave_section = system_prompt[start_idx:next_section]
            else:
                # N·∫øu kh√¥ng t√¨m th·∫•y ph·∫ßn ti·∫øp theo, l·∫•y ƒë·∫øn h·∫øt ho·∫∑c 5000 k√Ω t·ª±
                leave_section = system_prompt[start_idx:start_idx+5000]
            
            # Format l·∫°i ƒë·ªÉ d·ªÖ ƒë·ªçc h∆°n
            answer = f"""ƒê·ªÉ t·∫°o ƒë∆°n ngh·ªâ ph√©p, b·∫°n l√†m theo c√°c b∆∞·ªõc CHI TI·∫æT sau:\n\n{leave_section}\n\n**L∆∞u √Ω:** ƒê∆°n ngh·ªâ ph√©p c·∫ßn ƒë∆∞·ª£c ph√™ duy·ªát b·ªüi Tr∆∞·ªüng nh√≥m ‚Üí Qu·∫£n l√Ω ‚Üí Admin tr∆∞·ªõc khi c√≥ hi·ªáu l·ª±c."""
        else:
            # Fallback n·∫øu kh√¥ng t√¨m th·∫•y trong system prompt
            answer = """ƒê·ªÉ t·∫°o ƒë∆°n ngh·ªâ ph√©p, b·∫°n l√†m theo c√°c b∆∞·ªõc sau:

1. **V√†o menu "ƒê∆°n ngh·ªâ ph√©p"** tr√™n thanh ƒëi·ªÅu h∆∞·ªõng
2. **Nh·∫•n n√∫t "T·∫°o ƒë∆°n ngh·ªâ ph√©p m·ªõi"**
3. **ƒêi·ªÅn th√¥ng tin:**
   - Ch·ªçn lo·∫°i ngh·ªâ (ph√©p nƒÉm, kh√¥ng l∆∞∆°ng, ƒë·∫∑c bi·ªát)
   - Ch·ªçn ng√†y b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c
   - Ch·ªçn gi·ªù (n·∫øu ngh·ªâ n·ª≠a ng√†y)
   - Nh·∫≠p l√Ω do ngh·ªâ
4. **Nh·∫•n "G·ª≠i ƒë∆°n"** ƒë·ªÉ g·ª≠i ƒë∆°n l√™n tr∆∞·ªüng nh√≥m ph√™ duy·ªát

**L∆∞u √Ω:** ƒê∆°n ngh·ªâ ph√©p c·∫ßn ƒë∆∞·ª£c ph√™ duy·ªát b·ªüi Tr∆∞·ªüng nh√≥m ‚Üí Qu·∫£n l√Ω ‚Üí Admin tr∆∞·ªõc khi c√≥ hi·ªáu l·ª±c."""
    
    elif any(keyword in message_lower for keyword in ['l·ªãch s·ª≠ ch·∫•m c√¥ng', 'xem ch·∫•m c√¥ng', 'ch·∫•m c√¥ng']):
        answer = """ƒê·ªÉ xem l·ªãch s·ª≠ ch·∫•m c√¥ng c·ªßa B·∫¢N TH√ÇN b·∫°n trong h·ªá th·ªëng:

1. **V√†o trang "Dashboard"** (Trang ch·ªß sau khi ƒëƒÉng nh·∫≠p).
2. ·ªû ph√≠a d∆∞·ªõi trang, t√¨m b·∫£ng **"L·ªãch s·ª≠ ƒëƒÉng k√Ω ch·∫•m c√¥ng"** ho·∫∑c b·∫£ng hi·ªÉn th·ªã c√°c ng√†y/b·∫£n ghi ch·∫•m c√¥ng c·ªßa b·∫°n.
3. **Cu·ªôn xu·ªëng/qua c√°c trang** trong b·∫£ng ƒë·ªÉ xem ƒë·∫ßy ƒë·ªß c√°c b·∫£n ghi ch·∫•m c√¥ng tr∆∞·ªõc ƒë√¢y.

**L∆∞u √Ω quan tr·ªçng:**
- H∆∞·ªõng d·∫´n n√†y CH·ªà m√¥ t·∫£ nh·ªØng g√¨ nh√¢n vi√™n th√¥ng th∆∞·ªùng c√≥ th·ªÉ l√†m: xem l·∫°i l·ªãch s·ª≠ ch·∫•m c√¥ng c·ªßa ch√≠nh m√¨nh tr√™n Dashboard.
- N·∫øu tr√™n giao di·ªán c·ªßa b·∫°n **kh√¥ng th·∫•y c√°c b·ªô l·ªçc n√¢ng cao, t√¨m ki·∫øm, ho·∫∑c n√∫t xu·∫•t Excel**, h√£y hi·ªÉu l√† b·∫°n **kh√¥ng c√≥ c√°c ch·ª©c nƒÉng ƒë√≥**, v√† chatbot s·∫Ω KH√îNG ƒë∆∞·ª£c ph√©p n√≥i r·∫±ng ch√∫ng t·ªìn t·∫°i.
- N·∫øu b·∫°n l√† Tr∆∞·ªüng nh√≥m/Qu·∫£n l√Ω/Admin v√† c·∫ßn xem l·ªãch s·ª≠ ch·∫•m c√¥ng c·ªßa ng∆∞·ªùi kh√°c ho·∫∑c xu·∫•t Excel b√°o c√°o, h√£y v√†o c√°c m√†n h√¨nh qu·∫£n l√Ω/ch·ª©c nƒÉng b√°o c√°o t∆∞∆°ng ·ª©ng m√† h·ªá th·ªëng c·ªßa b·∫°n ƒëang cung c·∫•p (t√πy c·∫•u h√¨nh t·ª´ng ƒë∆°n v·ªã)."""
    
    elif any(keyword in message_lower for keyword in ['ƒë·ªïi m·∫≠t kh·∫©u', 'thay ƒë·ªïi m·∫≠t kh·∫©u', 'password']):
        answer = """ƒê·ªÉ ƒë·ªïi m·∫≠t kh·∫©u:

1. **Nh·∫•n v√†o t√™n ng∆∞·ªùi d√πng** ·ªü g√≥c tr√™n b√™n ph·∫£i
2. **Ch·ªçn "ƒê·ªïi m·∫≠t kh·∫©u"** trong menu
3. **Nh·∫≠p:**
   - M·∫≠t kh·∫©u c≈©
   - M·∫≠t kh·∫©u m·ªõi (t·ªëi thi·ªÉu 6 k√Ω t·ª±)
   - X√°c nh·∫≠n m·∫≠t kh·∫©u m·ªõi
4. **Nh·∫•n "L∆∞u"** ƒë·ªÉ ho√†n t·∫•t

**L∆∞u √Ω:** M·∫≠t kh·∫©u m·ªõi ph·∫£i kh√°c m·∫≠t kh·∫©u c≈© v√† c√≥ ƒë·ªô d√†i t·ªëi thi·ªÉu 6 k√Ω t·ª±."""
    
    elif any(keyword in message_lower for keyword in ['ph√™ duy·ªát', 'duy·ªát ƒë∆°n', 'approve']):
        answer = """ƒê·ªÉ ph√™ duy·ªát ƒë∆°n ngh·ªâ ph√©p (d√†nh cho Tr∆∞·ªüng nh√≥m/Qu·∫£n l√Ω/Admin):

1. **V√†o "ƒê∆°n ngh·ªâ ph√©p"** ‚Üí Tab "Ch·ªù ph√™ duy·ªát"
2. **Xem danh s√°ch ƒë∆°n** c·∫ßn ph√™ duy·ªát
3. **Nh·∫•n "Xem chi ti·∫øt"** ƒë·ªÉ xem th√¥ng tin ƒë∆°n
4. **Ch·ªçn h√†nh ƒë·ªông:**
   - **Ph√™ duy·ªát:** Chuy·ªÉn ƒë∆°n l√™n c·∫•p tr√™n (ho·∫∑c ho√†n t·∫•t n·∫øu l√† Admin)
   - **T·ª´ ch·ªëi:** Nh·∫≠p l√Ω do t·ª´ ch·ªëi v√† tr·∫£ v·ªÅ nh√¢n vi√™n

**Quy tr√¨nh ph√™ duy·ªát:** Nh√¢n vi√™n ‚Üí Tr∆∞·ªüng nh√≥m ‚Üí Qu·∫£n l√Ω ‚Üí Admin"""
    
    elif any(keyword in message_lower for keyword in ['ch·∫•m c√¥ng', 'check in', 'check out']):
        answer = """ƒê·ªÉ ch·∫•m c√¥ng:

1. **V√†o "Dashboard"** ho·∫∑c menu "Ch·∫•m c√¥ng"
2. **Ch·ªçn ng√†y** c·∫ßn ch·∫•m c√¥ng
3. **Nh·∫≠p th√¥ng tin:**
   - Gi·ªù v√†o (check-in)
   - Gi·ªù ra (check-out)
   - Ca l√†m vi·ªác
   - Ghi ch√∫ (n·∫øu c√≥)
4. **Nh·∫•n "L∆∞u"** ƒë·ªÉ l∆∞u b·∫£n ghi ch·∫•m c√¥ng

**L∆∞u √Ω:** H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√≠nh gi·ªù l√†m vi·ªác, gi·ªù tƒÉng ca d·ª±a tr√™n gi·ªù v√†o/ra c·ªßa b·∫°n."""
    
    else:
        answer = """Xin ch√†o! M√¨nh l√† tr·ª£ l√Ω AI c·ªßa h·ªá th·ªëng ch·∫•m c√¥ng & ngh·ªâ ph√©p DMI.

Hi·ªán t·∫°i d·ªãch v·ª• AI (Ollama) ƒëang t·∫°m th·ªùi kh√¥ng kh·∫£ d·ª•ng. Tuy nhi√™n, m√¨nh v·∫´n c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n:

**C√°c ch·ª©c nƒÉng ch√≠nh:**
‚Ä¢ üìù T·∫°o v√† qu·∫£n l√Ω ƒë∆°n ngh·ªâ ph√©p
‚Ä¢ ‚è∞ Ch·∫•m c√¥ng h√†ng ng√†y
‚Ä¢ üìä Xem l·ªãch s·ª≠ ch·∫•m c√¥ng v√† ngh·ªâ ph√©p
‚Ä¢ üîê ƒê·ªïi m·∫≠t kh·∫©u
‚Ä¢ ‚úÖ Ph√™ duy·ªát ƒë∆°n ngh·ªâ ph√©p (d√†nh cho qu·∫£n l√Ω)

**B·∫°n c√≥ th·ªÉ h·ªèi:**
‚Ä¢ "C√°ch t·∫°o ƒë∆°n ngh·ªâ ph√©p"
‚Ä¢ "C√°ch xem l·ªãch s·ª≠ ch·∫•m c√¥ng"
‚Ä¢ "C√°ch ƒë·ªïi m·∫≠t kh·∫©u"
‚Ä¢ "C√°ch ph√™ duy·ªát ƒë∆°n ngh·ªâ ph√©p"

**ƒê·ªÉ kh·∫Øc ph·ª•c l·ªói AI:**
1. **Ki·ªÉm tra Ollama ƒëang ch·∫°y:**
   - M·ªü PowerShell/Terminal m·ªõi
   - Ch·∫°y: `ollama serve` (ƒë·ªÉ ch·∫°y trong c·ª≠a s·ªï ri√™ng)
   - Ho·∫∑c ch·∫°y: `python run_ollama_chatbot.py` (t·ª± ƒë·ªông kh·ªüi ƒë·ªông Ollama)

2. **Ki·ªÉm tra model ƒë√£ t·∫£i:**
   - Ch·∫°y: `ollama list` ƒë·ªÉ xem models c√≥ s·∫µn
   - N·∫øu thi·∫øu model qwen2.5:7b, ch·∫°y: `ollama pull qwen2.5:7b`

3. **Kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng:**
   - Sau khi Ollama ƒë√£ ch·∫°y, refresh trang web ho·∫∑c kh·ªüi ƒë·ªông l·∫°i app.py

**L∆∞u √Ω:** N·∫øu Ollama ƒë√£ c√†i ƒë·∫∑t nh∆∞ng v·∫´n l·ªói, c√≥ th·ªÉ do app.py ƒë√£ kh·ªüi ƒë·ªông tr∆∞·ªõc khi Ollama s·∫µn s√†ng. H√£y ƒë·∫£m b·∫£o Ollama ch·∫°y tr∆∞·ªõc khi kh·ªüi ƒë·ªông app."""

    return _sanitize_chatbot_output(answer) or _CHATBOT_CLARIFY_MESSAGE

def call_chatbot_llm(user_message: str, user_context: dict | None = None, conversation_history: list | None = None, ui_context: dict | None = None) -> str:
    """
    G·ªçi LLM (Ollama ho·∫∑c DeepSeek) ƒë·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng h·ªá th·ªëng.
    C√≥ cache ƒë·ªÉ tr·∫£ l·ªùi nhanh cho c√¢u h·ªèi th∆∞·ªùng g·∫∑p.
    H·ªó tr·ª£ l·ªãch s·ª≠ h·ªôi tho·∫°i ƒë·ªÉ duy tr√¨ ng·ªØ c·∫£nh xuy√™n su·ªët.
    """
    # Ki·ªÉm tra cache tr∆∞·ªõc (ch·ªâ cache khi kh√¥ng c√≥ l·ªãch s·ª≠ ƒë·ªÉ tr√°nh cache sai)
    import hashlib
    cache_key = hashlib.md5((user_message + str(user_context) + (str(conversation_history) if conversation_history else '')).encode('utf-8')).hexdigest()
    
    # Ch·ªâ d√πng cache n·∫øu kh√¥ng c√≥ l·ªãch s·ª≠ h·ªôi tho·∫°i (ƒë·ªÉ ƒë·∫£m b·∫£o ng·ªØ c·∫£nh ch√≠nh x√°c)
    if not conversation_history or len(conversation_history) == 0:
        with _chatbot_cache_lock:
            if cache_key in _chatbot_cache:
                try:
                    print(f"[CHATBOT] Cache hit - tr·∫£ l·ªùi ngay l·∫≠p t·ª©c")
                except Exception:
                    pass
                return _chatbot_cache[cache_key]
    
    # Kh·ªüi ƒë·ªông scheduler t·ª± ƒë·ªông index n·∫øu c·∫ßn
    try:
        if CHATBOT_AUTO_INDEX == '1' and not getattr(call_chatbot_llm, "_kb_thread_started", False):
            t = threading.Thread(target=_chatbot_kb_scheduler, daemon=True)
            t.start()
            setattr(call_chatbot_llm, "_kb_thread_started", True)
    except Exception:
        pass

    # Chu·∫©n b·ªã system prompt + context ng∆∞·ªùi d√πng (n·∫øu c√≥)
    system_prompt = _build_chatbot_system_prompt()

    if user_context:
        # Th√™m b·ªëi c·∫£nh ng∆∞·ªùi d√πng v√†o prompt ƒë·ªÉ AI t∆∞ v·∫•n ch√≠nh x√°c h∆°n
        try:
            ctx_lines = []
            if 'user_name' in user_context and user_context['user_name']:
                ctx_lines.append(f"T√™n ng∆∞·ªùi d√πng: {user_context['user_name']}")
            if 'role' in user_context and user_context['role']:
                role = user_context['role']
                ctx_lines.append(f"Vai tr√≤ hi·ªán t·∫°i trong h·ªá th·ªëng: {role}")
                # Th√™m h∆∞·ªõng d·∫´n c·ª• th·ªÉ v·ªÅ vai tr√≤
                role_instructions = {
                    'EMPLOYEE': 'Ng∆∞·ªùi d√πng n√†y l√† NH√ÇN VI√äN. CH·ªà tr·∫£ l·ªùi v·ªÅ c√°c ch·ª©c nƒÉng: ch·∫•m c√¥ng, t·∫°o/xem/s·ª≠a/x√≥a ƒë∆°n ngh·ªâ ph√©p c·ªßa b·∫£n th√¢n, ƒë·ªïi m·∫≠t kh·∫©u. KH√îNG ƒë·ªÅ c·∫≠p ƒë·∫øn ph√™ duy·ªát ƒë∆°n, qu·∫£n l√Ω ng∆∞·ªùi d√πng, ho·∫∑c c√°c ch·ª©c nƒÉng qu·∫£n tr·ªã.',
                    'TEAM_LEADER': 'Ng∆∞·ªùi d√πng n√†y l√† TR∆Ø·ªûNG NH√ìM. C√≥ th·ªÉ tr·∫£ l·ªùi v·ªÅ: t·∫•t c·∫£ ch·ª©c nƒÉng c·ªßa nh√¢n vi√™n + ph√™ duy·ªát/t·ª´ ch·ªëi ƒë∆°n ngh·ªâ ph√©p c·ªßa nh√¢n vi√™n trong nh√≥m, xem d·ªØ li·ªáu nh√¢n vi√™n trong nh√≥m. KH√îNG ƒë·ªÅ c·∫≠p ƒë·∫øn qu·∫£n l√Ω ng∆∞·ªùi d√πng/ph√≤ng ban/ng√†y l·ªÖ.',
                    'MANAGER': 'Ng∆∞·ªùi d√πng n√†y l√† QU·∫¢N L√ù. C√≥ th·ªÉ tr·∫£ l·ªùi v·ªÅ: t·∫•t c·∫£ ch·ª©c nƒÉng c·ªßa Tr∆∞·ªüng nh√≥m + ph√™ duy·ªát/t·ª´ ch·ªëi ƒë∆°n ƒë√£ ƒë∆∞·ª£c Leader ph√™ duy·ªát, xem d·ªØ li·ªáu t·∫•t c·∫£ nh√¢n vi√™n trong ph√≤ng ban. KH√îNG ƒë·ªÅ c·∫≠p ƒë·∫øn qu·∫£n l√Ω ng∆∞·ªùi d√πng/ph√≤ng ban/ng√†y l·ªÖ.',
                    'ADMIN': 'Ng∆∞·ªùi d√πng n√†y l√† QU·∫¢N TR·ªä VI√äN. C√≥ th·ªÉ tr·∫£ l·ªùi v·ªÅ T·∫§T C·∫¢ c√°c ch·ª©c nƒÉng trong h·ªá th·ªëng bao g·ªìm: qu·∫£n l√Ω ng∆∞·ªùi d√πng, qu·∫£n l√Ω ph√≤ng ban, qu·∫£n l√Ω ng√†y l·ªÖ, ph√™ duy·ªát t·∫•t c·∫£ ƒë∆°n, xem v√† xu·∫•t t·∫•t c·∫£ d·ªØ li·ªáu.'
                }
                if role in role_instructions:
                    ctx_lines.append(f"H∆Ø·ªöNG D·∫™N TR·∫¢ L·ªúI: {role_instructions[role]}")
            if 'department' in user_context and user_context['department']:
                ctx_lines.append(f"Ph√≤ng ban: {user_context['department']}")
            if ctx_lines:
                system_prompt += "\n\n=== TH√îNG TIN NG·ªÆ C·∫¢NH NG∆Ø·ªúI D√ôNG HI·ªÜN T·∫†I ===\n" + "\n".join(
                    f"{line}" for line in ctx_lines
                ) + "\n\nQUAN TR·ªåNG: D·ª±a v√†o vai tr√≤ tr√™n, CH·ªà tr·∫£ l·ªùi v·ªÅ c√°c ch·ª©c nƒÉng m√† vai tr√≤ ƒë√≥ c√≥ quy·ªÅn th·ª±c hi·ªán. N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ ch·ª©c nƒÉng kh√¥ng thu·ªôc vai tr√≤ c·ªßa h·ªç, gi·∫£i th√≠ch r√µ r√†ng v√† ƒë·ªÅ xu·∫•t li√™n h·ªá ng∆∞·ªùi c√≥ quy·ªÅn.\n"
        except Exception:
            # Kh√¥ng ƒë·ªÉ l·ªói context l√†m h·ªèng c·∫£ chatbot
            pass

    # Th√™m UI context v√†o prompt ƒë·ªÉ AI c√≥ th·ªÉ h∆∞·ªõng d·∫´n ch√≠nh x√°c d·ª±a tr√™n giao di·ªán hi·ªán t·∫°i
    if ui_context and isinstance(ui_context, dict):
        try:
            ui_info = []
            
            # Th√¥ng tin trang hi·ªán t·∫°i
            if ui_context.get('pageTitle'):
                ui_info.append(f"Trang hi·ªán t·∫°i: {ui_context.get('pageTitle')}")
            if ui_context.get('currentURL'):
                ui_info.append(f"URL: {ui_context.get('currentURL')}")
            
            # Th√¥ng tin c√°c input/textarea/select
            if ui_context.get('formInputs') and len(ui_context['formInputs']) > 0:
                ui_info.append("\nC√°c tr∆∞·ªùng nh·∫≠p li·ªáu tr√™n trang:")
                for inp in ui_context['formInputs'][:20]:  # Gi·ªõi h·∫°n 20 ƒë·ªÉ kh√¥ng qu√° d√†i
                    label = inp.get('label', '').strip()
                    placeholder = inp.get('placeholder', '').strip()
                    value = inp.get('value', '')
                    required = inp.get('required', False)
                    
                    # Ch·ªâ d√πng label ho·∫∑c placeholder, kh√¥ng d√πng name/id (k·ªπ thu·∫≠t)
                    field_name = label or placeholder
                    if not field_name:
                        continue  # B·ªè qua n·∫øu kh√¥ng c√≥ t√™n hi·ªÉn th·ªã
                    
                    desc = f"  - {field_name}"
                    if value and str(value).strip() and str(value) not in ['unchecked', '']:
                        # Ch·ªâ hi·ªÉn th·ªã gi√° tr·ªã n·∫øu kh√¥ng qu√° d√†i v√† c√≥ √Ω nghƒ©a
                        value_str = str(value).strip()
                        if len(value_str) <= 50:
                            desc += f" (gi√° tr·ªã hi·ªán t·∫°i: '{value_str}')"
                    if required:
                        desc += " [B·∫ÆT BU·ªòC]"
                    ui_info.append(desc)
            
            # Th√¥ng tin c√°c n√∫t
            if ui_context.get('buttons') and len(ui_context['buttons']) > 0:
                ui_info.append("\nC√°c n√∫t tr√™n trang:")
                for btn in ui_context['buttons'][:15]:  # Gi·ªõi h·∫°n 15
                    text = btn.get('text', '').strip()
                    disabled = btn.get('disabled', False)
                    # Ch·ªâ d√πng text, kh√¥ng d√πng id (k·ªπ thu·∫≠t)
                    if text:
                        desc = f"  - {text}"
                        if disabled:
                            desc += " [ƒêANG B·ªä V√î HI·ªÜU H√ìA]"
                        ui_info.append(desc)
            
            # Th√¥ng tin c√°c dropdown
            if ui_context.get('dropdowns') and len(ui_context['dropdowns']) > 0:
                ui_info.append("\nC√°c dropdown/select tr√™n trang:")
                for dd in ui_context['dropdowns'][:10]:  # Gi·ªõi h·∫°n 10
                    label = dd.get('label', '').strip()
                    selected = dd.get('selectedText', '').strip()
                    options = dd.get('options', [])
                    
                    # Ch·ªâ d√πng label, kh√¥ng d√πng name (k·ªπ thu·∫≠t)
                    if not label:
                        continue  # B·ªè qua n·∫øu kh√¥ng c√≥ label
                    
                    desc = f"  - {label}"
                    if selected:
                        desc += f" (ƒë√£ ch·ªçn: '{selected}')"
                    if options and len(options) > 0:
                        # Ch·ªâ l·∫•y text hi·ªÉn th·ªã, kh√¥ng l·∫•y value (k·ªπ thu·∫≠t)
                        option_texts = [opt.get('text', '').strip() for opt in options[:5] if opt.get('text', '').strip()]
                        if len(options) > 5:
                            option_texts.append(f"... v√† {len(options) - 5} l·ª±a ch·ªçn kh√°c")
                        if option_texts:
                            desc += f" [c√°c l·ª±a ch·ªçn: {', '.join(option_texts)}]"
                    ui_info.append(desc)
            
            # Th√¥ng tin text/headings quan tr·ªçng
            if ui_context.get('textContent') and len(ui_context['textContent']) > 0:
                ui_info.append("\nC√°c ti√™u ƒë·ªÅ v√† text quan tr·ªçng:")
                for txt in ui_context['textContent'][:10]:  # Gi·ªõi h·∫°n 10
                    text = txt.get('text', '')
                    txt_type = txt.get('type', '')
                    if text:
                        desc = f"  - [{txt_type}] {text}"
                        ui_info.append(desc)
            
            # Th√¥ng tin b·∫£ng
            if ui_context.get('tables') and len(ui_context['tables']) > 0:
                ui_info.append("\nC√°c b·∫£ng d·ªØ li·ªáu tr√™n trang:")
                for tbl in ui_context['tables'][:5]:  # Gi·ªõi h·∫°n 5
                    headers = tbl.get('headers', [])
                    row_count = tbl.get('rowCount', 0)
                    desc = f"  - B·∫£ng c√≥ {len(headers)} c·ªôt"
                    if headers:
                        desc += f" ({', '.join(headers[:5])})"
                    if row_count > 0:
                        desc += f", {row_count} h√†ng d·ªØ li·ªáu"
                    ui_info.append(desc)
            
            if ui_info:
                system_prompt += "\n\nTH√îNG TIN GIAO DI·ªÜN HI·ªÜN T·∫†I (QUAN TR·ªåNG - D√ôNG ƒê·ªÇ H∆Ø·ªöNG D·∫™N CH√çNH X√ÅC):\n"
                system_prompt += "\n".join(ui_info)
                system_prompt += "\n\nL∆ØU √ù: Khi h∆∞·ªõng d·∫´n ng∆∞·ªùi d√πng, B·∫ÆT BU·ªòC ph·∫£i tham chi·∫øu CH√çNH X√ÅC c√°c t√™n tr∆∞·ªùng, t√™n n√∫t, gi√° tr·ªã hi·ªán t·∫°i m√† b·∫°n th·∫•y trong th√¥ng tin giao di·ªán ·ªü tr√™n. Kh√¥ng ƒë∆∞·ª£c b·ªãa ƒë·∫∑t ho·∫∑c ƒëo√°n m√≤ t√™n tr∆∞·ªùng/n√∫t."
                
        except Exception as e:
            try:
                print(f"[CHATBOT] L·ªói x·ª≠ l√Ω UI context: {e}")
            except Exception:
                pass

    # Th√™m ng·ªØ c·∫£nh n·ªôi b·ªô (RAG) n·∫øu c√≥ - v·ªõi timeout ƒë·ªÉ kh√¥ng ch·∫∑n qu√° l√¢u
    try:
        import signal
        rag_context = None
        
        # Th·ª≠ l·∫•y RAG context v·ªõi timeout 2 gi√¢y
        def _get_rag_with_timeout():
            try:
                return _retrieve_chatbot_context(user_message)
            except Exception:
                return None
        
        # Ch·∫°y RAG trong thread ri√™ng v·ªõi timeout
        import threading
        rag_result = [None]
        rag_done = threading.Event()
        
        def _rag_worker():
            try:
                rag_result[0] = _get_rag_with_timeout()
            except Exception:
                pass
            finally:
                rag_done.set()
        
        rag_thread = threading.Thread(target=_rag_worker, daemon=True)
        rag_thread.start()
        
        # Ch·ªù t·ªëi ƒëa 2 gi√¢y cho RAG
        if rag_done.wait(timeout=2.0):
            rag_context = rag_result[0]
        else:
            # Timeout - b·ªè qua RAG ƒë·ªÉ tr·∫£ l·ªùi nhanh h∆°n
            try:
                print(f"[CHATBOT] RAG timeout - b·ªè qua ƒë·ªÉ tr·∫£ l·ªùi nhanh h∆°n")
            except Exception:
                pass
        
        if rag_context:
            system_prompt += "\n" + rag_context
    except Exception as e:
        try:
            print(f"[CHATBOT] L·ªói RAG: {e}")
        except Exception:
            pass

    # ∆Øu ti√™n DeepSeek n·∫øu ƒë∆∞·ª£c c·∫•u h√¨nh ƒë·∫ßy ƒë·ªß
    provider = CHATBOT_PROVIDER
    try:
        print(f"[CHATBOT] Provider={provider}, model_ollama={OLLAMA_MODEL}, model_deepseek={DEEPSEEK_MODEL}")
        print(f"[CHATBOT] User message: {user_message[:200]}{'...' if len(user_message) > 200 else ''}")
    except Exception:
        pass
    if provider == 'deepseek' and DEEPSEEK_API_KEY:
        try:
            # X√¢y d·ª±ng danh s√°ch messages v·ªõi l·ªãch s·ª≠ h·ªôi tho·∫°i
            messages = [{"role": "system", "content": system_prompt}]
            
            # Th√™m l·ªãch s·ª≠ h·ªôi tho·∫°i n·∫øu c√≥
            if conversation_history:
                for msg in conversation_history:
                    # Chuy·ªÉn ƒë·ªïi role t·ª´ frontend format sang API format
                    role = msg.get('role', 'user')
                    if role == 'assistant':
                        messages.append({"role": "assistant", "content": msg.get('content', '')})
                    elif role == 'user':
                        messages.append({"role": "user", "content": msg.get('content', '')})
            
            # Th√™m tin nh·∫Øn hi·ªán t·∫°i
            messages.append({"role": "user", "content": user_message})
            
            payload = {
                "model": DEEPSEEK_MODEL,
                "messages": messages,
                "temperature": 0.15,
                "max_tokens": 2000,  # TƒÉng ƒë·ªÉ tr√°nh c·∫Øt n·ªôi dung, v·∫´n gi·ªØ c√¢u tr·∫£ l·ªùi g·ªçn
            }
            headers = {
                "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
                "Content-Type": "application/json",
            }
            if OPENROUTER_SITE:
                headers["HTTP-Referer"] = OPENROUTER_SITE
            if OPENROUTER_TITLE:
                headers["X-Title"] = OPENROUTER_TITLE
            resp = requests.post(DEEPSEEK_API_URL, json=payload, headers=headers, timeout=15)  # Gi·∫£m t·ª´ 60s xu·ªëng 15s
            resp.raise_for_status()
            data = resp.json()
            # DeepSeek s·ª≠ d·ª•ng schema t∆∞∆°ng t·ª± OpenAI Chat Completions
            answer = (data.get("choices", [{}])[0]
                        .get("message", {})
                        .get("content", "")
                        .strip()
                    or "Xin l·ªói, m√¨nh ch∆∞a nh·∫≠n ƒë∆∞·ª£c n·ªôi dung tr·∫£ l·ªùi t·ª´ DeepSeek.")
            try:
                print(f"[CHATBOT] DeepSeek answer length: {len(answer)}")
            except Exception:
                pass
            answer = _sanitize_chatbot_output(answer) or _CHATBOT_CLARIFY_MESSAGE
            # L∆∞u v√†o cache
            with _chatbot_cache_lock:
                if len(_chatbot_cache) >= CHATBOT_CACHE_SIZE:
                    oldest_key = next(iter(_chatbot_cache))
                    del _chatbot_cache[oldest_key]
                _chatbot_cache[cache_key] = answer
            return answer
        except Exception as e:
            print(f"[CHATBOT] L·ªói g·ªçi DeepSeek: {e}")
            # Fallback sang Ollama n·∫øu c√≥
            provider = 'ollama'

    # M·∫∑c ƒë·ªãnh / fallback: d√πng Ollama local
    try:
        # Ki·ªÉm tra k·∫øt n·ªëi Ollama tr∆∞·ªõc khi g·ªçi
        try:
            health_check = requests.get(OLLAMA_API_URL.replace('/api/chat', '/api/tags'), timeout=3)
            if health_check.status_code != 200:
                print(f"[CHATBOT] Ollama service tr·∫£ v·ªÅ status code: {health_check.status_code}")
                raise Exception(f"Ollama service kh√¥ng ph·∫£n h·ªìi (status: {health_check.status_code})")
            
            # Ki·ªÉm tra model c√≥ s·∫µn kh√¥ng
            try:
                tags_data = health_check.json()
                available_models = [model.get('name', '').split(':')[0] for model in tags_data.get('models', [])]
                model_name = OLLAMA_MODEL.split(':')[0]
                if model_name not in available_models:
                    print(f"[CHATBOT] Model '{OLLAMA_MODEL}' ch∆∞a ƒë∆∞·ª£c t·∫£i. Models c√≥ s·∫µn: {available_models}")
                    print(f"[CHATBOT] Vui l√≤ng ch·∫°y: ollama pull {OLLAMA_MODEL}")
                    # V·∫´n th·ª≠ g·ªçi, c√≥ th·ªÉ model ƒëang ƒë∆∞·ª£c pull t·ª± ƒë·ªông
            except Exception as model_check_err:
                print(f"[CHATBOT] Kh√¥ng th·ªÉ ki·ªÉm tra model: {model_check_err}")
                
        except requests.exceptions.ConnectionError as conn_err:
            print(f"[CHATBOT] ‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn Ollama t·∫°i {OLLAMA_API_URL.replace('/api/chat', '')}")
            print(f"[CHATBOT] L·ªói chi ti·∫øt: {conn_err}")
            print(f"[CHATBOT] üí° Gi·∫£i ph√°p: ƒê·∫£m b·∫£o Ollama ƒëang ch·∫°y b·∫±ng l·ªánh 'ollama serve'")
            print(f"[CHATBOT] ‚ö†Ô∏è  S·ª≠ d·ª•ng fallback answer v·ªõi h∆∞·ªõng d·∫´n chi ti·∫øt t·ª´ system prompt")
            fallback_answer = _get_fallback_answer(user_message)
            return fallback_answer
        except requests.exceptions.Timeout as timeout_err:
            print(f"[CHATBOT] ‚ùå Timeout khi ki·ªÉm tra Ollama (qu√° 3 gi√¢y)")
            print(f"[CHATBOT] üí° Gi·∫£i ph√°p: Ki·ªÉm tra Ollama c√≥ ƒëang ch·∫°y kh√¥ng")
            print(f"[CHATBOT] ‚ö†Ô∏è  S·ª≠ d·ª•ng fallback answer v·ªõi h∆∞·ªõng d·∫´n chi ti·∫øt t·ª´ system prompt")
            fallback_answer = _get_fallback_answer(user_message)
            return fallback_answer
        except Exception as conn_err:
            print(f"[CHATBOT] ‚ùå Ollama kh√¥ng kh·∫£ d·ª•ng: {conn_err}")
            print(f"[CHATBOT] ‚ö†Ô∏è  S·ª≠ d·ª•ng fallback answer v·ªõi h∆∞·ªõng d·∫´n chi ti·∫øt t·ª´ system prompt")
            fallback_answer = _get_fallback_answer(user_message)
            return fallback_answer
        
        # X√¢y d·ª±ng danh s√°ch messages v·ªõi l·ªãch s·ª≠ h·ªôi tho·∫°i
        messages = [{"role": "system", "content": system_prompt}]
        
        # Th√™m l·ªãch s·ª≠ h·ªôi tho·∫°i n·∫øu c√≥
        if conversation_history:
            for msg in conversation_history:
                # Chuy·ªÉn ƒë·ªïi role t·ª´ frontend format sang API format
                role = msg.get('role', 'user')
                if role == 'assistant':
                    messages.append({"role": "assistant", "content": msg.get('content', '')})
                elif role == 'user':
                    messages.append({"role": "user", "content": msg.get('content', '')})
        
        # Th√™m tin nh·∫Øn hi·ªán t·∫°i
        messages.append({"role": "user", "content": user_message})
        
        payload = {
            "model": OLLAMA_MODEL,
            "messages": messages,
            "stream": False,
            "options": {
                "temperature": 0.15,
                "num_predict": 2000,  # TƒÉng l√™n ƒë·ªÉ tr·∫£ l·ªùi chi ti·∫øt h∆°n (t·ª´ 300 l√™n 2000)
                "num_ctx": 4096,  # TƒÉng context window ƒë·ªÉ c√≥ th·ªÉ x·ª≠ l√Ω system prompt d√†i (t·ª´ 2048 l√™n 4096)
            }
        }
        
        try:
            print(f"[CHATBOT] ƒêang g·ªçi Ollama API v·ªõi model: {OLLAMA_MODEL}")
            # Timeout: 5s cho k·∫øt n·ªëi, 120s cho ƒë·ªçc response (model c√≥ th·ªÉ c·∫ßn th·ªùi gian ƒë·ªÉ t·∫£i/generate)
            resp = requests.post(OLLAMA_API_URL, json=payload, timeout=(5, 120))
            resp.raise_for_status()
            data = resp.json()
            # Schema chu·∫©n c·ªßa Ollama /api/chat: { message: { role, content }, ... }
            message = data.get("message") or {}
            content = (message.get("content") or "").strip()
            if content:
                try:
                    print(f"[CHATBOT] ‚úÖ Ollama tr·∫£ l·ªùi th√†nh c√¥ng, ƒë·ªô d√†i: {len(content)} k√Ω t·ª±")
                except Exception:
                    pass
                content = _sanitize_chatbot_output(content) or _CHATBOT_CLARIFY_MESSAGE
                # L∆∞u v√†o cache
                with _chatbot_cache_lock:
                    if len(_chatbot_cache) >= CHATBOT_CACHE_SIZE:
                        oldest_key = next(iter(_chatbot_cache))
                        del _chatbot_cache[oldest_key]
                    _chatbot_cache[cache_key] = content
                return content
            else:
                print(f"[CHATBOT] ‚ö†Ô∏è Ollama tr·∫£ v·ªÅ response nh∆∞ng kh√¥ng c√≥ n·ªôi dung. Response: {data}")
                error_msg = "Xin l·ªói, m√¨nh ch∆∞a nh·∫≠n ƒë∆∞·ª£c n·ªôi dung tr·∫£ l·ªùi t·ª´ m√¥ h√¨nh AI (Ollama)."
                return error_msg
        except requests.exceptions.HTTPError as http_err:
            print(f"[CHATBOT] ‚ùå L·ªói HTTP t·ª´ Ollama: {http_err}")
            if hasattr(http_err.response, 'text'):
                print(f"[CHATBOT] Response body: {http_err.response.text[:500]}")
            # C√≥ th·ªÉ l√† model ch∆∞a ƒë∆∞·ª£c pull
            if http_err.response.status_code == 404:
                print(f"[CHATBOT] üí° Model '{OLLAMA_MODEL}' c√≥ th·ªÉ ch∆∞a ƒë∆∞·ª£c t·∫£i. Ch·∫°y: ollama pull {OLLAMA_MODEL}")
            fallback_answer = _get_fallback_answer(user_message)
            return fallback_answer
            
    except requests.exceptions.ConnectionError as conn_err:
        print(f"[CHATBOT] ‚ùå L·ªói k·∫øt n·ªëi Ollama khi g·ªçi API: {conn_err}")
        print(f"[CHATBOT] URL: {OLLAMA_API_URL}")
        fallback_answer = _get_fallback_answer(user_message)
        return fallback_answer
    except requests.exceptions.Timeout as timeout_err:
        print(f"[CHATBOT] ‚ùå Ollama timeout sau 120 gi√¢y: {timeout_err}")
        print(f"[CHATBOT] üí° Model c√≥ th·ªÉ ƒëang ƒë∆∞·ª£c t·∫£i l·∫ßn ƒë·∫ßu ho·∫∑c c·∫ßn th·ªùi gian x·ª≠ l√Ω d√†i, vui l√≤ng th·ª≠ l·∫°i sau")
        fallback_answer = _get_fallback_answer(user_message)
        return fallback_answer
    except Exception as e:
        print(f"[CHATBOT] ‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ªçi Ollama: {type(e).__name__}: {e}")
        import traceback
        print(f"[CHATBOT] Traceback: {traceback.format_exc()}")
        fallback_answer = _get_fallback_answer(user_message)
        return fallback_answer

# ====== TOKEN KEEP-ALIVE SCHEDULER ======
_token_keepalive_lock = threading.Lock()
_token_keepalive_started = False

# ====== LICENSE ONLINE CHECK SCHEDULER ======
_license_check_lock = threading.Lock()
_license_check_started = False
_license_is_valid = True  # Global flag ƒë·ªÉ track license status


def _force_shutdown_app(reason: str = ""):
    """
    D·ª´ng to√†n b·ªô ch∆∞∆°ng tr√¨nh NGAY L·∫¨P T·ª®C (d√πng cho tr∆∞·ªùng h·ª£p license kh√¥ng h·ª£p l·ªá / h·∫øt h·∫°n).
    S·ª≠ d·ª•ng os._exit ƒë·ªÉ ch·∫Øc ch·∫Øn d·ª´ng c·∫£ Flask v√† m·ªçi thread n·ªÅn.
    """
    try:
        print(f"[LICENSE] ·ª®ng d·ª•ng s·∫Ω d·ª´ng ngay l·∫≠p t·ª©c. L√Ω do: {reason}", flush=True)
    except Exception:
        pass
    # Tho√°t process ngay l·∫≠p t·ª©c, kh√¥ng ch·∫°y clean-up handlers
    os._exit(1)


def _license_check_worker(interval_seconds: int = 60):
    """
    Thread n·ªÅn ki·ªÉm tra license online li√™n t·ª•c qua License Manager Pro.
    N·∫øu license h·∫øt h·∫°n/kh√¥ng h·ª£p l·ªá -> ch·∫∑n truy c·∫≠p app (kh√¥ng tho√°t app).
    Interval m·∫∑c ƒë·ªãnh: 60 gi√¢y (1 ph√∫t) ƒë·ªÉ c·∫≠p nh·∫≠t nhanh h∆°n khi c√≥ thay ƒë·ªïi t·ª´ ƒëi·ªán tho·∫°i.
    Khi license s·∫Øp h·∫øt h·∫°n (days_remaining <= 7), s·∫Ω t·ª± ƒë·ªông gi·∫£m xu·ªëng 30 gi√¢y.
    """
    global _license_is_valid, _license_warning_state
    from datetime import datetime

    # ƒê·ª£i v√†i gi√¢y cho app & database kh·ªüi ƒë·ªông xong
    print(f"[LICENSE] License checker worker ƒëang kh·ªüi ƒë·ªông, s·∫Ω b·∫Øt ƒë·∫ßu ki·ªÉm tra sau 5 gi√¢y...", flush=True)
    time.sleep(5)
    print(f"[LICENSE] B·∫Øt ƒë·∫ßu ki·ªÉm tra license ƒë·ªãnh k·ª≥ (m·ªói {interval_seconds} gi√¢y)...", flush=True)
    
    # Interval ƒë·ªông: b·∫Øt ƒë·∫ßu v·ªõi interval_seconds, s·∫Ω t·ª± ƒëi·ªÅu ch·ªânh d·ª±a tr√™n days_remaining
    current_interval = interval_seconds

    while True:
        try:
            with app.app_context():
                # S·ª≠ d·ª•ng h√†m helper ƒë·ªÉ l·∫•y license key nh·∫•t qu√°n
                license_key = get_license_key()

                if not license_key:
                    print("[LICENSE] Kh√¥ng t√¨m th·∫•y license key ƒë·ªÉ verify. ƒê√£ ch·∫∑n truy c·∫≠p app.")
                    global _license_is_valid
                    _license_is_valid = False
                    time.sleep(current_interval)
                    continue

                # ∆Øu ti√™n d√πng API endpoint, fallback v·ªÅ ?verify= n·∫øu API kh√¥ng c√≥
                verify_url = f"{LICENSE_VERIFY_ENDPOINT.rstrip('/')}/api/verify?verify={license_key}"
                try:
                    resp = requests.get(verify_url, timeout=10)
                except Exception as e:
                    # L·ªói m·∫°ng t·∫°m th·ªùi: log l·∫°i nh∆∞ng KH√îNG d·ª´ng app ngay
                    try:
                        from datetime import datetime, timedelta
                        next_check_time = datetime.now() + timedelta(seconds=current_interval)
                        next_check_str = next_check_time.strftime("%H:%M:%S")
                        print(f"[LICENSE] L·ªói k·∫øt n·ªëi server license: {e}. S·∫Ω th·ª≠ l·∫°i sau {current_interval} gi√¢y (l·∫ßn ti·∫øp theo: {next_check_str})", flush=True)
                    except Exception:
                        print(f"[LICENSE] L·ªói k·∫øt n·ªëi server license: {e}. S·∫Ω th·ª≠ l·∫°i sau {current_interval} gi√¢y.", flush=True)
                    time.sleep(current_interval)
                    continue

                if resp.status_code != 200:
                    try:
                        from datetime import datetime, timedelta
                        next_check_time = datetime.now() + timedelta(seconds=current_interval)
                        next_check_str = next_check_time.strftime("%H:%M:%S")
                        print(f"[LICENSE] Server license tr·∫£ v·ªÅ status {resp.status_code}. S·∫Ω th·ª≠ l·∫°i sau {current_interval} gi√¢y (l·∫ßn ti·∫øp theo: {next_check_str})", flush=True)
                    except Exception:
                        print(f"[LICENSE] Server license tr·∫£ v·ªÅ status {resp.status_code}. S·∫Ω th·ª≠ l·∫°i sau {current_interval} gi√¢y.", flush=True)
                    time.sleep(current_interval)
                    continue

                try:
                    data = resp.json()
                except Exception as e:
                    # Server license kh√¥ng tr·∫£ v·ªÅ JSON chu·∫©n (th∆∞·ªùng l√† HTML hi·ªÉn th·ªã th√¥ng tin license).
                    # Thay v√¨ d·ª´ng app ngay, ta c·ªë g·∫Øng ph√¢n t√≠ch n·ªôi dung text ƒë·ªÉ suy ra tr·∫°ng th√°i license.
                    print(f"[LICENSE] Kh√¥ng parse ƒë∆∞·ª£c JSON t·ª´ server license: {e}. Th·ª≠ ph√¢n t√≠ch n·ªôi dung text...")
                    data = _infer_license_data_from_text(resp.text or "", license_key=license_key)
                    if not data:
                        # Kh√¥ng ƒëo√°n ƒë∆∞·ª£c tr·∫°ng th√°i t·ª´ n·ªôi dung -> log l·∫°i v√† t·∫°m cho qua ƒë·ªÉ kh√¥ng kh√≥a app nh·∫ßm.
                        try:
                            from datetime import datetime, timedelta
                            next_check_time = datetime.now() + timedelta(seconds=current_interval)
                            next_check_str = next_check_time.strftime("%H:%M:%S")
                            print(f"[LICENSE] Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c tr·∫°ng th√°i license t·ª´ n·ªôi dung server. S·∫Ω th·ª≠ l·∫°i sau {current_interval} gi√¢y (l·∫ßn ti·∫øp theo: {next_check_str})", flush=True)
                        except Exception:
                            print(f"[LICENSE] Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c tr·∫°ng th√°i license t·ª´ n·ªôi dung server. S·∫Ω th·ª≠ l·∫°i sau {current_interval} gi√¢y.", flush=True)
                        time.sleep(current_interval)
                        continue

                is_valid = bool(data.get("valid", False))
                status = str(data.get("status", "")).lower()
                days_remaining = data.get("days_remaining", None)
                expiry_str = data.get("expiry", "")

                # Ki·ªÉm tra h·∫øt h·∫°n d·ª±a tr√™n c√°c field tr·∫£ v·ªÅ
                expired = False

                # T√≠nh to√°n days_remaining t·ª´ expiry ƒë·ªÉ ƒë·∫£m b·∫£o ch√≠nh x√°c (override gi√° tr·ªã t·ª´ API n·∫øu c√≥)
                if expiry_str:
                    try:
                        # Parse expiry date (c√≥ th·ªÉ l√† UTC v·ªõi 'Z')
                        if 'Z' in expiry_str:
                            # Chuy·ªÉn UTC v·ªÅ local time ƒë·ªÉ kh·ªõp v·ªõi UI (UI d√πng new Date() = local time)
                            from datetime import timezone
                            expiry_dt_utc = datetime.fromisoformat(expiry_str.replace('Z', '+00:00'))
                            # Chuy·ªÉn UTC sang local time
                            expiry_dt = expiry_dt_utc.astimezone().replace(tzinfo=None)
                        else:
                            expiry_dt = datetime.fromisoformat(expiry_str)
                            if expiry_dt.tzinfo:
                                expiry_dt = expiry_dt.astimezone().replace(tzinfo=None)
                        
                        # D√πng local time nh∆∞ UI (new Date() trong JavaScript)
                        now_dt = datetime.now()
                        
                        # T√≠nh days_remaining ch√≠nh x√°c (d√πng floor nh∆∞ UI: Math.floor(diffMs / (1000 * 60 * 60 * 24)))
                        diff_time = expiry_dt - now_dt
                        # T√≠nh s·ªë milliseconds (gi·ªëng JavaScript) - c√≥ th·ªÉ √¢m n·∫øu ƒë√£ h·∫øt h·∫°n
                        diff_ms = diff_time.total_seconds() * 1000
                        # Math.floor(diffMs / (1000 * 60 * 60 * 24))
                        calculated_days_remaining = int(diff_ms / (1000 * 60 * 60 * 24))
                        # Override days_remaining t·ª´ API b·∫±ng gi√° tr·ªã t√≠nh to√°n ch√≠nh x√°c
                        # N·∫øu √¢m nghƒ©a l√† ƒë√£ h·∫øt h·∫°n, n·∫øu d∆∞∆°ng nghƒ©a l√† c√≤n h·∫°n
                        days_remaining = calculated_days_remaining
                        if calculated_days_remaining < 0:
                            expired = True
                            print(f"[LICENSE] ƒê√£ t√≠nh l·∫°i days_remaining t·ª´ expiry: {calculated_days_remaining} ng√†y (ƒê√É H·∫æT H·∫†N) (t·ª´ API: {data.get('days_remaining', 'N/A')})")
                        else:
                            print(f"[LICENSE] ƒê√£ t√≠nh l·∫°i days_remaining t·ª´ expiry: {calculated_days_remaining} ng√†y (t·ª´ API: {data.get('days_remaining', 'N/A')})")
                    except Exception as e:
                        print(f"[LICENSE] L·ªói parse expiry '{expiry_str}': {e}")

                # 1) N·∫øu c√≥ days_remaining - ƒëi·ªÅu ch·ªânh interval ƒë·ªông d·ª±a tr√™n tr·∫°ng th√°i license
                if isinstance(days_remaining, (int, float)):
                    # Khi license s·∫Øp h·∫øt h·∫°n (‚â§ 7 ng√†y), gi·∫£m interval xu·ªëng 30s ƒë·ªÉ check th∆∞·ªùng xuy√™n h∆°n
                    if 0 <= days_remaining <= 7:
                        if current_interval > 30:
                            current_interval = 30
                            print(f"[LICENSE] License s·∫Øp h·∫øt h·∫°n ({days_remaining} ng√†y), gi·∫£m interval xu·ªëng 30 gi√¢y ƒë·ªÉ check th∆∞·ªùng xuy√™n h∆°n", flush=True)
                    else:
                        # License c√≤n nhi·ªÅu th·ªùi gian, d√πng interval m·∫∑c ƒë·ªãnh
                        if current_interval != interval_seconds:
                            current_interval = interval_seconds
                            print(f"[LICENSE] License c√≤n nhi·ªÅu th·ªùi gian, tƒÉng interval v·ªÅ {interval_seconds} gi√¢y", flush=True)
                    
                    # N·∫øu c√≤n ‚â§ 1 ng√†y nh∆∞ng CH∆ØA h·∫øt h·∫°n -> g·ª≠i c·∫£nh b√°o cho to√†n h·ªá th·ªëng (gi·ªëng c∆° ch·∫ø refresh token)
                    # √Åp d·ª•ng cho c·∫£ tr∆∞·ªùng h·ª£p days_remaining == 1 v√† days_remaining == 0 nh∆∞ng v·∫´n c√≤n gi·ªù/ph√∫t/gi√¢y.
                    if 0 <= days_remaining <= 1 and not expired:
                        try:
                            warning_message = (
                                "‚ö†Ô∏è ·ª®NG D·ª§NG CH·∫§M C√îNG & NGH·ªà PH√âP S·∫ÆP H·∫æT H·∫†N LICENSE.\n\n"
                                "- To√†n b·ªô NH√ÇN VI√äN c·∫ßn NHANH CH√ìNG ho√†n th√†nh vi·ªác nh·∫≠p ƒë·∫ßy ƒë·ªß d·ªØ li·ªáu ch·∫•m c√¥ng, ƒëƒÉng k√Ω ngh·ªâ ph√©p, tƒÉng ca... tr∆∞·ªõc khi key h·∫øt h·∫°n.\n"
                                "- C√°c TR∆Ø·ªûNG NH√ìM / QU·∫¢N L√ù / QU·∫¢N TR·ªä VI√äN c·∫ßn PH√ä DUY·ªÜT T·∫§T C·∫¢ c√°c ƒë∆°n ch·∫•m c√¥ng, ngh·ªâ ph√©p, tƒÉng ca c·ªßa c·∫•p d∆∞·ªõi trong th·ªùi gian s·ªõm nh·∫•t.\n\n"
                                "L∆ØU √ù QUAN TR·ªåNG:\n"
                                "- Sau khi license h·∫øt h·∫°n, h·ªá th·ªëng ch·∫•m c√¥ng v√† ngh·ªâ ph√©p s·∫Ω T·∫†M D·ª™NG HO·∫†T ƒê·ªòNG, kh√¥ng th·ªÉ ti·∫øp t·ª•c nh·∫≠p li·ªáu hay ph√™ duy·ªát.\n\n"
                                "ƒê·ªÄ NGH·ªä ADMIN S·ªöM LI√äN H·ªÜ DEVELOPER ƒê·ªÇ GIA H·∫†N LICENSE:\n"
                                "Nguy·ªÖn C√¥ng ƒê·∫°t - 0375097105."
                            )
                            # D√πng c∆° ch·∫ø publish_token_status ƒë·ªÉ hi·ªán banner c·∫£nh b√°o (gi·ªëng refresh token)
                            try:
                                publish_token_status(
                                    'expired',
                                    warning_message,
                                    needs_reauth=False
                                )
                            except Exception:
                                pass
                            # G·ª≠i th√™m qua Telegram n·∫øu c√≥ c·∫•u h√¨nh
                            try:
                                send_telegram_message(warning_message)
                            except Exception:
                                pass
                        except Exception:
                            # Kh√¥ng ƒë·ªÉ l·ªói c·∫£nh b√°o l√†m h·ªèng lu·ªìng ch√≠nh
                            pass
                    else:
                        # N·∫øu days_remaining > 1 (ho·∫∑c √¢m nh∆∞ng ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω expired ·ªü d∆∞·ªõi) -> clear c·∫£nh b√°o LICENSE n·∫øu ƒëang b·∫≠t
                        try:
                            from datetime import datetime
                            with _license_warning_lock:
                                _license_warning_state = {
                                    'active': False,
                                    'payload': None,
                                    'updated_at': datetime.now().isoformat(),
                                }
                        except Exception:
                            pass

                    if days_remaining < 0:
                        expired = True

                if (not is_valid) or expired or (status not in ("active", "ƒëang ho·∫°t ƒë·ªông", "")):
                    # Khi license h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá -> ch·∫∑n truy c·∫≠p app nh∆∞ng kh√¥ng tho√°t
                    _license_is_valid = False
                    base_msg = data.get("message", "License kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n")
                    contact_msg = (
                        f"{base_msg}\n\n"
                        "Vui l√≤ng li√™n h·ªá ADMIN ƒë·ªÉ gia h·∫°n:\n"
                        "Nguy·ªÖn C√¥ng ƒê·∫°t - 0375097105."
                    )
                    # In r√µ license key ƒëang s·ª≠ d·ª•ng ƒë·ªÉ d·ªÖ debug khi h·∫øt h·∫°n/kh√¥ng h·ª£p l·ªá
                    try:
                        print(f"[LICENSE] License key ƒëang d√πng: {license_key}")
                    except Exception:
                        pass
                    print(f"[LICENSE] License KH√îNG H·ª¢P L·ªÜ / H·∫æT H·∫†N - ƒê√£ ch·∫∑n truy c·∫≠p app: {contact_msg}")
                    try:
                        # Th·ª≠ g·ª≠i th√¥ng b√°o qua Telegram n·∫øu ƒë√£ c·∫•u h√¨nh
                        send_telegram_message(f"[LICENSE EXPIRED]\n{contact_msg}")
                    except Exception:
                        pass
                    # KH√îNG g·ªçi _force_shutdown_app n·ªØa, ch·ªâ set flag ƒë·ªÉ ch·∫∑n truy c·∫≠p
                else:
                    # License h·ª£p l·ªá -> cho ph√©p truy c·∫≠p
                    if not _license_is_valid:
                        print(f"[LICENSE] License ƒë√£ ƒë∆∞·ª£c gia h·∫°n - Cho ph√©p truy c·∫≠p l·∫°i app")
                    _license_is_valid = True

                    # N·∫øu tr∆∞·ªõc ƒë√≥ c√≥ c·∫£nh b√°o LICENSE, clear cache ƒë·ªÉ UI ·∫©n banner ·ªü l·∫ßn load sau
                    try:
                        with _license_warning_lock:
                            _license_warning_state = {
                                'active': False,
                                'payload': None,
                                'updated_at': datetime.now().isoformat(),
                            }
                    except Exception:
                        pass

                # N·∫øu t·ªõi ƒë√¢y l√† license v·∫´n h·ª£p l·ªá
                try:
                    exp_info = expiry_str or "N/A"
                    print(f"[LICENSE] License h·ª£p l·ªá. H·∫øt h·∫°n: {exp_info}, days_remaining={days_remaining}")
                except Exception:
                    pass

        except Exception as e:
            print(f"[LICENSE] L·ªói kh√¥ng mong ƒë·ª£i trong license_check_worker: {e}")

        # Log th√¥ng tin v·ªÅ l·∫ßn check ti·∫øp theo
        try:
            from datetime import datetime, timedelta
            next_check_time = datetime.now() + timedelta(seconds=current_interval)
            next_check_str = next_check_time.strftime("%H:%M:%S")
            print(f"[LICENSE] S·∫Ω ki·ªÉm tra l·∫°i sau {current_interval} gi√¢y (l·∫ßn ti·∫øp theo: {next_check_str})", flush=True)
        except Exception:
            print(f"[LICENSE] S·∫Ω ki·ªÉm tra l·∫°i sau {current_interval} gi√¢y", flush=True)

        # Ng·ªß tr∆∞·ªõc khi ki·ªÉm tra l·∫°i (d√πng current_interval ƒë·ªông)
        time.sleep(current_interval)


def _check_license_once() -> tuple[bool, bool, str, str]:
    """
    Ch·∫°y 1 l·∫ßn logic ki·ªÉm tra license.
    Tr·∫£ v·ªÅ: (is_valid, expired, status, message)
    KH√îNG t·ª± t·∫Øt app trong h√†m n√†y, ƒë·ªÉ caller quy·∫øt ƒë·ªãnh.
    """
    from datetime import datetime as _dt_mod

    with app.app_context():
        # S·ª≠ d·ª•ng h√†m helper ƒë·ªÉ l·∫•y license key nh·∫•t qu√°n
        license_key = get_license_key()
        print(f"[LICENSE] License key ƒëang d√πng: {license_key}", flush=True)

        if not license_key:
            msg = "Kh√¥ng c√≥ license key"
            print(f"[LICENSE] {msg}")
            return False, True, "missing", msg

        # ∆Øu ti√™n d√πng API endpoint, fallback v·ªÅ ?verify= n·∫øu API kh√¥ng c√≥
        verify_url = f"{LICENSE_VERIFY_ENDPOINT.rstrip('/')}/api/verify?verify={license_key}"
        print(f"[LICENSE] Calling API: {verify_url}", flush=True)
        try:
            resp = requests.get(verify_url, timeout=10)
            print(f"[LICENSE] API Status Code: {resp.status_code}", flush=True)
        except Exception as e:
            msg = f"L·ªói k·∫øt n·ªëi server license: {e}"
            print(f"[LICENSE] {msg}")
            # L·ªói m·∫°ng: coi nh∆∞ ch∆∞a x√°c ƒë·ªãnh, nh∆∞ng kh√¥ng ƒë√°nh expired, ƒë·ªÉ caller quy·∫øt ƒë·ªãnh
            return True, False, "unknown", msg

        if resp.status_code != 200:
            msg = f"Server license tr·∫£ v·ªÅ status {resp.status_code}"
            print(f"[LICENSE] {msg}")
            return True, False, "unknown", msg

        # Parse JSON ho·∫∑c text nh∆∞ trong worker
        try:
            data = resp.json()
            # Debug: log full response ƒë·ªÉ ki·ªÉm tra
            print(f"[LICENSE] API Response Full: {resp.text[:500]}", flush=True)
            print(f"[LICENSE] API Response Parsed: valid={data.get('valid')}, status={data.get('status')}, message={data.get('message')}, key={data.get('key')}", flush=True)
        except Exception as e:
            print(f"[LICENSE] Kh√¥ng parse ƒë∆∞·ª£c JSON t·ª´ server license: {e}. Th·ª≠ ph√¢n t√≠ch n·ªôi dung text...")
            print(f"[LICENSE] Response text: {resp.text[:200]}", flush=True)
            data = _infer_license_data_from_text(resp.text or "", license_key=license_key)
            if not data:
                msg = "Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c tr·∫°ng th√°i license t·ª´ n·ªôi dung server."
                print(f"[LICENSE] {msg}")
                return True, False, "unknown", msg

        is_valid = bool(data.get("valid", False))
        status = str(data.get("status", "")).lower()
        days_remaining = data.get("days_remaining", None)
        expiry_str = data.get("expiry", "")

        expired = False
        if isinstance(days_remaining, (int, float)) and days_remaining < 0:
            expired = True
        if expiry_str and not expired:
            try:
                normalized = expiry_str.replace('Z', '+00:00') if 'Z' in expiry_str else expiry_str
                expiry_dt = _dt_mod.fromisoformat(normalized)
                from datetime import timezone
                now_dt = _dt_mod.now() if expiry_dt.tzinfo is None else _dt_mod.now(timezone.utc)
                if expiry_dt < now_dt:
                    expired = True
            except Exception as e:
                print(f"[LICENSE] L·ªói parse expiry '{expiry_str}': {e}")

        msg = data.get("message", "")
        # Debug: log k·∫øt qu·∫£ cu·ªëi c√πng
        print(f"[LICENSE] Check result: is_valid={is_valid}, expired={expired}, status={status}, msg={msg}", flush=True)
        return is_valid, expired, status, msg

def ensure_license_check_started(interval_seconds: int = 60):
    """
    ƒê·∫£m b·∫£o thread ki·ªÉm tra license online ch·ªâ kh·ªüi ƒë·ªông m·ªôt l·∫ßn.
    """
    global _license_check_started
    if _license_check_started:
        return
    with _license_check_lock:
        if _license_check_started:
            return
        try:
            t = threading.Thread(
                target=_license_check_worker,
                args=(interval_seconds,),
                daemon=True
            )
            t.start()
            _license_check_started = True
            print(f"[LICENSE] License online checker started (m·ªói {interval_seconds} gi√¢y).")
        except Exception as e:
            print(f"[LICENSE] Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông license online checker: {e}")

# Telegram Bot Configuration (load from environment variables)
BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN', '')
CHAT_ID = os.environ.get('TELEGRAM_CHAT_ID', '')

def _ensure_dir(path):
    try:
        os.makedirs(path, exist_ok=True)
    except Exception as e:
        print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c {path}: {e}")

def _list_backups(backup_dir, prefix="attendance", suffix=".db"):
    try:
        files = [
            os.path.join(backup_dir, f) for f in os.listdir(backup_dir)
            if f.startswith(prefix) and f.endswith(suffix)
        ]
        files.sort(key=lambda p: os.path.getmtime(p))
        return files
    except Exception:
        return []

def send_telegram_file(file_path, caption=None):
    """G·ª≠i file l√™n Telegram"""
    try:
        if not BOT_TOKEN or not CHAT_ID:
            print("‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh BOT_TOKEN ho·∫∑c CHAT_ID")
            return False
        
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendDocument"
        
        with open(file_path, 'rb') as file:
            files = {'document': file}
            data = {
                'chat_id': CHAT_ID,
                'caption': caption or f"üõ°Ô∏è Backup database - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            }
            
            response = requests.post(url, files=files, data=data, timeout=30)
            
            if response.status_code == 200:
                print(f"üì§ ƒê√£ g·ª≠i backup l√™n Telegram: {os.path.basename(file_path)}")
                return True
            else:
                print(f"‚ùå L·ªói g·ª≠i Telegram: {response.status_code} - {response.text}")
                return False
                
    except Exception as e:
        print(f"‚ùå L·ªói khi g·ª≠i file l√™n Telegram: {e}")
        return False

def create_backup(backup_dir="backups", retention=3, send_to_telegram=True):
    """
    Sao l∆∞u database: ∆∞u ti√™n instance/attendance.db; fallback attendance.db t·∫°i root.
    Gi·ªØ t·ªëi ƒëa 'retention' b·∫£n backup g·∫ßn nh·∫•t.
    G·ª≠i file backup l√™n Telegram n·∫øu send_to_telegram=True.
    """
    try:
        _ensure_dir(backup_dir)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        src_candidates = [
            os.path.join("instance", "attendance.db"),
            os.path.join(os.getcwd(), "attendance.db"),
        ]
        src = None
        for c in src_candidates:
            if os.path.exists(c):
                src = c
                break
        if not src:
            print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y file database ƒë·ªÉ backup")
            return False
        base_name = f"attendance_{timestamp}.db"
        dst = os.path.join(backup_dir, base_name)
        shutil.copy2(src, dst)
        print(f"‚úÖ ƒê√£ backup database: {dst}")
        
        # G·ª≠i l√™n Telegram n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
        if send_to_telegram:
            try:
                send_telegram_file(dst, f"üõ°Ô∏è Backup database - {timestamp}")
            except Exception as e:
                print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ g·ª≠i backup l√™n Telegram: {e}")
        
        # Retention
        backups = _list_backups(backup_dir, prefix="attendance_", suffix=".db")
        if len(backups) > retention:
            to_delete = backups[:len(backups)-retention]
            for f in to_delete:
                try:
                    os.remove(f)
                    print(f"üßπ X√≥a b·∫£n backup c≈©: {f}")
                except Exception as e:
                    print(f"‚ö†Ô∏è Kh√¥ng x√≥a ƒë∆∞·ª£c backup c≈© {f}: {e}")
        return True
    except Exception as e:
        print(f"‚ùå L·ªói khi backup database: {e}")
        return False

def _backup_worker(interval_minutes=180, backup_dir="backups", retention=3, send_to_telegram=True):
    """Worker ch·∫°y n·ªÅn ƒë·ªÉ backup ƒë·ªãnh k·ª≥."""
    # ƒê·ª£i interval ƒë·∫ßu ti√™n tr∆∞·ªõc khi ch·∫°y backup l·∫ßn ƒë·∫ßu (tr√°nh t·∫°o backup ngay khi kh·ªüi ƒë·ªông)
    try:
        interval_seconds = max(60, int(interval_minutes) * 60)
    except Exception:
        interval_seconds = 3 * 60 * 60  # Fallback 3 gi·ªù
    
    while True:
        # Ng·ªß tr∆∞·ªõc, sau ƒë√≥ m·ªõi ch·∫°y backup (tr√°nh t·∫°o backup ngay khi kh·ªüi ƒë·ªông)
        try:
            time_module.sleep(interval_seconds)
        except Exception:
            # Fallback ng·ªß 3 gi·ªù n·∫øu c·∫•u h√¨nh l·ªói
            time_module.sleep(3 * 60 * 60)
        
        # Sau khi ng·ªß xong, m·ªõi ch·∫°y backup
        try:
            create_backup(backup_dir=backup_dir, retention=retention, send_to_telegram=send_to_telegram)
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói trong backup worker: {e}")

def ensure_backup_scheduler_started(interval_minutes=180, backup_dir="backups", retention=3, send_to_telegram=True):
    """
    Kh·ªüi ch·∫°y thread backup ƒë·ªãnh k·ª≥ m·ªôt l·∫ßn duy nh·∫•t.
    """
    global _backup_scheduler_started
    if _backup_scheduler_started:
        return
    with _backup_scheduler_lock:
        if _backup_scheduler_started:
            return
        try:
            t = threading.Thread(
                target=_backup_worker,
                kwargs={
                    'interval_minutes': interval_minutes,
                    'backup_dir': backup_dir,
                    'retention': retention,
                    'send_to_telegram': send_to_telegram,
                },
                daemon=True
            )
            t.start()
            _backup_scheduler_started = True
            telegram_status = " + Telegram" if send_to_telegram else ""
            print(f"üõ°Ô∏è Backup scheduler started: every {interval_minutes} minutes, dir='{backup_dir}', retention={retention}{telegram_status}")
        except Exception as e:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi ch·∫°y backup scheduler: {e}")

# ====== TOKEN KEEP-ALIVE FUNCTIONS ======

def _token_keepalive_worker(interval_minutes=30):
    """Worker ch·∫°y n·ªÅn ƒë·ªÉ gi·ªØ token s·ªëng - KH√îNG t·ª± ƒë·ªông authenticate"""
    while True:
        try:
            # Ch·ªâ load token t·ª´ file, kh√¥ng t·ª± ƒë·ªông authenticate
            google_api = GoogleDriveAPI(auto_authenticate=False)
            
            # N·∫øu kh√¥ng c√≥ token ho·∫∑c token kh√¥ng h·ª£p l·ªá, ch·ªâ th√¥ng b√°o, kh√¥ng authenticate
            if not google_api.creds:
                print(f"‚ö†Ô∏è [Token Keep-Alive] Kh√¥ng c√≥ token. C·∫ßn admin b·∫•m n√∫t Refresh Token ƒë·ªÉ ·ªßy quy·ªÅn.")
                try:
                    publish_token_status('expired', 'Kh√¥ng c√≥ token. Vui l√≤ng b·∫•m n√∫t Refresh Token ƒë·ªÉ ·ªßy quy·ªÅn.', needs_reauth=True)
                except Exception:
                    pass
                time_module.sleep(interval_minutes * 60)
                continue
            
            # Ki·ªÉm tra v√† refresh token n·∫øu c·∫ßn (ch·ªâ refresh t·ª± ƒë·ªông, kh√¥ng authenticate)
            if google_api.creds.expired:
                if google_api.creds.refresh_token:
                    try:
                        print(f"üîÑ [Token Keep-Alive] ƒêang refresh token t·ª± ƒë·ªông...")
                        google_api.creds.refresh(GoogleRequest())
                        # L∆∞u token m·ªõi
                        with open(google_api.token_file, 'w') as token:
                            token.write(google_api.creds.to_json())
                        google_api.save_last_refresh_time()
                        print(f"‚úÖ [Token Keep-Alive] Token ƒë√£ ƒë∆∞·ª£c refresh th√†nh c√¥ng!")
                        # Notify admins that token is valid
                        try:
                            publish_token_status('valid', 'Token ƒë√£ ƒë∆∞·ª£c refresh t·ª± ƒë·ªông th√†nh c√¥ng!')
                        except Exception:
                            pass
                    except Exception as refresh_err:
                        error_str = str(refresh_err).lower()
                        print(f"‚ö†Ô∏è [Token Keep-Alive] Kh√¥ng th·ªÉ refresh token t·ª± ƒë·ªông: {refresh_err}")
                        # Notify admins that token needs reauth
                        try:
                            if 'invalid_grant' in error_str:
                                publish_token_status('expired', 'Token kh√¥ng h·ª£p l·ªá. Vui l√≤ng b·∫•m n√∫t Refresh Token ƒë·ªÉ ·ªßy quy·ªÅn l·∫°i.', needs_reauth=True)
                            else:
                                publish_token_status('expired', 'Token h·∫øt h·∫°n. Vui l√≤ng b·∫•m n√∫t Refresh Token ƒë·ªÉ ·ªßy quy·ªÅn l·∫°i.', needs_reauth=True)
                        except Exception:
                            pass
                else:
                    print(f"‚ö†Ô∏è [Token Keep-Alive] Token h·∫øt h·∫°n v√† kh√¥ng c√≥ refresh_token. C·∫ßn admin b·∫•m n√∫t Refresh Token.")
                    try:
                        publish_token_status('expired', 'Token h·∫øt h·∫°n. Vui l√≤ng b·∫•m n√∫t Refresh Token ƒë·ªÉ ·ªßy quy·ªÅn l·∫°i.', needs_reauth=True)
                    except Exception:
                        pass
            else:
                print(f"‚ÑπÔ∏è [Token Keep-Alive] Token v·∫´n c√≤n hi·ªáu l·ª±c")
            
        except Exception as e:
            print(f"‚ùå [Token Keep-Alive] L·ªói: {e}")
        
        # Ng·ªß theo kho·∫£ng th·ªùi gian
        try:
            time_module.sleep(max(60, int(interval_minutes) * 60))
        except Exception:
            # Fallback ng·ªß 30 ph√∫t n·∫øu c·∫•u h√¨nh l·ªói
            time_module.sleep(30 * 60)

def ensure_token_keepalive_started(interval_minutes=30):
    """
    Kh·ªüi ch·∫°y thread gi·ªØ token s·ªëng m·ªôt l·∫ßn duy nh·∫•t.
    """
    global _token_keepalive_started
    if _token_keepalive_started:
        return
    with _token_keepalive_lock:
        if _token_keepalive_started:
            return
        try:
            t = threading.Thread(
                target=_token_keepalive_worker,
                kwargs={
                    'interval_minutes': interval_minutes,
                },
                daemon=True
            )
            t.start()
            _token_keepalive_started = True
            print(f"üîë Token Keep-Alive started: every {interval_minutes} minutes")
        except Exception as e:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi ch·∫°y Token Keep-Alive: {e}")

# ====== YEARLY SCHEDULE RESET SCHEDULER ======
_yearly_reset_scheduler_lock = threading.Lock()
_yearly_reset_scheduler_started = False
_last_reset_year = None
_last_notification_days = set()  # L∆∞u c√°c ng√†y ƒë√£ g·ª≠i th√¥ng b√°o ƒë·ªÉ tr√°nh g·ª≠i tr√πng

def send_telegram_message(message):
    """G·ª≠i tin nh·∫Øn vƒÉn b·∫£n l√™n Telegram"""
    try:
        if not BOT_TOKEN or not CHAT_ID:
            print("‚ö†Ô∏è Ch∆∞a c·∫•u h√¨nh BOT_TOKEN ho·∫∑c CHAT_ID")
            return False
        
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        data = {
            'chat_id': CHAT_ID,
            'text': message,
            'parse_mode': 'HTML'
        }
        
        response = requests.post(url, json=data, timeout=30)
        
        if response.status_code == 200:
            print(f"üì§ ƒê√£ g·ª≠i th√¥ng b√°o l√™n Telegram")
            return True
        else:
            print(f"‚ùå L·ªói g·ª≠i Telegram: {response.status_code} - {response.text}")
            return False
    except Exception as e:
        print(f"‚ùå L·ªói khi g·ª≠i tin nh·∫Øn l√™n Telegram: {e}")
        return False

def get_admin_users():
    """L·∫•y danh s√°ch t·∫•t c·∫£ admin users"""
    try:
        with app.app_context():
            from database.models import User
            admins = User.query.filter(
                User.roles.like('%ADMIN%'),
                User.is_deleted == False,
                User.is_active == True
            ).all()
            return admins
    except Exception as e:
        print(f"‚ùå L·ªói khi l·∫•y danh s√°ch admin: {e}")
        return []

def check_december_data_complete(year):
    """Ki·ªÉm tra d·ªØ li·ªáu th√°ng 12 ƒë√£ ƒë·∫ßy ƒë·ªß ch∆∞a"""
    try:
        with app.app_context():
            from database.models import Attendance, User
            from datetime import date
            
            # L·∫•y t·∫•t c·∫£ users ƒëang ho·∫°t ƒë·ªông
            active_users = User.query.filter_by(is_deleted=False, is_active=True).all()
            
            # Ki·ªÉm tra t·ª´ng user c√≥ d·ªØ li·ªáu ƒë·∫ßy ƒë·ªß trong th√°ng 12 kh√¥ng
            incomplete_users = []
            december_start = date(year, 12, 1)
            december_end = date(year, 12, 31)
            
            for user in active_users:
                # ƒê·∫øm s·ªë ng√†y c√≥ d·ªØ li·ªáu ch·∫•m c√¥ng trong th√°ng 12
                attendance_count = Attendance.query.filter(
                    Attendance.user_id == user.id,
                    Attendance.date >= december_start,
                    Attendance.date <= december_end
                ).count()
                
                # Ki·ªÉm tra n·∫øu thi·∫øu d·ªØ li·ªáu (√≠t h∆°n 20 ng√†y l√†m vi·ªác - c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh)
                # Th√°ng 12 th∆∞·ªùng c√≥ kho·∫£ng 22-23 ng√†y l√†m vi·ªác (tr·ª´ cu·ªëi tu·∫ßn v√† l·ªÖ)
                if attendance_count < 15:  # Ng∆∞·ª°ng t·ªëi thi·ªÉu 15 ng√†y
                    incomplete_users.append({
                        'name': user.name,
                        'employee_id': user.employee_id,
                        'attendance_count': attendance_count
                    })
            
            return {
                'complete': len(incomplete_users) == 0,
                'incomplete_users': incomplete_users,
                'total_users': len(active_users),
                'checked_users': len(active_users) - len(incomplete_users)
            }
    except Exception as e:
        print(f"‚ùå L·ªói khi ki·ªÉm tra d·ªØ li·ªáu th√°ng 12: {e}")
        return {
            'complete': False,
            'incomplete_users': [],
            'error': str(e)
        }

def reset_yearly_schedule():
    """Reset/x√≥a d·ªØ li·ªáu l·ªãch c≈© khi b·∫Øt ƒë·∫ßu nƒÉm m·ªõi"""
    try:
        with app.app_context():
            from database.models import Attendance
            from datetime import date
            
            current_year = datetime.now().year
            previous_year = current_year - 1
            
            # X√≥a t·∫•t c·∫£ d·ªØ li·ªáu ch·∫•m c√¥ng c·ªßa nƒÉm tr∆∞·ªõc
            # S·ª≠ d·ª•ng strftime cho SQLite ho·∫∑c extract cho PostgreSQL/MySQL
            try:
                # Th·ª≠ d√πng extract tr∆∞·ªõc (PostgreSQL/MySQL)
                deleted_count = Attendance.query.filter(
                    db.extract('year', Attendance.date) == previous_year
                ).delete()
            except Exception:
                # Fallback cho SQLite: d√πng strftime
                from sqlalchemy import func
                deleted_count = Attendance.query.filter(
                    func.strftime('%Y', Attendance.date) == str(previous_year)
                ).delete()
            
            db.session.commit()
            
            print(f"‚úÖ ƒê√£ x√≥a {deleted_count} b·∫£n ghi ch·∫•m c√¥ng c·ªßa nƒÉm {previous_year}")
            
            # G·ª≠i th√¥ng b√°o cho admin
            message = f"üîÑ <b>RESET L·ªäCH H√ÄNG NƒÇM</b>\n\n"
            message += f"‚úÖ ƒê√£ ho√†n t·∫•t reset l·ªãch v√†o ng√†y 1/1/{current_year}\n"
            message += f"üìä ƒê√£ x√≥a {deleted_count} b·∫£n ghi ch·∫•m c√¥ng c·ªßa nƒÉm {previous_year}\n"
            message += f"üìÖ H·ªá th·ªëng ƒë√£ s·∫µn s√†ng cho nƒÉm m·ªõi {current_year}"
            
            send_telegram_message(message)
            
            return True, deleted_count
    except Exception as e:
        db.session.rollback()  # Rollback transaction on error
        print(f"‚ùå L·ªói khi reset l·ªãch h√†ng nƒÉm: {e}")
        error_msg = f"‚ùå <b>L·ªñI RESET L·ªäCH</b>\n\nƒê√£ x·∫£y ra l·ªói khi reset l·ªãch h√†ng nƒÉm: {str(e)}"
        send_telegram_message(error_msg)
        return False, 0

def send_yearly_reset_reminder(days_until_reset):
    """G·ª≠i th√¥ng b√°o nh·∫Øc nh·ªü admin tr∆∞·ªõc ng√†y reset"""
    try:
        current_year = datetime.now().year
        next_year = current_year + 1
        
        # Ki·ªÉm tra d·ªØ li·ªáu th√°ng 12
        check_result = check_december_data_complete(current_year)
        
        message = f"‚è∞ <b>NH·∫ÆC NH·ªû RESET L·ªäCH H√ÄNG NƒÇM</b>\n\n"
        
        if days_until_reset == 7:
            message += f"üìÖ C√≤n <b>7 ng√†y</b> n·ªØa ƒë·∫øn ng√†y reset l·ªãch (1/1/{next_year})\n\n"
        elif days_until_reset == 3:
            message += f"üìÖ C√≤n <b>3 ng√†y</b> n·ªØa ƒë·∫øn ng√†y reset l·ªãch (1/1/{next_year})\n\n"
        elif days_until_reset == 1:
            message += f"üìÖ C√≤n <b>1 ng√†y</b> n·ªØa ƒë·∫øn ng√†y reset l·ªãch (1/1/{next_year})\n\n"
            message += f"‚ö†Ô∏è <b>L∆ØU √ù QUAN TR·ªåNG:</b>\n"
            message += f"‚Ä¢ H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông x√≥a t·∫•t c·∫£ d·ªØ li·ªáu ch·∫•m c√¥ng c·ªßa nƒÉm {current_year}\n"
            message += f"‚Ä¢ Vui l√≤ng ƒë·∫£m b·∫£o ƒë√£ sao l∆∞u d·ªØ li·ªáu quan tr·ªçng\n"
            message += f"‚Ä¢ Nh·∫Øc nh·ªü nh√¢n vi√™n ho√†n t·∫•t nh·∫≠p d·ªØ li·ªáu th√°ng 12\n\n"
        
        # Th√¥ng tin v·ªÅ d·ªØ li·ªáu th√°ng 12
        if check_result.get('complete', False):
            message += f"‚úÖ <b>D·ªØ li·ªáu th√°ng 12:</b> ƒê√£ ƒë·∫ßy ƒë·ªß ({check_result.get('checked_users', 0)}/{check_result.get('total_users', 0)} nh√¢n vi√™n)\n"
        else:
            incomplete = check_result.get('incomplete_users', [])
            if incomplete:
                message += f"‚ö†Ô∏è <b>D·ªØ li·ªáu th√°ng 12:</b> C√≥ {len(incomplete)} nh√¢n vi√™n ch∆∞a ƒë·∫ßy ƒë·ªß:\n"
                for user_info in incomplete[:5]:  # Ch·ªâ hi·ªÉn th·ªã 5 ng∆∞·ªùi ƒë·∫ßu
                    message += f"   ‚Ä¢ {user_info['name']} (ID: {user_info['employee_id']}) - {user_info['attendance_count']} ng√†y\n"
                if len(incomplete) > 5:
                    message += f"   ... v√† {len(incomplete) - 5} nh√¢n vi√™n kh√°c\n"
            else:
                message += f"‚ö†Ô∏è <b>D·ªØ li·ªáu th√°ng 12:</b> Kh√¥ng th·ªÉ ki·ªÉm tra (c√≥ l·ªói)\n"
        
        message += f"\nüìã <b>H√†nh ƒë·ªông c·∫ßn th·ª±c hi·ªán:</b>\n"
        message += f"‚Ä¢ Ki·ªÉm tra v√† ƒë·∫£m b·∫£o nh√¢n vi√™n ƒë√£ nh·∫≠p ƒë·∫ßy ƒë·ªß d·ªØ li·ªáu th√°ng 12\n"
        message += f"‚Ä¢ Sao l∆∞u d·ªØ li·ªáu quan tr·ªçng tr∆∞·ªõc ng√†y 1/1/{next_year}\n"
        message += f"‚Ä¢ H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông reset v√†o 00:00 ng√†y 1/1/{next_year}"
        
        send_telegram_message(message)
        print(f"üì§ ƒê√£ g·ª≠i th√¥ng b√°o nh·∫Øc nh·ªü reset l·ªãch ({days_until_reset} ng√†y tr∆∞·ªõc)")
        
    except Exception as e:
        print(f"‚ùå L·ªói khi g·ª≠i th√¥ng b√°o nh·∫Øc nh·ªü: {e}")

def _yearly_reset_worker():
    """Worker ch·∫°y n·ªÅn ƒë·ªÉ ki·ªÉm tra v√† reset l·ªãch h√†ng nƒÉm"""
    global _last_reset_year, _last_notification_days
    
    while True:
        try:
            now = datetime.now()
            current_year = now.year
            current_month = now.month
            current_day = now.day
            
            # Ki·ªÉm tra n·∫øu l√† ng√†y 1/1 v√† ch∆∞a reset nƒÉm n√†y
            if current_month == 1 and current_day == 1:
                if _last_reset_year != current_year:
                    print(f"üîÑ [YEARLY RESET] Ph√°t hi·ªán ng√†y 1/1/{current_year}, b·∫Øt ƒë·∫ßu reset l·ªãch...")
                    success, deleted_count = reset_yearly_schedule()
                    if success:
                        _last_reset_year = current_year
                        _last_notification_days.clear()  # Reset danh s√°ch th√¥ng b√°o
                        print(f"‚úÖ [YEARLY RESET] ƒê√£ ho√†n t·∫•t reset l·ªãch nƒÉm {current_year}")
                    else:
                        print(f"‚ùå [YEARLY RESET] L·ªói khi reset l·ªãch nƒÉm {current_year}")
            
            # Ki·ªÉm tra v√† g·ª≠i th√¥ng b√°o nh·∫Øc nh·ªü
            # T√≠nh s·ªë ng√†y c√≤n l·∫°i ƒë·∫øn 1/1 nƒÉm sau
            next_year = current_year + 1
            next_jan_1 = datetime(next_year, 1, 1)
            days_until_reset = (next_jan_1 - now).days
            
            # G·ª≠i th√¥ng b√°o v√†o c√°c m·ªëc: 7 ng√†y, 3 ng√†y, 1 ng√†y tr∆∞·ªõc
            if days_until_reset in [7, 3, 1]:
                if days_until_reset not in _last_notification_days:
                    send_yearly_reset_reminder(days_until_reset)
                    _last_notification_days.add(days_until_reset)
            
            # X√≥a c√°c m·ªëc ƒë√£ qua kh·ªèi danh s√°ch ƒë·ªÉ c√≥ th·ªÉ g·ª≠i l·∫°i nƒÉm sau
            if days_until_reset < 0:
                _last_notification_days.clear()
            
            # Ki·ªÉm tra m·ªói ng√†y m·ªôt l·∫ßn (v√†o l√∫c 00:00)
            # T√≠nh th·ªùi gian ƒë·∫øn 00:00 ng√†y h√¥m sau
            tomorrow = datetime(now.year, now.month, now.day) + timedelta(days=1)
            seconds_until_midnight = (tomorrow - now).total_seconds()
            
            # Ng·ªß ƒë·∫øn 00:00 ng√†y h√¥m sau, nh∆∞ng t·ªëi thi·ªÉu 1 gi·ªù ƒë·ªÉ tr√°nh l·ªói
            sleep_seconds = max(3600, int(seconds_until_midnight))
            time.sleep(sleep_seconds)
            
        except Exception as e:
            print(f"‚ö†Ô∏è L·ªói trong yearly reset worker: {e}")
            # Ng·ªß 1 gi·ªù tr∆∞·ªõc khi th·ª≠ l·∫°i
            time.sleep(3600)

def ensure_yearly_reset_scheduler_started():
    """Kh·ªüi ch·∫°y thread reset l·ªãch h√†ng nƒÉm m·ªôt l·∫ßn duy nh·∫•t"""
    global _yearly_reset_scheduler_started
    if _yearly_reset_scheduler_started:
        return
    with _yearly_reset_scheduler_lock:
        if _yearly_reset_scheduler_started:
            return
        try:
            t = threading.Thread(
                target=_yearly_reset_worker,
                daemon=True
            )
            t.start()
            _yearly_reset_scheduler_started = True
            print(f"üìÖ Yearly reset scheduler started: t·ª± ƒë·ªông reset l·ªãch v√†o ng√†y 1/1 h√†ng nƒÉm")
        except Exception as e:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi ch·∫°y yearly reset scheduler: {e}")

def start_all_background_services():
    """
    Kh·ªüi ƒë·ªông t·∫•t c·∫£ c√°c d·ªãch v·ª• n·ªÅn: backup + token keep-alive + yearly reset
    """
    print("üöÄ Kh·ªüi ƒë·ªông c√°c d·ªãch v·ª• n·ªÅn...")
    
    # Kh·ªüi ƒë·ªông backup scheduler
    try:
        ensure_backup_scheduler_started(interval_minutes=60, backup_dir="backups", retention=3, send_to_telegram=True)
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói kh·ªüi ƒë·ªông backup scheduler: {e}")
    
    # Kh·ªüi ƒë·ªông token keep-alive
    try:
        ensure_token_keepalive_started(interval_minutes=30)
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói kh·ªüi ƒë·ªông token keep-alive: {e}")
    
    # Kh·ªüi ƒë·ªông yearly reset scheduler
    try:
        ensure_yearly_reset_scheduler_started()
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói kh·ªüi ƒë·ªông yearly reset scheduler: {e}")
    
    # Kh·ªüi ƒë·ªông license online checker (m·∫∑c ƒë·ªãnh 60 gi√¢y ki·ªÉm tra 1 l·∫ßn)
    try:
        ensure_license_check_started(interval_seconds=60)
    except Exception as e:
        print(f"[LICENSE] L·ªói kh·ªüi ƒë·ªông license online checker: {e}")
    
    print("‚úÖ T·∫•t c·∫£ d·ªãch v·ª• n·ªÅn ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông!")

# --- Helper function ƒë·ªÉ x·ª≠ l√Ω ƒë·ªãnh d·∫°ng th·ªùi gian SA/CH/AM/PM ---
def clean_time_format(time_str):
    """X·ª≠ l√Ω ƒë·ªãnh d·∫°ng th·ªùi gian c√≥ SA/CH/AM/PM"""
    if not time_str:
        return '00:00'
    
    # X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho c√°c tr∆∞·ªùng h·ª£p 12:00
    if '12:00' in time_str:
        # 12:00 SA = 12:00 tr∆∞a (PM) - trong ti·∫øng Vi·ªát
        if 'SA' in time_str:
            return '12:00'
        # 12:00 CH = 12:00 chi·ªÅu (PM) - trong ti·∫øng Vi·ªát  
        elif 'CH' in time_str:
            return '12:00'
        # 12:00 PM = 12:00 tr∆∞a (PM) - chu·∫©n qu·ªëc t·∫ø
        elif 'PM' in time_str:
            return '12:00'
        # 12:00 AM = 00:00 n·ª≠a ƒë√™m (AM) - chu·∫©n qu·ªëc t·∫ø
        elif 'AM' in time_str:
            return '00:00'
        else:
            return '12:00'
    else:
        # X·ª≠ l√Ω ƒë·ªãnh d·∫°ng th·ªùi gian c√≥ th·ªÉ c√≥ SA/CH/AM/PM
        return time_str.replace('SA', '').replace('CH', '').replace('AM', '').replace('PM', '').strip()

# --- Google Drive API Routes ---
@app.route('/api/google-drive/update-sheet', methods=['POST'])
@login_required
def update_google_sheet():
    """API ƒë·ªÉ c·∫≠p nh·∫≠t Google Sheets thay v√¨ m·ªü Chrome"""
    try:
        data = request.get_json()
        
        # Ki·ªÉm tra quy·ªÅn admin ho·∫∑c manager
        user = db.session.get(User, session['user_id'])
        if not user or not any(role in ['ADMIN', 'MANAGER'] for role in user.roles.split(',')):
            return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 403
        
        # L·∫•y th√¥ng tin t·ª´ request
        spreadsheet_id = data.get('spreadsheet_id')
        sheet_name = data.get('sheet_name')
        row = data.get('row')
        column = data.get('column')
        new_value = data.get('new_value')
        
        if not all([spreadsheet_id, sheet_name, row, column, new_value is not None]):
            return jsonify({'error': 'Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc'}), 400
        
        # Kh·ªüi t·∫°o Google Drive API
        google_api = GoogleDriveAPI()
        
        if not google_api.sheets_service:
            return jsonify({'error': 'Kh√¥ng th·ªÉ k·∫øt n·ªëi Google API'}), 500
        
        # C·∫≠p nh·∫≠t gi√° tr·ªã trong sheet
        success = google_api.update_sheet_value(
            spreadsheet_id=spreadsheet_id,
            sheet_name=sheet_name,
            row=int(row),
            column=column,
            new_value=str(new_value)
        )
        
        if success:
            return jsonify({
                'message': 'C·∫≠p nh·∫≠t Google Sheets th√†nh c√¥ng',
                'spreadsheet_id': spreadsheet_id,
                'sheet_name': sheet_name,
                'cell': f"{column}{row}",
                'new_value': new_value
            }), 200
        else:
            return jsonify({'error': 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t Google Sheets'}), 500
            
    except Exception as e:
        print(f"L·ªói khi c·∫≠p nh·∫≠t Google Sheets: {e}")
        return jsonify({'error': 'L·ªói h·ªá th·ªëng'}), 500

@app.route('/api/google-drive/find-bud-timesheet', methods=['GET'])
@login_required
def find_bud_timesheet():
    """API ƒë·ªÉ t√¨m file Bud_TimeSheet-202510"""
    try:
        # Ki·ªÉm tra quy·ªÅn admin ho·∫∑c manager
        user = db.session.get(User, session['user_id'])
        if not user or not any(role in ['ADMIN', 'MANAGER'] for role in user.roles.split(',')):
            return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 403
        
        # Kh·ªüi t·∫°o Google Drive API
        google_api = GoogleDriveAPI()
        
        if not google_api.drive_service:
            return jsonify({'error': 'Kh√¥ng th·ªÉ k·∫øt n·ªëi Google API'}), 500
        
        # T√¨m file Bud_TimeSheet-202510
        target_file = google_api.find_and_read_bud_timesheet(GOOGLE_DRIVE_FOLDER_ID)
        
        if target_file:
            return jsonify({
                'message': 'T√¨m th·∫•y file Bud_TimeSheet-202510',
                'file_id': target_file['id'],
                'file_name': target_file['name'],
                'file_type': google_api._get_file_type(target_file['mimeType']),
                'web_view_link': target_file.get('webViewLink', 'N/A')
            }), 200
        else:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y file Bud_TimeSheet-202510'}), 404
            
    except Exception as e:
        print(f"L·ªói khi t√¨m file Bud_TimeSheet: {e}")
        return jsonify({'error': 'L·ªói h·ªá th·ªëng'}), 500

@app.route('/api/google-drive/list-timesheets', methods=['GET'])
@login_required
def list_all_timesheets():
    """API ƒë·ªÉ l·∫•y danh s√°ch t·∫•t c·∫£ file timesheet"""
    try:
        # Ki·ªÉm tra quy·ªÅn admin ho·∫∑c manager
        user = db.session.get(User, session['user_id'])
        if not user or not any(role in ['ADMIN', 'MANAGER'] for role in user.roles.split(',')):
            return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 403
        
        # Kh·ªüi t·∫°o Google Drive API
        google_api = GoogleDriveAPI()
        
        if not google_api.drive_service:
            return jsonify({'error': 'Kh√¥ng th·ªÉ k·∫øt n·ªëi Google API'}), 500
        
        # L·∫•y danh s√°ch t·∫•t c·∫£ file timesheet
        timesheets = google_api.list_all_timesheets(GOOGLE_DRIVE_FOLDER_ID)
        
        if timesheets:
            return jsonify({
                'message': f'T√¨m th·∫•y {len(timesheets)} file timesheet',
                'count': len(timesheets),
                'files': [
                    {
                        'id': file['id'],
                        'name': file['name'],
                        'type': google_api._get_file_type(file['mimeType']),
                        'size': file.get('size', 'N/A'),
                        'modified_time': file['modifiedTime'],
                        'web_view_link': file.get('webViewLink', 'N/A')
                    }
                    for file in timesheets
                ]
            }), 200
        else:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y file timesheet n√†o'}), 404
            
    except Exception as e:
        print(f"L·ªói khi l·∫•y danh s√°ch file timesheet: {e}")
        return jsonify({'error': 'L·ªói h·ªá th·ªëng'}), 500

@app.route('/api/google-drive/department-mapping', methods=['GET'])
@login_required
def get_department_mapping():
    """API ƒë·ªÉ l·∫•y mapping ph√≤ng ban v·ªõi file timesheet"""
    try:
        # Ki·ªÉm tra quy·ªÅn admin ho·∫∑c manager
        user = db.session.get(User, session['user_id'])
        if not user or not any(role in ['ADMIN', 'MANAGER'] for role in user.roles.split(',')):
            return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 403
        
        # Kh·ªüi t·∫°o Google Drive API
        google_api = GoogleDriveAPI()
        
        # L·∫•y mapping ph√≤ng ban
        mappings = google_api.get_all_department_mappings()
        
        return jsonify({
            'message': 'Mapping ph√≤ng ban v·ªõi file timesheet',
            'mappings': mappings,
            'note': 'York v√† Como ƒë·ªÅu s·ª≠ d·ª•ng Chirashi_TimeSheet'
        }), 200
            
    except Exception as e:
        print(f"L·ªói khi l·∫•y mapping ph√≤ng ban: {e}")
        return jsonify({'error': 'L·ªói h·ªá th·ªëng'}), 500

# --- Helper function ƒë·ªÉ x·ª≠ l√Ω ƒë·ªãnh d·∫°ng th·ªùi gian SA/CH/AM/PM ---
def clean_time_format(time_str):
    """X·ª≠ l√Ω ƒë·ªãnh d·∫°ng th·ªùi gian c√≥ SA/CH/AM/PM"""
    if not time_str:
        return '00:00'
    
    # X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho c√°c tr∆∞·ªùng h·ª£p 12:00
    if '12:00' in time_str:
        # 12:00 SA = 12:00 tr∆∞a (PM) - trong ti·∫øng Vi·ªát
        if 'SA' in time_str:
            return '12:00'
        # 12:00 CH = 12:00 chi·ªÅu (PM) - trong ti·∫øng Vi·ªát  
        elif 'CH' in time_str:
            return '12:00'
        # 12:00 PM = 12:00 tr∆∞a (PM) - chu·∫©n qu·ªëc t·∫ø
        elif 'PM' in time_str:
            return '12:00'
        # 12:00 AM = 00:00 n·ª≠a ƒë√™m (AM) - chu·∫©n qu·ªëc t·∫ø
        elif 'AM' in time_str:
            return '00:00'
        else:
            return '12:00'
    else:
        # X·ª≠ l√Ω ƒë·ªãnh d·∫°ng th·ªùi gian c√≥ th·ªÉ c√≥ SA/CH/AM/PM
        return time_str.replace('SA', '').replace('CH', '').replace('AM', '').replace('PM', '').strip()

# --- Helper t√≠nh ƒë∆°n v·ªã ngh·ªâ theo ca ---
def _compute_leave_units_generic(from_date_dt: datetime, from_time_str: str, to_date_dt: datetime, to_time_str: str) -> float:
    try:
        # X·ª≠ l√Ω ƒë·ªãnh d·∫°ng th·ªùi gian c√≥ SA/CH/AM/PM
        clean_from_time = clean_time_format(from_time_str)
        clean_to_time = clean_time_format(to_time_str)
        
        start_dt = datetime.combine(from_date_dt.date(), datetime.strptime(clean_from_time, '%H:%M').time())
        end_dt = datetime.combine(to_date_dt.date(), datetime.strptime(clean_to_time, '%H:%M').time())
    except Exception:
        # Fallback: t√≠nh theo s·ªë ng√†y l·ªãch
        return max(0.0, (to_date_dt - from_date_dt).days + 1)
    if end_dt < start_dt:
        return 0.0
    workday_hours = 8.0
    half_hours = 4.0
    if start_dt.date() == end_dt.date():
        hours = (end_dt - start_dt).total_seconds() / 3600.0
        if hours <= 0:
            return 0.0
        # Logic t√≠nh theo th·ªùi gian l√†m vi·ªác th·ª±c t·∫ø (tr·ª´ gi·ªù ngh·ªâ)
        # 1 ng√†y = 8 ti·∫øng l√†m vi·ªác, 0.5 ng√†y = 4 ti·∫øng l√†m vi·ªác
        # L√†m tr√≤n ƒë·∫øn 0.5
        days = round((hours / workday_hours) * 2) / 2.0
        return days
    # nhi·ªÅu ng√†y
    end_of_first = datetime.combine(start_dt.date(), time(23,59,59))
    first_hours = (end_of_first - start_dt).total_seconds() / 3600.0
    first_unit = round((first_hours / workday_hours) * 2) / 2.0
    
    start_of_last = datetime.combine(end_dt.date(), time(0,0,0))
    last_hours = (end_dt - start_of_last).total_seconds() / 3600.0
    last_unit = round((last_hours / workday_hours) * 2) / 2.0
    
    middle_days = (to_date_dt.date() - from_date_dt.date()).days - 1
    middle_units = max(0, middle_days) * 1.0
    
    total_units = first_unit + middle_units + last_unit
    return round(total_units * 2) / 2.0

# Load configuration
config_name = os.environ.get('FLASK_CONFIG') or 'default'
app.config.from_object(config[config_name])

# Initialize CSRF protection
csrf = CSRFProtect(app)


# Error handler ƒë·ªÉ catch 404 v√† log
@app.errorhandler(404)
def handle_404(e):
    """Log 404 errors ƒë·ªÉ debug routing issues"""
    import sys
    print(f"[404 ERROR] ====== ROUTE NOT FOUND ======", file=sys.stderr, flush=True)
    print(f"[404 ERROR] ====== ROUTE NOT FOUND ======", flush=True)
    print(f"[404 ERROR] Method: {request.method}", file=sys.stderr, flush=True)
    print(f"[404 ERROR] Method: {request.method}", flush=True)
    print(f"[404 ERROR] Path: {request.path}", file=sys.stderr, flush=True)
    print(f"[404 ERROR] Path: {request.path}", flush=True)
    print(f"[404 ERROR] Full URL: {request.url}", file=sys.stderr, flush=True)
    print(f"[404 ERROR] Full URL: {request.url}", flush=True)
    print(f"[404 ERROR] Endpoint: {request.endpoint}", file=sys.stderr, flush=True)
    print(f"[404 ERROR] Endpoint: {request.endpoint}", flush=True)
    print(f"[404 ERROR] Args: {dict(request.args)}", file=sys.stderr, flush=True)
    print(f"[404 ERROR] Args: {dict(request.args)}", flush=True)
    print(f"[404 ERROR] Remote Addr: {request.remote_addr}", file=sys.stderr, flush=True)
    print(f"[404 ERROR] Remote Addr: {request.remote_addr}", flush=True)
    
    # Ki·ªÉm tra n·∫øu l√† route export
    if 'export-attendance-history-excel' in request.path or 'export' in request.path.lower():
        print(f"[404 ERROR] ‚ö†Ô∏è EXPORT ROUTE NOT FOUND!", file=sys.stderr, flush=True)
        print(f"[404 ERROR] ‚ö†Ô∏è EXPORT ROUTE NOT FOUND!", flush=True)
        print(f"[404 ERROR] Registered routes containing 'export':", file=sys.stderr, flush=True)
        print(f"[404 ERROR] Registered routes containing 'export':", flush=True)
        from flask import current_app
        for rule in current_app.url_map.iter_rules():
            if 'export' in str(rule):
                print(f"[404 ERROR]   - {rule.rule} -> {rule.endpoint} ({rule.methods})", file=sys.stderr, flush=True)
                print(f"[404 ERROR]   - {rule.rule} -> {rule.endpoint} ({rule.methods})", flush=True)
    
    print(f"[404 ERROR] =============================", file=sys.stderr, flush=True)
    print(f"[404 ERROR] =============================", flush=True)
    return jsonify({'error': 'Route not found', 'path': request.path}), 404

# CSRF protection is enabled for all routes
# No need to disable in development

# Expose csrf_token() helper to Jinja templates
@app.context_processor
def inject_csrf_token():
    return dict(csrf_token=generate_csrf)

# Time formatting helper (convert UTC -> local, e.g., UTC+7)
@app.context_processor
def inject_format_helpers():
    def format_local(dt, hours_offset=7):
        try:
            if not dt:
                return ''
            return (dt + timedelta(hours=hours_offset)).strftime('%d/%m/%Y %H:%M')
        except Exception:
            return dt.strftime('%d/%m/%Y %H:%M') if dt else ''
    return dict(format_local=format_local)

# Initialize database
db.init_app(app)
migrate = Migrate(app, db)

# Initialize signature manager
signature_manager.init_app(app)

login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

# Handler ƒë·ªÉ API routes tr·∫£ v·ªÅ JSON thay v√¨ redirect HTML khi ch∆∞a ƒëƒÉng nh·∫≠p
@login_manager.unauthorized_handler
def unauthorized():
    # N·∫øu request l√† API call (c√≥ header Accept: application/json ho·∫∑c path b·∫Øt ƒë·∫ßu b·∫±ng /api/)
    if request.path.startswith('/api/') or request.headers.get('Accept', '').startswith('application/json'):
        return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p', 'day_type': 'normal', 'reason': 'Ng√†y th∆∞·ªùng (fallback)'}), 401
    # Ng∆∞·ª£c l·∫°i, redirect v·ªÅ login nh∆∞ b√¨nh th∆∞·ªùng
    return redirect(url_for('login'))

# Import rate limiting from utils
from utils.decorators import rate_limit

@login_manager.user_loader
def load_user(user_id):
    return db.session.get(User, int(user_id))


# ==========================
# License / Activation utils
# ==========================
def get_activation_record():
    """L·∫•y (ho·∫∑c t·∫°o m·∫∑c ƒë·ªãnh) b·∫£n ghi k√≠ch ho·∫°t duy nh·∫•t - c√≥ retry ƒë·ªÉ tr√°nh database locked."""
    import time

    max_retries = 3
    for attempt in range(max_retries):
        try:
            activation = Activation.query.get(1)
            if not activation:
                activation = Activation(id=1, is_activated=False)
                db.session.add(activation)
                try:
                    db.session.commit()
                except Exception:
                    db.session.rollback()
            return activation
        except Exception as e:
            error_str = str(e).lower()
            if 'locked' in error_str or 'busy' in error_str:
                if attempt < max_retries - 1:
                    time.sleep(0.5 * (attempt + 1))  # 0.5s, 1s, 1.5s
                    continue
            raise
    return None


def is_app_activated():
    """Ki·ªÉm tra ·ª©ng d·ª•ng ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t hay ch∆∞a."""
    activation = get_activation_record()
    return bool(activation and activation.is_activated)


def get_license_key():
    """
    L·∫•y license key m·ªôt c√°ch nh·∫•t qu√°n cho c·∫£ web v√† mobile.
    ∆Øu ti√™n: Environment variable (APP_LICENSE_KEY) > Database (activation.license_key)
    
    L√Ω do: 
    - Environment variable l√† ngu·ªìn "master" ƒë∆∞·ª£c config tr√™n server, ƒë·∫£m b·∫£o nh·∫•t qu√°n
    - Database c√≥ th·ªÉ ch·ª©a key c≈©/kh√¥ng h·ª£p l·ªá t·ª´ l·∫ßn k√≠ch ho·∫°t tr∆∞·ªõc
    - N·∫øu environment variable ƒë∆∞·ª£c set, n√≥ s·∫Ω override database ƒë·ªÉ ƒë·∫£m b·∫£o d√πng key ƒë√∫ng
    """
    # ∆Øu ti√™n environment variable tr∆∞·ªõc (key "master" tr√™n server)
    license_key = (APP_LICENSE_KEY or '').strip()
    
    # Ki·ªÉm tra xem database c√≥ key kh√°c kh√¥ng (ƒë·ªÉ c·∫£nh b√°o n·∫øu c√≥ s·ª± kh√¥ng nh·∫•t qu√°n)
    activation = None
    try:
        activation = get_activation_record()
    except Exception as e:
        # Ch·ªâ log n·∫øu kh√¥ng ph·∫£i l·ªói application context (v√¨ c√≥ th·ªÉ g·ªçi ngo√†i context)
        if "application context" not in str(e).lower():
            print(f"[LICENSE] L·ªói l·∫•y activation record: {e}")
    
    db_key = None
    if activation is not None:
        db_key = (getattr(activation, 'license_key', None) or '').strip()
    
    # C·∫£nh b√°o n·∫øu key trong database kh√°c v·ªõi environment variable
    if license_key and db_key and license_key != db_key:
        print(f"[LICENSE] ‚ö†Ô∏è C·∫¢NH B√ÅO: Key trong database ('{db_key[:10]}...') kh√°c v·ªõi environment variable ('{license_key[:10]}...'). ƒêang d√πng key t·ª´ environment variable.", flush=True)
    
    # N·∫øu kh√¥ng c√≥ environment variable, m·ªõi l·∫•y t·ª´ database
    if not license_key:
        license_key = db_key
    
    return license_key

# ====== LICENSE ACCESS CONTROL ======
@app.before_request
def check_license_before_request():
    """
    Ch·∫∑n t·∫•t c·∫£ request khi license h·∫øt h·∫°n.
    Cho ph√©p truy c·∫≠p static files v√† trang activate.
    """
    # [FIX] Comment out prints to prevent OSError: [Errno 22] Invalid argument
    # caused by corrupted stdout in some Windows environments
    # print(f"[LICENSE CHECK] ====== LICENSE CHECK CALLED ======")
    # print(f"[LICENSE CHECK] {request.method} {request.path}, endpoint: {request.endpoint}")
    
    # Debug: log m·ªçi request ƒë·ªÉ ki·ªÉm tra
    if 'export-attendance-history-excel' in request.path or 'export' in request.path.lower():
        # print(f"[LICENSE CHECK] ‚ö†Ô∏è EXPORT REQUEST DETECTED IN LICENSE CHECK!")
        # print(f"[LICENSE CHECK] Export request: {request.method} {request.path}, endpoint: {request.endpoint}")
        # print(f"[LICENSE CHECK] Full URL: {request.url}")
        pass
    
    # Cho ph√©p truy c·∫≠p static files v√† trang activate
    if request.endpoint in ('static', 'activate') or request.path.startswith('/static/'):
        return None
    
    # Cho ph√©p truy c·∫≠p c√°c route export Excel (ki·ªÉm tra c·∫£ endpoint v√† path)
    export_paths = ['/export-attendance-history-excel', '/export-leave-history-excel', '/export-leave-cases-excel']
    if any(path in request.path for path in export_paths):
        # print(f"[LICENSE CHECK] Allowing export route: {request.path}, endpoint: {request.endpoint}")
        return None
    
    if request.endpoint in ('export_attendance_history_excel', 'export_leave_history_excel', 'export_leave_cases_excel'):
        # print(f"[LICENSE CHECK] Allowing export route by endpoint: {request.endpoint}")
        return None
    
    # N·∫øu license kh√¥ng h·ª£p l·ªá, ch·∫∑n t·∫•t c·∫£ request kh√°c
    if not _license_is_valid:
        # Security: D√πng render_template() thay v√¨ render_template_string() ƒë·ªÉ tr√°nh template injection
        from flask import render_template
        contact_msg = (
            "License kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.\n\n"
            "Vui l√≤ng li√™n h·ªá ADMIN ƒë·ªÉ gia h·∫°n:\n"
            "Nguy·ªÖn C√¥ng ƒê·∫°t - 0375097105.\n\n"
            "H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông ki·ªÉm tra l·∫°i license sau 60 gi√¢y."
        )
        
        # Tr·∫£ v·ªÅ trang HTML th√¥ng b√°o license h·∫øt h·∫°n t·ª´ file template
        # (ƒê√£ x√≥a hardcoded HTML template ƒë·ªÉ tr√°nh template injection risk)
        return render_template('license_expired.html', message=contact_msg), 403
    
    return None

# Routes
# Route export attendance history Excel - MOVED HERE TO ENSURE EARLY REGISTRATION
# ƒê·∫£m b·∫£o route ƒë∆∞·ª£c ƒëƒÉng k√Ω tr∆∞·ªõc c√°c route kh√°c ƒë·ªÉ tr√°nh conflict
# Khai b√°o th√™m bi·∫øn th·ªÉ c√≥ d·∫•u "/" cu·ªëi ƒë·ªÉ ch·∫Øc ch·∫Øn match m·ªçi URL
@app.route('/export-attendance-history-excel', methods=['GET', 'OPTIONS'], strict_slashes=False)
@app.route('/export-attendance-history-excel/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@csrf.exempt
def export_attendance_history_excel():
    """
    Xu·∫•t l·ªãch s·ª≠ ch·∫•m c√¥ng ra file Excel chu·∫©n, d·ªÖ ƒë·ªçc/d·ªÖ in v·ªõi c√°c c·ªôt:
    Ng√†y, Nh√¢n vi√™n, M√£ nh√¢n vi√™n, Ph√≤ng ban, Gi·ªù v√†o, Gi·ªù ra, Ngh·ªâ,
    ƒê·ªëi ·ª©ng, T·ªïng gi·ªù l√†m, Gi·ªù c√¥ng, TƒÉng ca tr∆∞·ªõc 22h, TƒÉng ca sau 22h, Lo·∫°i ng√†y.
    """
    # Handle OPTIONS request for CORS
    if request.method == 'OPTIONS':
        response = make_response()
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type')
        response.headers.add('Access-Control-Allow-Methods', 'GET, OPTIONS')
        return response
    import sys
    print(f"[EXPORT EXCEL] ====== H√ÄM ƒê∆Ø·ª¢C G·ªåI ====== Path: {request.path}, Method: {request.method}, Endpoint: {request.endpoint}", file=sys.stderr, flush=True)
    print(f"[EXPORT EXCEL] ====== H√ÄM ƒê∆Ø·ª¢C G·ªåI ====== Path: {request.path}, Method: {request.method}, Endpoint: {request.endpoint}", flush=True)
    print(f"[EXPORT EXCEL] Request URL: {request.url}, Full Path: {request.full_path}", flush=True)
    print(f"[EXPORT EXCEL] Remote Addr: {request.remote_addr}", flush=True)
    print(f"[EXPORT EXCEL] Headers: {dict(request.headers)}", flush=True)
    try:
        logger.info("[EXPORT EXCEL] B·∫Øt ƒë·∫ßu xu·∫•t Excel l·ªãch s·ª≠ ch·∫•m c√¥ng")
        
        if 'user_id' not in session:
            logger.warning("[EXPORT EXCEL] Kh√¥ng c√≥ user_id trong session")
            return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
        if check_session_timeout():
            logger.warning("[EXPORT EXCEL] Session ƒë√£ h·∫øt h·∫°n")
            return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
        update_session_activity()

        user = db.session.get(User, session['user_id'])
        if not user:
            logger.warning(f"[EXPORT EXCEL] Kh√¥ng t√¨m th·∫•y user v·ªõi ID: {session.get('user_id')}")
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404

        current_role = session.get('current_role', user.roles.split(',')[0])
        if current_role != 'ADMIN':
            logger.warning(f"[EXPORT EXCEL] User {user.id} kh√¥ng ph·∫£i ADMIN, role: {current_role}")
            return jsonify({'error': 'Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ quy·ªÅn xu·∫•t Excel l·ªãch s·ª≠ ch·∫•m c√¥ng'}), 403

        logger.info(f"[EXPORT EXCEL] User {user.id} ({user.name}) ƒëang xu·∫•t Excel")
        
        from utils.query_optimizer import optimize_attendance_history_query

        # L·∫•y tham s·ªë l·ªçc gi·ªëng API l·ªãch s·ª≠ ch·∫•m c√¥ng
        search = (request.args.get('search') or '').strip()
        department = (request.args.get('department') or '').strip()
        date_from_str = (request.args.get('date_from') or '').strip()
        date_to_str = (request.args.get('date_to') or '').strip()
        # H·ªó tr·ª£ l·ªçc theo kho·∫£ng th√°ng/nƒÉm
        month_from = (request.args.get('month_from') or '').strip() or None
        month_to = (request.args.get('month_to') or '').strip() or None
        year_from = (request.args.get('year_from') or '').strip() or None
        year_to = (request.args.get('year_to') or '').strip() or None
        
        logger.info(f"[EXPORT EXCEL] Tham s·ªë: search={search}, department={department}, date_from={date_from_str}, date_to={date_to_str}, month_from={month_from}, month_to={month_to}, year_from={year_from}, year_to={year_to}")

        date_from = validate_date(date_from_str) if date_from_str else None
        date_to = validate_date(date_to_str) if date_to_str else None

        # N·∫øu ch∆∞a ch·ªçn ng√†y nh∆∞ng c√≥ ch·ªçn th√°ng -> chuy·ªÉn ƒë·ªïi sang date_from/date_to
        # N·∫øu c√≥ month_from nh∆∞ng kh√¥ng c√≥ year_from, d√πng nƒÉm hi·ªán t·∫°i l√†m m·∫∑c ƒë·ªãnh
        if not date_from and month_from:
            # N·∫øu kh√¥ng c√≥ year_from, d√πng nƒÉm hi·ªán t·∫°i
            if not year_from:
                from datetime import datetime
                year_from = str(datetime.now().year)
                logger.info(f"[EXPORT EXCEL] Kh√¥ng c√≥ year_from, d√πng nƒÉm hi·ªán t·∫°i: {year_from}")
            
            # ƒê·∫£m b·∫£o year_from c√≥ gi√° tr·ªã tr∆∞·ªõc khi x·ª≠ l√Ω
            if year_from:
                try:
                    import calendar
                    month_from_val = int(month_from)
                    year_from_val = int(year_from)
                    # N·∫øu c√≥ month_to v√† year_to th√¨ d√πng c·∫£ hai
                    # N·∫øu ch·ªâ c√≥ month_to th√¨ d√πng month_to v·ªõi year_from
                    # N·∫øu kh√¥ng c√≥ month_to th√¨ d√πng month_from v√† year_from
                    if month_to and year_to:
                        month_to_val = int(month_to)
                        year_to_val = int(year_to)
                    elif month_to:
                        month_to_val = int(month_to)
                        year_to_val = year_from_val
                    else:
                        month_to_val = month_from_val
                        year_to_val = year_from_val
                    # Gi·ªõi h·∫°n h·ª£p l·ªá
                    if not (1 <= month_from_val <= 12 and 1 <= month_to_val <= 12):
                        return jsonify({'error': 'Th√°ng kh√¥ng h·ª£p l·ªá'}), 400
                    if not (2000 <= year_from_val <= 2100 and 2000 <= year_to_val <= 2100):
                        return jsonify({'error': 'NƒÉm kh√¥ng h·ª£p l·ªá'}), 400
                    from datetime import date as _date
                    date_from = _date(year_from_val, month_from_val, 1)
                    # T√≠nh ng√†y cu·ªëi c√πng c·ªßa th√°ng_to/year_to
                    last_day = calendar.monthrange(year_to_val, month_to_val)[1]
                    date_to = _date(year_to_val, month_to_val, last_day)
                    logger.info(f"[EXPORT EXCEL] ƒê√£ chuy·ªÉn ƒë·ªïi th√°ng/nƒÉm th√†nh date_from={date_from}, date_to={date_to}")
                except Exception as e:
                    logger.error(f"[EXPORT EXCEL] L·ªói chuy·ªÉn ƒë·ªïi th√°ng/nƒÉm: {e}")
                    return jsonify({'error': 'Tham s·ªë th√°ng/nƒÉm kh√¥ng h·ª£p l·ªá'}), 400

        # N·∫øu v·∫´n kh√¥ng c√≥ kho·∫£ng l·ªçc n√†o, ch·∫∑n t·∫£i tr·ªëng
        # Ki·ªÉm tra c·∫£ date_from/date_to v√† month_from/month_to (year c√≥ th·ªÉ l√† m·∫∑c ƒë·ªãnh)
        has_date_filter = date_from or date_to
        has_month_filter = month_from  # Ch·ªâ c·∫ßn month_from l√† ƒë·ªß, year s·∫Ω ƒë∆∞·ª£c set m·∫∑c ƒë·ªãnh n·∫øu c·∫ßn
        has_other_filters = search or department
        
        if not (has_date_filter or has_month_filter or has_other_filters):
            logger.warning("[EXPORT EXCEL] Kh√¥ng c√≥ b·ªô l·ªçc n√†o ƒë∆∞·ª£c cung c·∫•p")
            return jsonify({'error': 'Kh√¥ng c√≥ gi√° tr·ªã n√†o ƒë·ªÉ xu·∫•t. Vui l√≤ng ch·ªçn ng√†y/th√°ng/nƒÉm ho·∫∑c b·ªô l·ªçc.'}), 400

        # L·∫•y to√†n b·ªô b·∫£n ghi (ƒë√£ ph√™ duy·ªát) theo b·ªô l·ªçc
        logger.info("[EXPORT EXCEL] ƒêang truy v·∫•n d·ªØ li·ªáu ch·∫•m c√¥ng...")
        attendances, total = optimize_attendance_history_query(
            search=search or None,
            department=department or None,
            date_from=date_from,
            date_to=date_to,
            user_id=user.id,
            page=1,
            per_page=100000,  # Get all records for export
            is_admin=True
        )
        
        logger.info(f"[EXPORT EXCEL] T√¨m th·∫•y {total} b·∫£n ghi, l·∫•y ƒë∆∞·ª£c {len(attendances)} b·∫£n ghi")

        if not attendances:
            logger.warning("[EXPORT EXCEL] Kh√¥ng c√≥ d·ªØ li·ªáu ch·∫•m c√¥ng ƒë·ªÉ xu·∫•t")
            return jsonify({'error': 'Kh√¥ng c√≥ d·ªØ li·ªáu ch·∫•m c√¥ng ƒë·ªÉ xu·∫•t Excel'}), 404

        wb = Workbook()
        ws = wb.active
        ws.title = "L·ªãch s·ª≠ ch·∫•m c√¥ng"

        # ƒê·ªãnh d·∫°ng header
        header_font = Font(bold=True)
        header_alignment = Alignment(horizontal="center", vertical="center")
        center_alignment = Alignment(horizontal="center", vertical="center")
        left_alignment = Alignment(horizontal="left", vertical="center")
        right_alignment = Alignment(horizontal="right", vertical="center")
        thin_border = Border(
            left=Side(style="thin"),
            right=Side(style="thin"),
            top=Side(style="thin"),
            bottom=Side(style="thin")
        )

        headers = [
            "Ng√†y",
            "Nh√¢n vi√™n",
            "M√£ nh√¢n vi√™n",
            "Ph√≤ng ban",
            "Gi·ªù v√†o",
            "Gi·ªù ra",
            "Ngh·ªâ",
            "ƒê·ªëi ·ª©ng",
            "T·ªïng gi·ªù l√†m",
            "Gi·ªù c√¥ng",
            "TƒÉng ca tr∆∞·ªõc 22h",
            "TƒÉng ca sau 22h",
            "Lo·∫°i ng√†y"
        ]

        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = header_font
            cell.alignment = header_alignment
            cell.border = thin_border

        # Helper t√≠nh t·ªïng ƒë·ªëi ·ª©ng (HH:MM) ‚Äì gi·ªØ d·∫°ng chu·ªói ƒë·ªÉ tr√°nh m·∫•t d·ªØ li·ªáu khi convert
        def _calc_comp_total(att_obj):
            def hhmm_to_minutes_safe(v):
                try:
                    if not v or v in ["0", "0:00"]:
                        return 0
                    if isinstance(v, str) and ":" in v:
                        h, m = v.split(":", 1)
                        return int(h or "0") * 60 + int(m or "0")
                except Exception:
                    return 0
                return 0

            comp_regular = att_obj._format_minutes_to_hhmm(att_obj.comp_time_regular_minutes)
            comp_ot = att_obj._format_minutes_to_hhmm(att_obj.comp_time_overtime_minutes)
            comp_before_22 = att_obj._format_minutes_to_hhmm(att_obj.comp_time_ot_before_22_minutes)
            comp_after_22 = att_obj._format_minutes_to_hhmm(att_obj.comp_time_ot_after_22_minutes)
            overtime_comp = att_obj._format_minutes_to_hhmm(att_obj.overtime_comp_time_minutes)

            total_minutes = (
                hhmm_to_minutes_safe(comp_regular)
                + hhmm_to_minutes_safe(comp_ot)
                + hhmm_to_minutes_safe(comp_before_22)
                + hhmm_to_minutes_safe(comp_after_22)
                + hhmm_to_minutes_safe(overtime_comp)
            )
            return f"{total_minutes // 60}:{total_minutes % 60:02d}"

        # Ghi d·ªØ li·ªáu
        row_idx = 2
        for att in attendances:
            att_dict = att.to_dict()
            user_obj = att.user

            ngay_val = att.date
            nhanvien_val = user_obj.name if user_obj and user_obj.name else "-"
            # ƒê·∫£m b·∫£o m√£ nh√¢n vi√™n l√† chu·ªói ƒë·ªÉ tr√°nh Excel hi·ªÉu nh·∫ßm l√† th·ªùi gian
            # Convert sang string ngay t·ª´ ƒë·∫ßu, k·ªÉ c·∫£ khi l√† s·ªë 0
            if user_obj and user_obj.employee_id is not None:
                manv_val = str(user_obj.employee_id).strip()
            else:
                manv_val = ""
            if user_obj and user_obj.department:
                phongban_val = str(user_obj.department).strip()
            else:
                phongban_val = ""

            # Gi·ªØ nguy√™n chu·ªói HH:MM ƒë·ªÉ tr√°nh m·∫•t d·ªØ li·ªáu (ƒë√£ g·∫∑p t√¨nh tr·∫°ng None khi convert time)
            gio_vao = att_dict.get("check_in") or ""
            gio_ra = att_dict.get("check_out") or ""
            nghi_val = att_dict.get("break_time") or ""
            doi_ung_val = _calc_comp_total(att) or ""
            tong_gio_lam = att_dict.get("total_work_hours") or ""
            gio_cong = att_dict.get("work_hours_display") or ""
            ot_truoc_22 = att_dict.get("overtime_before_22") or "0:00"
            ot_sau_22 = att_dict.get("overtime_after_22") or "0:00"
            loai_ngay = att_dict.get("holiday_type") or "-"

            values = [
                ngay_val,
                nhanvien_val,
                manv_val,
                phongban_val,
                gio_vao,
                gio_ra,
                nghi_val,
                doi_ung_val,
                tong_gio_lam,
                gio_cong,
                ot_truoc_22,
                ot_sau_22,
                loai_ngay,
            ]

            for col, val in enumerate(values, 1):
                cell = ws.cell(row=row_idx, column=col)
                cell.border = thin_border

                # ƒê·ªãnh d·∫°ng theo lo·∫°i c·ªôt
                if col == 1:
                    cell.value = val
                    cell.number_format = "dd/mm/yyyy"
                    cell.alignment = center_alignment
                elif col in [2, 13]:  # B: t√™n NV ƒë·ªÉ tr√°i, M: lo·∫°i ng√†y gi·ªØ tr√°i
                    cell.value = val
                    cell.alignment = left_alignment
                elif col in [3, 4]:  # C: M√£ nh√¢n vi√™n, D: Ph√≤ng ban - ƒë·ªãnh d·∫°ng text
                    # ƒê·∫£m b·∫£o gi√° tr·ªã ƒë∆∞·ª£c l∆∞u d∆∞·ªõi d·∫°ng text ƒë·ªÉ tr√°nh Excel hi·ªÉu nh·∫ßm l√† th·ªùi gian
                    # Set format text TR∆Ø·ªöC khi set value ƒë·ªÉ Excel kh√¥ng t·ª± ƒë·ªông convert
                    cell.number_format = "@"  # Text format (@ = text trong Excel)
                    # Gi√° tr·ªã ƒë√£ ƒë∆∞·ª£c convert sang string ·ªü tr√™n, ch·ªâ c·∫ßn set v√†o cell
                    # ƒê·∫£m b·∫£o kh√¥ng ph·∫£i None
                    text_value = str(val).strip() if val is not None and val != "" else ""
                    cell.value = text_value
                    cell.alignment = center_alignment
                else:
                    cell.value = val
                    cell.number_format = "HH:mm"
                    cell.alignment = center_alignment

            row_idx += 1

        # AutoFit ƒë·ªô r·ªông c·ªôt
        for col_idx in range(1, len(headers) + 1):
            column = get_column_letter(col_idx)
            max_len = 0
            for cell in ws[column]:
                try:
                    cell_val = cell.value
                    if isinstance(cell_val, (datetime, date, time)):
                        text = cell_val.strftime("%d/%m/%Y") if col_idx == 1 else cell_val.strftime("%H:%M")
                    else:
                        text = str(cell_val) if cell_val is not None else ""
                    if len(text) > max_len:
                        max_len = len(text)
                except Exception:
                    continue
            ws.column_dimensions[column].width = max(10, min(max_len + 2, 40))

        # T√πy ch·ªânh r·ªông h∆°n cho c·ªôt B (Nh√¢n vi√™n) ƒë·ªÉ ƒë·ªß t√™n d√†i
        current_b_width = ws.column_dimensions["B"].width or 10
        ws.column_dimensions["B"].width = min(current_b_width * 3, 60)  # g·∫•p 3, gi·ªõi h·∫°n 60

        # N·ªõi r·ªông c√°c c·ªôt C -> M (3 -> 13) g·∫•p ƒë√¥i ƒë·ªÉ d·ªÖ ƒë·ªçc
        for col_idx in range(3, 14):
            col_letter = get_column_letter(col_idx)
            current_width = ws.column_dimensions[col_letter].width or 10
            ws.column_dimensions[col_letter].width = min(current_width * 2, 80)

        # CƒÉn gi·ªØa cho c·ªôt C, D (M√£ nh√¢n vi√™n, Ph√≤ng ban) v√† c·ªôt M (Lo·∫°i ng√†y) sau khi set width
        for row in ws.iter_rows(min_row=2, max_row=row_idx - 1, min_col=3, max_col=4):
            for cell in row:
                cell.alignment = center_alignment
        for cell in ws.iter_rows(min_row=2, max_row=row_idx - 1, min_col=13, max_col=13):
            for c in cell:
                c.alignment = center_alignment

        # L·ªçc t·ª± ƒë·ªông cho header
        ws.auto_filter.ref = f"A1:{get_column_letter(len(headers))}{row_idx-1}"

        # L∆∞u file v√†o b·ªô nh·ªõ
        output = BytesIO()
        wb.save(output)
        output.seek(0)

        vn_filename = f"Lich_su_cham_cong_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        from urllib.parse import quote
        ascii_fallback = "lich_su_cham_cong.xlsx"
        content_disposition = (
            f"attachment; filename=\"{ascii_fallback}\"; "
            f"filename*=UTF-8''{quote(vn_filename)}"
        )

        response = make_response(output.getvalue())
        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        response.headers['Content-Disposition'] = content_disposition
        response.headers['Content-Length'] = len(output.getvalue())
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'

        logger.info(f"[EXPORT EXCEL] Xu·∫•t Excel th√†nh c√¥ng, {len(attendances)} b·∫£n ghi")
        return response

    except Exception as e:
        error_msg = f"[ERROR] Error exporting attendance Excel: {e}"
        logger.error(error_msg, exc_info=True)
        print(error_msg)
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói khi xu·∫•t file Excel ch·∫•m c√¥ng: {str(e)}'}), 500

@app.route('/')
def index():
    # N·∫øu app ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t th√¨ b·∫Øt bu·ªôc v√†o trang k√≠ch ho·∫°t
    if not is_app_activated():
        return redirect(url_for('activate'))
    if 'user_id' not in session:
        return redirect(url_for('login'))
    return redirect(url_for('dashboard'))

@app.route('/login', methods=['GET', 'POST'])
@rate_limit(max_requests=100, window_seconds=300)
def login():
    # N·∫øu app ch∆∞a k√≠ch ho·∫°t, kh√¥ng cho login m√† chuy·ªÉn sang trang k√≠ch ho·∫°t
    if not is_app_activated():
        return redirect(url_for('activate'))
    remembered_username = request.cookies.get('remembered_username', '')
    skip_auto_login = request.args.get('logout') == '1'

    if request.method == 'GET':
        remember_token = request.cookies.get('remember_token')
        if remember_token and not skip_auto_login:
            user = User.query.filter_by(remember_token=remember_token).first()
            if user and user.remember_token_expires and user.remember_token_expires > datetime.now():
                # B4: Validate IP and User-Agent for remember token security
                current_ip = request.remote_addr
                current_ua = request.headers.get('User-Agent', '')[:255]

                # Check IP binding (if stored)
                ip_valid = user.remember_token_ip is None or user.remember_token_ip == current_ip
                # Check User-Agent binding (partial match for browser updates)
                ua_valid = user.remember_token_user_agent is None or (
                    user.remember_token_user_agent[:50] == current_ua[:50] if current_ua else True
                )

                if not ip_valid or not ua_valid:
                    # Token hijacking attempt - invalidate token
                    user.remember_token = None
                    user.remember_token_expires = None
                    user.remember_token_ip = None
                    user.remember_token_user_agent = None
                    db.session.commit()
                    security_logger.warning("Remember token validation failed",
                        user_id=user.id,
                        stored_ip=user.remember_token_ip,
                        current_ip=current_ip,
                        ip_match=ip_valid,
                        ua_match=ua_valid)
                else:
                    # Auto login with remember token
                    session['user_id'] = user.id
                    session['name'] = user.name
                    session['employee_id'] = user.employee_id
                    session['roles'] = user.roles.split(',')
                    # ∆Øu ti√™n EMPLOYEE n·∫øu user c√≥ vai tr√≤ n√†y
                    user_roles = user.roles.split(',')
                    if 'EMPLOYEE' in user_roles:
                        session['current_role'] = 'EMPLOYEE'
                    else:
                        session['current_role'] = user_roles[0]
                    session['last_activity'] = datetime.now().isoformat()

                    log_audit_action(
                        user_id=user.id,
                        action='AUTO_LOGIN',
                        table_name='users',
                        record_id=user.id,
                        new_values={'auto_login_time': datetime.now().isoformat()}
                    )

                    flash('ƒêƒÉng nh·∫≠p t·ª± ƒë·ªông th√†nh c√¥ng!', 'success')
                    return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        employee_id_str = request.form.get('username', '').strip()
        password = request.form.get('password')
        remember = request.form.get('remember') == 'on'
        
        # Validate input
        if not employee_id_str or not password:
            flash('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß m√£ nh√¢n vi√™n v√† m·∫≠t kh·∫©u!', 'error')
            return render_template(
                'login.html',
                messages=get_flashed_messages(with_categories=False),
                remembered_username=employee_id_str or remembered_username,
                remember_checked=remember or bool(remembered_username)
            )
        # Validate employee id format (digits only)
        try:
            employee_id = validate_employee_id(employee_id_str)
        except ValidationError as ve:
            flash(ve.message or 'M√£ nh√¢n vi√™n kh√¥ng h·ª£p l·ªá!', 'error')
            return render_template(
                'login.html',
                messages=get_flashed_messages(with_categories=False),
                remembered_username=employee_id_str or remembered_username,
                remember_checked=remember or bool(remembered_username)
            )
        
        if not validate_input_sanitize(password):
            flash('M·∫≠t kh·∫©u kh√¥ng h·ª£p l·ªá!', 'error')
            return render_template(
                'login.html',
                messages=get_flashed_messages(with_categories=False),
                remembered_username=employee_id_str or remembered_username,
                remember_checked=remember or bool(remembered_username)
            )
        
        try:
            user = User.query.filter_by(employee_id=employee_id).first()
            
            if user and user.check_password(password):
                # Check security before login
                is_allowed, message = security_manager.check_login_attempts(employee_id)
                if not is_allowed:
                    flash(message, 'error')
                    return render_template('login.html', messages=get_flashed_messages(with_categories=False))
                
                session['user_id'] = user.id
                session['name'] = user.name
                session['employee_id'] = user.employee_id
                session['roles'] = user.roles.split(',')
                # ∆Øu ti√™n EMPLOYEE n·∫øu user c√≥ vai tr√≤ n√†y
                user_roles = user.roles.split(',')
                logger.info(f"User login successful", user_id=user.id, employee_id=employee_id, roles=user_roles)
                if 'EMPLOYEE' in user_roles:
                    session['current_role'] = 'EMPLOYEE'
                else:
                    session['current_role'] = user_roles[0]
                session['last_activity'] = datetime.now().isoformat()
                
                # Clear failed attempts on successful login
                security_manager.clear_failed_attempts(employee_id)
                
                response = redirect(url_for('dashboard'))
                
                log_audit_action(
                    user_id=user.id,
                    action='LOGIN',
                    table_name='users',
                    record_id=user.id,
                    new_values={'login_time': datetime.now().isoformat()}
                )
                
                if remember:
                    # Generate secure remember token with IP/UA binding (B4)
                    remember_token = secrets.token_urlsafe(32)
                    user.remember_token = remember_token
                    user.remember_token_expires = datetime.now() + timedelta(days=30)
                    user.remember_token_ip = request.remote_addr
                    user.remember_token_user_agent = request.headers.get('User-Agent', '')[:255]
                    db.session.commit()
                    response.set_cookie('remember_token', remember_token, max_age=30*24*60*60, httponly=True, secure=app.config.get('SESSION_COOKIE_SECURE', False))
                    response.set_cookie('remembered_username', employee_id_str, max_age=30*24*60*60)
                else:
                    # Clear remember token if not checked
                    if user.remember_token:
                        user.remember_token = None
                        user.remember_token_expires = None
                        user.remember_token_ip = None
                        user.remember_token_user_agent = None
                        db.session.commit()
                    response.delete_cookie('remember_token')
                    response.delete_cookie('remembered_username')
                
                flash('ƒêƒÉng nh·∫≠p th√†nh c√¥ng!', 'success')
                return response
            
            # Record failed login attempt
            security_manager.record_failed_login(employee_id)
            flash('M√£ nh√¢n vi√™n ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng!', 'error')
        except Exception as e:
            db.session.rollback()  # Rollback transaction on error
            security_logger.error("Login system error", 
                                error_type='LoginSystemError',
                                employee_id=employee_id,
                                error_details=str(e))
            flash('ƒê√£ x·∫£y ra l·ªói khi ƒëƒÉng nh·∫≠p!', 'error')
    
    form_username = request.form.get('username', '').strip() if request.method == 'POST' else ''
    username_prefill = form_username or remembered_username
    remember_prefill = (request.form.get('remember') == 'on') if request.method == 'POST' else bool(username_prefill)

    return render_template(
        'login.html',
        messages=get_flashed_messages(with_categories=False),
        remembered_username=username_prefill,
        remember_checked=remember_prefill
    )

@app.route('/logout')
def logout():
    forget_device = request.args.get('forget') == '1'
    # Log logout if user was logged in
    if 'user_id' in session:
        log_audit_action(
            user_id=session['user_id'],
            action='LOGOUT',
            table_name='users',
            record_id=session['user_id'],
            new_values={'logout_time': datetime.now().isoformat()}
        )
        
        user = db.session.get(User, session['user_id'])
        if user and forget_device:
            user.remember_token = None
            user.remember_token_expires = None
            user.remember_token_ip = None
            user.remember_token_user_agent = None
            db.session.commit()
    
    session.clear()
    redirect_url = url_for('login') if forget_device else url_for('login', logout=1)
    response = redirect(redirect_url)
    if forget_device:
        response.delete_cookie('remember_token')
        response.delete_cookie('remembered_username')
    return response

@app.route('/dashboard')
def dashboard():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # Process any pending DB updates from async email threads
    from utils.email_utils import process_db_updates
    process_db_updates()
    
    user = db.session.get(User, session['user_id'])
    if not user:
        session.clear()
        flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
        return redirect(url_for('login'))
    
    # Ki·ªÉm tra user c√≥ active kh√¥ng
    if not user.is_active:
        session.clear()
        flash('T√†i kho·∫£n ƒë√£ b·ªã kh√≥a!', 'error')
        return redirect(url_for('login'))
    
    # Ki·ªÉm tra session timeout
    if check_session_timeout():
        flash('Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n!', 'error')
        return redirect(url_for('login'))
    
    # C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông cu·ªëi
    update_session_activity()
    
    # X·ª≠ l√Ω tham s·ªë role t·ª´ query string
    role_param = request.args.get('role')
    if role_param and role_param in user.roles.split(','):
        session['current_role'] = role_param
        # Set current_role from query param
    
    # ƒê·∫£m b·∫£o session c√≥ ƒë·∫ßy ƒë·ªß th√¥ng tin
    if 'roles' not in session:
        session['roles'] = user.roles.split(',')
    
    # Ch·ªâ set current_role n·∫øu ch∆∞a c√≥ ho·∫∑c kh√¥ng h·ª£p l·ªá
    if 'current_role' not in session:
        # ∆Øu ti√™n EMPLOYEE n·∫øu user c√≥ vai tr√≤ n√†y (ch·ªâ khi ƒëƒÉng nh·∫≠p l·∫ßn ƒë·∫ßu)
        user_roles = user.roles.split(',')
        if 'EMPLOYEE' in user_roles:
            session['current_role'] = 'EMPLOYEE'
        else:
            session['current_role'] = user_roles[0]
        # print(f"DEBUG DASHBOARD: Set current_role to {session['current_role']} (no current_role in session)")
    elif session['current_role'] not in user.roles.split(','):
        # ∆Øu ti√™n EMPLOYEE n·∫øu user c√≥ vai tr√≤ n√†y (ch·ªâ khi current_role kh√¥ng h·ª£p l·ªá)
        user_roles = user.roles.split(',')
        if 'EMPLOYEE' in user_roles:
            session['current_role'] = 'EMPLOYEE'
        else:
            session['current_role'] = user_roles[0]
        # print(f"DEBUG DASHBOARD: Reset current_role to {session['current_role']} (not in user roles)")
    else:
        # print(f"DEBUG DASHBOARD: Keep current_role as {session['current_role']} (valid role)")

        if 'name' not in session:
            session['name'] = user.name
        if 'employee_id' not in session:
            session['employee_id'] = user.employee_id
    # Final current_role setup complete
    
    # Ki·ªÉm tra xem user ƒë√£ c√≥ ch·ªØ k√Ω c√° nh√¢n ch∆∞a
    has_signature = bool(user.personal_signature)

    # N·∫øu l√† ADMIN, ki·ªÉm tra c·∫£nh b√°o ng√†y l·ªÖ ƒë·ªÉ hi·ªÉn th·ªã tr√™n dashboard
    if 'ADMIN' in (user.roles or '').split(','):
        try:
            from datetime import date as _date_mod
            current_year = datetime.now().year
            # C√≥ √≠t nh·∫•t 1 ng√†y l·ªÖ trong nƒÉm hi·ªán t·∫°i ch∆∞a?
            year_holidays = Holiday.query.filter(
                Holiday.date >= _date_mod(current_year, 1, 1),
                Holiday.date <= _date_mod(current_year, 12, 31)
            ).count()
            if year_holidays == 0:
                flash('‚ö†Ô∏è Hi·ªán ch∆∞a c·∫•u h√¨nh ng√†y l·ªÖ n√†o cho nƒÉm hi·ªán t·∫°i. Vui l√≤ng v√†o "Qu·∫£n l√Ω ng√†y l·ªÖ" ƒë·ªÉ th√™m.', 'warning')
        except Exception:
            # Kh√¥ng ƒë·ªÉ l·ªói ph·ª• l√†m v·ª° dashboard
            pass
    
    # L·∫•y danh s√°ch ƒë∆°n ngh·ªâ ph√©p c·ªßa ng∆∞·ªùi d√πng ƒë·ªÉ hi·ªÉn th·ªã badge b·ªã t·ª´ ch·ªëi tr√™n sidebar
    try:
        leave_requests = (LeaveRequest.query
                          .filter(LeaveRequest.user_id == user.id)
                          .order_by(LeaveRequest.created_at.desc())
                          .limit(100)
                          .all())
    except Exception:
        leave_requests = []

    # L·∫•y tr·∫°ng th√°i c·∫£nh b√°o LICENSE g·∫ßn nh·∫•t ƒë·ªÉ render s·∫µn v√†o HTML,
    # gi√∫p banner hi·ªÉn th·ªã nhanh h∆°n m√† kh√¥ng ph·∫£i ch·ªù request fetch() ƒë·∫ßu ti√™n.
    try:
        with _license_warning_lock:
            license_warning_state = dict(_license_warning_state)
    except Exception:
        # N·∫øu c√≥ l·ªói, fallback v·ªÅ state r·ªóng (kh√¥ng hi·ªÉn th·ªã c·∫£nh b√°o)
        license_warning_state = {'active': False, 'payload': None, 'updated_at': None}

    return render_template(
        'dashboard.html',
        user=user,
        has_signature=has_signature,
        leave_requests=leave_requests,
        license_warning_state_json=json.dumps(license_warning_state, ensure_ascii=False)
    )

@app.route('/api/attendance', methods=['POST'])
@rate_limit(max_requests=500, window_seconds=60)
def record_attendance():
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    data = request.get_json()
    # print('DEBUG raw:', data)
    # print('DEBUG signature POST:', data.get('signature'))  # Th√™m log signature
    # Validate input (defensive): utils.validators raises ValidationError on bad/missing values
    try:
        # Required: date + holiday type
        date = validate_date(data.get('date'))
        holiday_type = validate_holiday_type(data.get('holiday_type'))

        # Optional-ish: allow empty for Vietnamese holiday (handled below)
        check_in_raw = data.get('check_in')
        check_out_raw = data.get('check_out')
        check_in = validate_time(check_in_raw) if check_in_raw else None
        check_out = validate_time(check_out_raw) if check_out_raw else None

        note = validate_note(data.get('note', ''))

        # Shift fields can be omitted for Vietnamese holiday (handled below)
        shift_code = data.get('shift_code')
        shift_start_raw = data.get('shift_start')
        shift_end_raw = data.get('shift_end')
        shift_start = validate_time(shift_start_raw) if shift_start_raw else None
        shift_end = validate_time(shift_end_raw) if shift_end_raw else None
    except ValidationError as e:
        return jsonify({'error': e.message}), 400
    
    # Khai b√°o holiday_type tr∆∞·ªõc khi s·ª≠ d·ª•ng
    is_holiday = bool(data.get('is_holiday', False))
    # holiday_type already validated above
    
    # Ch·ªâ ch·∫•p nh·∫≠n HH:MM
    # L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m: break_time = 0:00, ng∆∞·ª£c l·∫°i = 1:00
    if holiday_type == 'vietnamese_holiday' and (not check_in or not check_out):
        raw_break_time = data.get('break_time', '00:00') or '00:00'
    else:
        raw_break_time = data.get('break_time', '01:00') or '01:00'
    if not (isinstance(raw_break_time, str) and re.match(r'^\d{1,2}:[0-5]\d$', raw_break_time)):
        return jsonify({'error': 'Th·ªùi gian ngh·ªâ ph·∫£i ·ªü ƒë·ªãnh d·∫°ng HH:MM'}), 400
    comp_time_regular_raw = data.get('comp_time_regular', '00:00') or '00:00'
    comp_time_overtime_raw = data.get('comp_time_overtime', '00:00') or '00:00'
    comp_time_ot_before_22_raw = data.get('comp_time_ot_before_22', '00:00') or '00:00'
    comp_time_ot_after_22_raw = data.get('comp_time_ot_after_22', '00:00') or '00:00'
    overtime_comp_time_raw = data.get('overtime_comp_time', '00:00') or '00:00'
    for fld, val in [('comp_time_regular', comp_time_regular_raw), ('comp_time_overtime', comp_time_overtime_raw), ('comp_time_ot_before_22', comp_time_ot_before_22_raw), ('comp_time_ot_after_22', comp_time_ot_after_22_raw), ('overtime_comp_time', overtime_comp_time_raw)]:
        if not (isinstance(val, str) and re.match(r'^\d{1,2}:[0-5]\d$', val)):
            return jsonify({'error': f'{fld} ph·∫£i ·ªü ƒë·ªãnh d·∫°ng HH:MM'}), 400
    # Quy ƒë·ªïi HH:MM ‚Üí gi·ªù (float) t∆∞∆°ng th√≠ch tr∆∞·ªùng hi·ªán t·∫°i, nh∆∞ng m·ªçi t√≠nh to√°n d√πng seconds
    def hhmm_to_hours(hhmm):
        """Chuy·ªÉn ƒë·ªïi an to√†n HH:MM sang gi·ªù th·∫≠p ph√¢n"""
        if not hhmm or hhmm == "":
            return 0.0
        try:
            if isinstance(hhmm, (int, float)):
                return float(hhmm)
            if isinstance(hhmm, str) and ":" in hhmm:
                hh, mm = hhmm.split(':')
                return int(hh) + int(mm)/60
            else:
                # Th·ª≠ chuy·ªÉn ƒë·ªïi string s·ªë
                return float(hhmm)
        except (ValueError, TypeError) as e:
            # print(f"Warning: Failed to convert {repr(hhmm)} to hours: {e}")
            return 0.0
    break_time = hhmm_to_hours(raw_break_time)
    comp_time_regular = hhmm_to_hours(comp_time_regular_raw)
    comp_time_overtime = hhmm_to_hours(comp_time_overtime_raw)
    comp_time_ot_before_22 = hhmm_to_hours(comp_time_ot_before_22_raw)
    comp_time_ot_after_22 = hhmm_to_hours(comp_time_ot_after_22_raw)
    overtime_comp_time = hhmm_to_hours(overtime_comp_time_raw)
    # shift_code / shift_start / shift_end already parsed above
    # next_day_checkout is removed - using checkout_date field instead
    # print('DEBUG validated:', 'shift_code:', shift_code, 'shift_start:', shift_start, 'shift_end:', shift_end)
    if not holiday_type:
        return jsonify({'error': 'Vui l√≤ng ch·ªçn lo·∫°i ng√†y h·ª£p l·ªá'}), 400
    # Cho ph√©p kh√¥ng nh·∫≠p gi·ªù v√†o/ra cho l·ªÖ Vi·ªát Nam (nh√¢n vi√™n ƒë∆∞·ª£c 8h m·∫∑c ƒë·ªãnh)
    if holiday_type != 'vietnamese_holiday' and (not check_in or not check_out):
        return jsonify({'error': 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß gi·ªù v√†o v√† gi·ªù ra h·ª£p l·ªá'}), 400
    if break_time is None:
        return jsonify({'error': 'Th·ªùi gian ngh·ªâ kh√¥ng h·ª£p l·ªá!'}), 400
    if comp_time_regular is None:
        return jsonify({'error': 'Gi·ªù ƒë·ªëi ·ª©ng trong ca kh√¥ng h·ª£p l·ªá!'}), 400
    if comp_time_overtime is None:
        return jsonify({'error': 'Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca kh√¥ng h·ª£p l·ªá!'}), 400
    if comp_time_ot_before_22 is None or comp_time_ot_after_22 is None:
        return jsonify({'error': 'Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca theo m·ªëc (tr∆∞·ªõc/sau 22h) kh√¥ng h·ª£p l·ªá!'}), 400
    
    # Parse checkout_date early (supports multi-day / overnight). Do NOT use validate_date() here because checkout_date
    # can be tomorrow when date is today (overnight shift).
    checkout_date_str = data.get('checkout_date')
    checkout_date = None
    if checkout_date_str:
        try:
            if isinstance(checkout_date_str, str) and '/' in checkout_date_str:
                d, m, y = checkout_date_str.split('/')
                checkout_date = datetime.strptime(f"{y}-{m.zfill(2)}-{d.zfill(2)}", '%Y-%m-%d').date()
            else:
                checkout_date = datetime.strptime(str(checkout_date_str), '%Y-%m-%d').date()
        except Exception:
            return jsonify({'error': 'Ng√†y ra kh√¥ng h·ª£p l·ªá'}), 400
        if checkout_date < date:
            return jsonify({'error': 'Ng√†y ra kh√¥ng ƒë∆∞·ª£c nh·ªè h∆°n ng√†y v√†o'}), 400

    # Validation: ƒë·ªëi ·ª©ng/OT ·ªü backend
    is_valid, error_message = validate_overtime_comp_time(
        check_in, check_out, shift_start, shift_end, break_time, 
        comp_time_regular, comp_time_overtime, comp_time_ot_before_22, comp_time_ot_after_22,
        date, checkout_date, holiday_type, shift_code
    )
    if not is_valid:
        return jsonify({'error': error_message}), 400
    
    # L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m: kh√¥ng c·∫ßn shift_code, shift_start, shift_end
    if holiday_type != 'vietnamese_holiday' and (not shift_code or not shift_start or not shift_end):
        return jsonify({'error': 'Vui l√≤ng ch·ªçn ca l√†m vi·ªác h·ª£p l·ªá!'}), 400
    # T·ªëi ∆∞u: L·∫•y user v√† existing_attendance trong 1 query
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    required_hours = get_required_daily_hours(user, date, holiday_type, shift_code)
    
    # Ki·ªÉm tra existing attendance v·ªõi timeout ƒë·ªÉ tr√°nh deadlock
    try:
        existing_attendance = Attendance.query.filter_by(user_id=user.id, date=date).first()
    except Exception as e:
        db.session.rollback()  # Rollback transaction on error
        # print(f"Database query error: {e}")
        return jsonify({'error': 'L·ªói truy v·∫•n database, vui l√≤ng th·ª≠ l·∫°i'}), 500
    if existing_attendance:
        if existing_attendance.status != 'rejected':
            return jsonify({'error': 'B·∫°n ƒë√£ ch·∫•m c√¥ng cho ng√†y n√†y r·ªìi, kh√¥ng th·ªÉ ch·∫•m c√¥ng 2 l·∫ßn trong 1 ng√†y.'}), 400
        else:
            db.session.delete(existing_attendance)
            db.session.commit()
    if date > datetime.now().date():
        return jsonify({'error': 'Kh√¥ng th·ªÉ ch·∫•m c√¥ng cho ng√†y trong t∆∞∆°ng lai!'}), 400
    # T·ª± ƒë·ªông l·∫•y ch·ªØ k√Ω t·ª´ database thay v√¨ y√™u c·∫ßu user k√Ω
    signature = data.get('signature', '')
    
    # L·∫•y ch·ªØ k√Ω t·ª´ database theo th·ª© t·ª± ∆∞u ti√™n (v·ªõi timeout)
    try:
        auto_signature = signature_manager.get_signature_from_database(user.id, 'EMPLOYEE')
    except Exception as e:
        # print(f"Signature query error: {e}")
        auto_signature = None  # Fallback n·∫øu c√≥ l·ªói
    signature_info = {
        'has_signature': False,
        'signature_type': 'none',
        'message': ''
    }
    
    if auto_signature:
        signature = auto_signature
        signature_info = {
            'has_signature': True,
            'signature_type': 'database',
            'message': f'ƒê√£ s·ª≠ d·ª•ng ch·ªØ k√Ω c√≥ s·∫µn t·ª´ database'
        }
        # print(f"‚úÖ AUTO SIGNATURE: User {user.name} using signature from database")
    else:
        signature_info = {
            'has_signature': False,
            'signature_type': 'none',
            'message': 'Kh√¥ng c√≥ ch·ªØ k√Ω trong database, s·∫Ω s·ª≠ d·ª•ng ch·ªØ k√Ω m·∫∑c ƒë·ªãnh'
        }
        # print(f"‚ö†Ô∏è NO AUTO SIGNATURE: User {user.name} has no signature in database")
    
    # X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho l·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m
    if holiday_type == 'vietnamese_holiday' and (not check_in or not check_out):
        # print(f"DEBUG: Creating Vietnamese holiday attendance without check-in/out")
        # L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m: set gi√° tr·ªã m·∫∑c ƒë·ªãnh
        attendance = Attendance(
            user_id=user.id,
            date=date,
            break_time=0.0,  # Kh√¥ng c√≥ th·ªùi gian ngh·ªâ khi kh√¥ng ƒëi l√†m
            comp_time_regular_minutes=0,
            comp_time_overtime_minutes=0,
            comp_time_ot_before_22_minutes=0,
            comp_time_ot_after_22_minutes=0,
            overtime_comp_time_minutes=0,
            is_holiday=is_holiday,
            holiday_type=holiday_type,
            status='pending',
            overtime_before_22="0:00",
            overtime_after_22="0:00",
            shift_code='5',  # Ca 5 (Ca t·ª± do) cho l·ªÖ Vi·ªát Nam
            signature=signature,
            check_in=None,  # Kh√¥ng c√≥ gi·ªù v√†o
            check_out=None,  # Kh√¥ng c√≥ gi·ªù ra
            shift_start=None,  # Kh√¥ng c√≥ gi·ªù b·∫Øt ƒë·∫ßu ca
            shift_end=None,  # Kh√¥ng c√≥ gi·ªù k·∫øt th√∫c ca
            total_work_hours=required_hours,  # T·ª± ƒë·ªông t√≠nh ƒë·ªß c√¥ng theo ch√≠nh s√°ch (m·∫∑c ƒë·ªãnh 8h, ∆∞u ti√™n 7h n·∫øu √°p d·ª•ng)
            required_hours=required_hours
        )
    else:
        # Logic b√¨nh th∆∞·ªùng cho c√°c tr∆∞·ªùng h·ª£p kh√°c
        # Chuy·ªÉn ƒë·ªïi gi·ªù sang ph√∫t cho c√°c c·ªôt minutes m·ªõi
        def hours_to_minutes(hours):
            return int(round(hours * 60)) if hours else 0
        
        attendance = Attendance(
            user_id=user.id,
            date=date,
            break_time=break_time,
            comp_time_regular_minutes=hours_to_minutes(comp_time_regular),
            comp_time_overtime_minutes=hours_to_minutes(comp_time_overtime),
            comp_time_ot_before_22_minutes=hours_to_minutes(comp_time_ot_before_22),
            comp_time_ot_after_22_minutes=hours_to_minutes(comp_time_ot_after_22),
            overtime_comp_time_minutes=hours_to_minutes(overtime_comp_time),
            is_holiday=is_holiday,
            holiday_type=holiday_type,
            status='pending',
            overtime_before_22="0:00",
            overtime_after_22="0:00",
            shift_code=shift_code,
            signature=signature,
            required_hours=required_hours
        )
    
    # N·∫øu user c√≥ vai tr√≤ cao h∆°n, l∆∞u ch·ªØ k√Ω v√†o field t∆∞∆°ng ·ª©ng
    if 'TEAM_LEADER' in user.roles.split(','):
        attendance.team_leader_signature = signature
    if 'MANAGER' in user.roles.split(','):
        attendance.manager_signature = signature
    db.session.add(attendance)
    
    # Ch·ªâ set check_in/check_out khi c√≥ gi·ªù v√†o/ra (kh√¥ng √°p d·ª•ng cho l·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m)
    if check_in and check_out:
        attendance.check_in = datetime.combine(date, check_in)
        
        # X·ª≠ l√Ω gi·ªù ra - s·ª≠ d·ª•ng checkout_date ƒë√£ parse ·ªü tr√™n (ho·∫∑c suy lu·∫≠n qua ƒë√™m)
        if not checkout_date:
            if check_out.hour < check_in.hour or (check_out.hour == check_in.hour and check_out.minute <= check_in.minute):
                checkout_date = date + timedelta(days=1)
            else:
                checkout_date = date
        
        # K·∫øt h·ª£p ng√†y ra + gi·ªù ra ƒë·ªÉ t·∫°o datetime ƒë·∫ßy ƒë·ªß
        attendance.check_out = datetime.combine(checkout_date, check_out)
    
    attendance.shift_start = shift_start
    attendance.shift_end = shift_end
    
    attendance.note = note
    # G√°n user object ƒë·ªÉ update_work_hours() c√≥ th·ªÉ check ch√≠nh s√°ch m·∫π <12 th√°ng
    attendance.user = user
    # Ch·ªâ g·ªçi update_work_hours() khi c√≥ gi·ªù v√†o/ra (tr∆∞·ªùng h·ª£p l·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m ƒë√£ set total_work_hours=8.0)
    if check_in and check_out:
        attendance.update_work_hours()
    try:
        logger.info("Attempting to commit attendance record", 
                   user_id=user.id, date=date.isoformat(), holiday_type=holiday_type)
        
        db.session.commit()
        
        logger.info("Successfully committed attendance record", 
                   attendance_id=attendance.id, user_id=user.id)
        
        audit_logger.audit_action(
            action='CREATE_ATTENDANCE',
            table_name='attendances',
            record_id=attendance.id,
            new_values={
                'date': attendance.date.isoformat(),
                'check_in': attendance.check_in.isoformat() if attendance.check_in else None,
                'check_out': attendance.check_out.isoformat() if attendance.check_out else None,
                'status': attendance.status
            }
        )
        
        return jsonify({
            'message': 'Ch·∫•m c√¥ng th√†nh c√¥ng',
            'work_hours': attendance.total_work_hours,
            'overtime_before_22': attendance.overtime_before_22,
            'overtime_after_22': attendance.overtime_after_22,
            'required_hours': required_hours,
            'signature_info': signature_info
        })
        
    except SQLAlchemyError as e:
        database_logger.error("Database error during attendance commit", 
                             error_type='SQLAlchemyError', 
                             user_id=user.id, 
                             error_details=str(e))
        db.session.rollback()
        return jsonify({'error': 'L·ªói c∆° s·ªü d·ªØ li·ªáu khi l∆∞u ch·∫•m c√¥ng'}), 500
        
    except ValidationError as e:
        logger.warning("Validation error during attendance creation", 
                      error_type='ValidationError',
                      user_id=user.id,
                      validation_error=e.message)
        return jsonify({'error': e.message}), 400
        
    except Exception as e:
        logger.critical("Unexpected error during attendance creation", 
                       error_type='UnexpectedError',
                       user_id=user.id,
                       error_details=str(e))
        db.session.rollback()
        return jsonify({'error': 'L·ªói h·ªá th·ªëng kh√¥ng x√°c ƒë·ªãnh'}), 500

@app.route('/api/log-error', methods=['POST'])
def log_frontend_error():
    """Endpoint ƒë·ªÉ log l·ªói t·ª´ frontend"""
    try:
        data = request.get_json()
        api_logger.error(
            "Frontend error reported",
            error_type='FrontendError',
            frontend_error_type=data.get('type'),
            frontend_message=data.get('message'),
            url=data.get('url'),
            user_agent=data.get('userAgent'),
            timestamp=data.get('timestamp')
        )
        return jsonify({'status': 'logged'}), 200
    except Exception as e:
        logger.error("Failed to log frontend error", error_details=str(e))
        return jsonify({'status': 'error'}), 500

@app.route('/api/attendance/history')
def get_attendance_history():
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    try:
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
        current_role = session.get('current_role', user.roles.split(',')[0])
        if request.args.get('all') == '1':
            if current_role != 'ADMIN':
                return jsonify({'error': 'Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ th·ªÉ xem l·ªãch s·ª≠ ch·∫•m c√¥ng to√†n b·ªô'}), 403
            if not has_role(session['user_id'], 'ADMIN'):
                return jsonify({'error': 'B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p d·ªØ li·ªáu to√†n b·ªô'}), 403
            page = validate_int(request.args.get('page', 1), min_val=1)
            per_page = validate_int(request.args.get('per_page', 10), min_val=1, max_val=100)
            search = validate_input_sanitize(request.args.get('search', '').strip())
            department = validate_input_sanitize(request.args.get('department', '').strip())
            # ∆Øu ti√™n l·ªçc theo kho·∫£ng th√°ng/nƒÉm n·∫øu c√≥
            month_from = request.args.get('month_from')
            month_to = request.args.get('month_to')
            year_from = request.args.get('year_from')
            year_to = request.args.get('year_to')
            
            date_from = None
            date_to = None
            
            # X·ª≠ l√Ω l·ªçc theo kho·∫£ng th√°ng/nƒÉm (∆∞u ti√™n cao nh·∫•t)
            # N·∫øu c√≥ month_from th√¨ x·ª≠ l√Ω (n·∫øu kh√¥ng c√≥ year_from th√¨ d√πng nƒÉm hi·ªán t·∫°i)
            if month_from:
                try:
                    import calendar
                    from datetime import date as _date, datetime
                    month_from_val = int(month_from)
                    # N·∫øu kh√¥ng c√≥ year_from, d√πng nƒÉm hi·ªán t·∫°i
                    year_from_val = int(year_from) if year_from else datetime.now().year
                    
                    # N·∫øu c√≥ month_to v√† year_to th√¨ d√πng, n·∫øu kh√¥ng th√¨ d√πng month_from v√† year_from
                    if month_to:
                        month_to_val = int(month_to)
                        year_to_val = int(year_to) if year_to else year_from_val
                    else:
                        # N·∫øu ch·ªâ c√≥ month_from, d√πng n√≥ cho c·∫£ ƒëi·ªÉm k·∫øt th√∫c
                        month_to_val = month_from_val
                        year_to_val = year_from_val
                    
                    # Validate gi√° tr·ªã
                    if 1 <= month_from_val <= 12 and 1 <= month_to_val <= 12 and 2000 <= year_from_val <= 2100 and 2000 <= year_to_val <= 2100:
                        date_from = _date(year_from_val, month_from_val, 1)
                        last_day = calendar.monthrange(year_to_val, month_to_val)[1]
                        date_to = _date(year_to_val, month_to_val, last_day)
                        # Debug log ƒë·ªÉ ki·ªÉm tra
                        if app.debug:
                            print(f"[FILTER DEBUG] Month range filter applied: {date_from} to {date_to}")
                            print(f"[FILTER DEBUG] Params: month_from={month_from_val}, year_from={year_from_val}, month_to={month_to_val}, year_to={year_to_val}")
                    else:
                        if app.debug:
                            print(f"[FILTER DEBUG] Invalid month/year values: month_from={month_from_val}, year_from={year_from_val}, month_to={month_to_val}, year_to={year_to_val}")
                except ValueError as e:
                    if app.debug:
                        print(f"[FILTER DEBUG] ValueError parsing month filter: {e}")
                    # Kh√¥ng set date_from/date_to n·∫øu c√≥ l·ªói parse
                    pass
                except Exception as e:
                    if app.debug:
                        print(f"[FILTER DEBUG] Exception parsing month filter: {e}")
                    # Kh√¥ng set date_from/date_to n·∫øu c√≥ l·ªói parse
                    pass
            
            # N·∫øu ch∆∞a c√≥ date_from/date_to t·ª´ filter th√°ng, ki·ªÉm tra filter ng√†y tr·ª±c ti·∫øp
            if not date_from:
                date_from_str = request.args.get('date_from', '').strip()
                if date_from_str:
                    date_from = validate_date(date_from_str)
            if not date_to:
                date_to_str = request.args.get('date_to', '').strip()
                if date_to_str:
                    date_to = validate_date(date_to_str)
            
            # H·ªó tr·ª£ l·ªçc theo th√°ng/nƒÉm ƒë∆°n (d√πng cho estimate bulk export) - ch·ªâ khi ch∆∞a c√≥ filter n√†o
            if not date_from:
                month_param = request.args.get('month')
                year_param = request.args.get('year')
                if month_param and year_param:
                    try:
                        month_val = int(month_param)
                        year_val = int(year_param)
                        from datetime import date as _date
                        if 1 <= month_val <= 12 and 2000 <= year_val <= 2100:
                            date_from = _date(year_val, month_val, 1)
                            import calendar
                            last_day = calendar.monthrange(year_val, month_val)[1]
                            date_to = _date(year_val, month_val, last_day)
                    except Exception:
                        pass
            
            # Debug log ƒë·ªÉ ki·ªÉm tra gi√° tr·ªã cu·ªëi c√πng
            if app.debug:
                print(f"[FILTER DEBUG] Final date_from: {date_from}, date_to: {date_to}")
                print(f"[FILTER DEBUG] Request params: month_from={month_from}, month_to={month_to}, year_from={year_from}, year_to={year_to}")
                print(f"[FILTER DEBUG] date_from_str: {request.args.get('date_from')}, date_to_str: {request.args.get('date_to')}")
            
            if page is None or per_page is None:
                return jsonify({'error': 'Tham s·ªë ph√¢n trang kh√¥ng h·ª£p l·ªá'}), 400
                
            # Use optimized query for fastest performance
            from utils.query_optimizer import optimize_attendance_history_query
            attendances, total = optimize_attendance_history_query(
                search=search, department=department, date_from=date_from, date_to=date_to,
                user_id=user.id, page=page, per_page=per_page, is_admin=True
            )
            
            # Debug log k·∫øt qu·∫£ query
            if app.debug:
                print(f"[FILTER DEBUG] Query result: total={total}, records={len(attendances)}")
                if attendances:
                    print(f"[FILTER DEBUG] First record date: {attendances[0].date}, Last record date: {attendances[-1].date}")
            # Disable caching for admin history data
            history = []
            for att in attendances:
                att_dict = att.to_dict()
                att_dict['user_name'] = att.user.name if att.user else '-'
                att_dict['department'] = att.user.department if att.user else '-'
                att_dict['approver_name'] = att.approver.name if att.approver else '-'
                
                # Debug logging ch·ªâ khi c·∫ßn thi·∫øt
                if app.debug and att.id <= 5:  # Ch·ªâ log 5 records ƒë·∫ßu ti√™n trong debug mode
                    pass

                history.append(att_dict)

            return jsonify({
                'total': total,
                'page': page,
                'per_page': per_page,
                'data': history
            })
        else:
            # L·∫•y tham s·ªë l·ªçc theo th√°ng
            month = validate_int(request.args.get('month', '').strip()) if request.args.get('month') else None
            year = validate_int(request.args.get('year', '').strip()) if request.args.get('year') else None
            
            # N·∫øu kh√¥ng c√≥ tham s·ªë th√°ng/nƒÉm, l·∫•y th√°ng/nƒÉm hi·ªán t·∫°i
            if not month or not year:
                from datetime import datetime
                now = datetime.now()
                month = month or now.month
                year = year or now.year
            
            # T·∫°o date_from v√† date_to cho th√°ng ƒë∆∞·ª£c ch·ªçn
            from datetime import datetime
            date_from = datetime(year, month, 1).date()
            if month == 12:
                date_to = datetime(year + 1, 1, 1).date()
            else:
                date_to = datetime(year, month + 1, 1).date()
            
            # Use optimized query for user's own records with month filter
            from utils.query_optimizer import optimize_attendance_history_query
            attendances, total = optimize_attendance_history_query(
                user_id=user.id, page=1, per_page=1000, is_admin=False,
                date_from=date_from, date_to=date_to
            )
            history = []
            for att in attendances:
                history.append(att.to_dict())
            resp = jsonify(history)
            resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
            resp.headers['Pragma'] = 'no-cache'
            resp.headers['Expires'] = '0'
            return resp
    except Exception as e:
        # print(f"Error in get_attendance_history: {str(e)}")
        return jsonify({'error': 'ƒê√£ x·∫£y ra l·ªói khi l·∫•y l·ªãch s·ª≠ ch·∫•m c√¥ng'}), 500


@app.route('/api/attendance/bulk-recreate', methods=['POST'])
@rate_limit(max_requests=10, window_seconds=60)
def bulk_recreate_attendance():
    """
    T·∫°o l·∫°i h√†ng lo·∫°t b·∫£n ghi ch·∫•m c√¥ng t·ª´ c√°c b·∫£n ghi ƒë√£ ph√™ duy·ªát
    Ch·ªâ ADMIN m·ªõi c√≥ quy·ªÅn s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y
    
    H·ªó tr·ª£:
    - T·∫°o l·∫°i theo kho·∫£ng ng√†y (date_from, date_to)
    - T·∫°o l·∫°i theo kho·∫£ng th√°ng (month_from, year_from, month_to, year_to)
    - T·∫°o l·∫°i theo ng√†y c·ª• th·ªÉ (specific_date)
    """
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    
    # Ch·ªâ ADMIN m·ªõi c√≥ quy·ªÅn
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    current_role = session.get('current_role', user.roles.split(',')[0])
    if current_role != 'ADMIN':
        return jsonify({'error': 'Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ quy·ªÅn t·∫°o l·∫°i b·∫£n ghi ch·∫•m c√¥ng'}), 403
    
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Thi·∫øu d·ªØ li·ªáu y√™u c·∫ßu'}), 400
        
        # X√°c ƒë·ªãnh kho·∫£ng th·ªùi gian c·∫ßn t·∫°o l·∫°i
        date_from = None
        date_to = None
        
        # Tr∆∞·ªùng h·ª£p 1: T·∫°o l·∫°i theo kho·∫£ng ng√†y
        if data.get('date_from') and data.get('date_to'):
            try:
                date_from = validate_date(data.get('date_from'))
                date_to = validate_date(data.get('date_to'))
            except ValidationError as e:
                return jsonify({'error': f'Ng√†y kh√¥ng h·ª£p l·ªá: {str(e)}'}), 400
            
            if date_from > date_to:
                return jsonify({'error': 'Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i nh·ªè h∆°n ho·∫∑c b·∫±ng ng√†y k·∫øt th√∫c'}), 400
        
        # Tr∆∞·ªùng h·ª£p 2: T·∫°o l·∫°i theo kho·∫£ng th√°ng
        elif data.get('month_from') and data.get('year_from') and data.get('month_to') and data.get('year_to'):
            month_from = validate_int(data.get('month_from'), min_val=1, max_val=12)
            year_from = validate_int(data.get('year_from'), min_val=2000, max_val=2100)
            month_to = validate_int(data.get('month_to'), min_val=1, max_val=12)
            year_to = validate_int(data.get('year_to'), min_val=2000, max_val=2100)
            
            if not all([month_from, year_from, month_to, year_to]):
                return jsonify({'error': 'Th√°ng/nƒÉm kh√¥ng h·ª£p l·ªá'}), 400
            
            # T√≠nh ng√†y ƒë·∫ßu th√°ng v√† cu·ªëi th√°ng
            from datetime import datetime
            date_from = datetime(year_from, month_from, 1).date()
            if month_to == 12:
                date_to = datetime(year_to + 1, 1, 1).date() - timedelta(days=1)
            else:
                date_to = datetime(year_to, month_to + 1, 1).date() - timedelta(days=1)
        
        # Tr∆∞·ªùng h·ª£p 3: T·∫°o l·∫°i theo ng√†y c·ª• th·ªÉ
        elif data.get('specific_date'):
            try:
                specific_date = validate_date(data.get('specific_date'))
            except ValidationError as e:
                return jsonify({'error': f'Ng√†y kh√¥ng h·ª£p l·ªá: {str(e)}'}), 400
            date_from = specific_date
            date_to = specific_date
        
        else:
            return jsonify({
                'error': 'Vui l√≤ng cung c·∫•p: (date_from, date_to) ho·∫∑c (month_from, year_from, month_to, year_to) ho·∫∑c (specific_date)'
            }), 400
        
        # L·∫•y T·∫§T C·∫¢ b·∫£n ghi trong kho·∫£ng th·ªùi gian (kh√¥ng ch·ªâ approved)
        # ƒë·ªÉ t·∫°o l·∫°i t·∫•t c·∫£ v·ªÅ tr·∫°ng th√°i pending (c·∫•p nh√¢n vi√™n)
        all_attendances = Attendance.query.filter(
            Attendance.date >= date_from,
            Attendance.date <= date_to
        ).order_by(Attendance.date, Attendance.user_id, Attendance.id).all()
        
        print(f"üîç [BULK_RECREATE] T√¨m th·∫•y {len(all_attendances)} b·∫£n ghi t·ª´ {date_from.strftime('%d/%m/%Y')} ƒë·∫øn {date_to.strftime('%d/%m/%Y')}")
        
        if not all_attendances:
            return jsonify({
                'success': True,
                'message': f'Kh√¥ng t√¨m th·∫•y b·∫£n ghi n√†o trong kho·∫£ng th·ªùi gian t·ª´ {date_from.strftime("%d/%m/%Y")} ƒë·∫øn {date_to.strftime("%d/%m/%Y")}',
                'recreated_count': 0,
                'skipped_count': 0
            })
        
        # Nh√≥m c√°c b·∫£n ghi theo user_id v√† date, ch·ªçn b·∫£n ghi t·ªët nh·∫•t cho m·ªói nh√≥m
        # ∆Øu ti√™n: approved > pending_admin > pending_manager > pending > rejected
        from collections import defaultdict
        status_priority = {
            'approved': 1,
            'pending_admin': 2,
            'pending_manager': 3,
            'pending': 4,
            'rejected': 5
        }
        
        best_attendances = {}  # Key: (user_id, date), Value: best attendance record
        
        for attendance in all_attendances:
            key = (attendance.user_id, attendance.date)
            if key not in best_attendances:
                best_attendances[key] = attendance
            else:
                current_priority = status_priority.get(best_attendances[key].status, 99)
                new_priority = status_priority.get(attendance.status, 99)
                # ∆Øu ti√™n b·∫£n ghi c√≥ priority th·∫•p h∆°n (approved = 1 l√† t·ªët nh·∫•t)
                if new_priority < current_priority:
                    best_attendances[key] = attendance
                # N·∫øu c√πng priority, ∆∞u ti√™n b·∫£n ghi m·ªõi h∆°n (id l·ªõn h∆°n)
                elif new_priority == current_priority and attendance.id > best_attendances[key].id:
                    best_attendances[key] = attendance
        
        source_attendances = list(best_attendances.values())
        print(f"üìä [BULK_RECREATE] Sau khi nh√≥m, c√≥ {len(source_attendances)} b·∫£n ghi duy nh·∫•t (user/date) ƒë·ªÉ t·∫°o l·∫°i")
        
        recreated_count = 0
        skipped_count = 0
        errors = []
        
        # T·∫°o l·∫°i t·ª´ng b·∫£n ghi
        for source_attendance in source_attendances:
            try:
                user_name = source_attendance.user.name if source_attendance.user else 'Unknown'
                date_str = source_attendance.date.strftime('%d/%m/%Y')
                
                # L∆∞u th√¥ng tin t·ª´ b·∫£n ghi ngu·ªìn tr∆∞·ªõc khi x√≥a (ƒë·ªÉ tr√°nh l·ªói khi truy c·∫≠p sau khi x√≥a)
                source_data = {
                    'user_id': source_attendance.user_id,
                    'date': source_attendance.date,
                    'check_in': source_attendance.check_in,
                    'check_out': source_attendance.check_out,
                    'break_time': source_attendance.break_time,
                    'comp_time_regular_minutes': source_attendance.comp_time_regular_minutes,
                    'comp_time_overtime_minutes': source_attendance.comp_time_overtime_minutes,
                    'comp_time_ot_before_22_minutes': source_attendance.comp_time_ot_before_22_minutes,
                    'comp_time_ot_after_22_minutes': source_attendance.comp_time_ot_after_22_minutes,
                    'overtime_comp_time_minutes': source_attendance.overtime_comp_time_minutes,
                    'is_holiday': source_attendance.is_holiday,
                    'holiday_type': source_attendance.holiday_type,
                    'note': source_attendance.note,
                    'total_work_hours': source_attendance.total_work_hours,
                    'regular_work_hours': source_attendance.regular_work_hours,
                    'overtime_before_22': source_attendance.overtime_before_22,
                    'overtime_after_22': source_attendance.overtime_after_22,
                    'shift_code': source_attendance.shift_code,
                    'shift_start': source_attendance.shift_start,
                    'shift_end': source_attendance.shift_end,
                    'required_hours': source_attendance.required_hours,
                    'signature': source_attendance.signature
                }
                
                # X√≥a T·∫§T C·∫¢ b·∫£n ghi hi·ªán c√≥ cho user/ng√†y n√†y (bao g·ªìm c·∫£ b·∫£n ghi ngu·ªìn)
                existing_attendances = Attendance.query.filter_by(
                    user_id=source_data['user_id'],
                    date=source_data['date']
                ).all()
                
                deleted_count = len(existing_attendances)
                
                # X√≥a t·∫•t c·∫£ b·∫£n ghi hi·ªán c√≥
                for existing_attendance in existing_attendances:
                    db.session.delete(existing_attendance)
                
                if existing_attendances:
                    db.session.flush()
                
                # T·∫°o b·∫£n ghi m·ªõi t·ª´ b·∫£n ghi ƒë√£ ph√™ duy·ªát
                new_attendance = Attendance(
                    user_id=source_data['user_id'],
                    date=source_data['date'],
                    check_in=source_data['check_in'],
                    check_out=source_data['check_out'],
                    break_time=source_data['break_time'],
                    comp_time_regular_minutes=source_data['comp_time_regular_minutes'],
                    comp_time_overtime_minutes=source_data['comp_time_overtime_minutes'],
                    comp_time_ot_before_22_minutes=source_data['comp_time_ot_before_22_minutes'],
                    comp_time_ot_after_22_minutes=source_data['comp_time_ot_after_22_minutes'],
                    overtime_comp_time_minutes=source_data['overtime_comp_time_minutes'],
                    is_holiday=source_data['is_holiday'],
                    holiday_type=source_data['holiday_type'],
                    status='pending',  # Reset v·ªÅ pending ƒë·ªÉ ph√™ duy·ªát l·∫°i
                    note=source_data['note'],  # Gi·ªØ nguy√™n ghi ch√∫
                    total_work_hours=source_data['total_work_hours'],
                    regular_work_hours=source_data['regular_work_hours'],
                    overtime_before_22=source_data['overtime_before_22'],
                    overtime_after_22=source_data['overtime_after_22'],
                    shift_code=source_data['shift_code'],
                    shift_start=source_data['shift_start'],
                    shift_end=source_data['shift_end'],
                    required_hours=source_data['required_hours'],
                    signature=source_data['signature'],  # Gi·ªØ ch·ªØ k√Ω c·ªßa employee
                    # Reset c√°c th√¥ng tin ph√™ duy·ªát
                    approved=False,
                    approved_by=None,
                    approved_at=None,
                    team_leader_signature=None,
                    manager_signature=None,
                    team_leader_signer_id=None,
                    manager_signer_id=None
                )
                
                db.session.add(new_attendance)
                recreated_count += 1
                
                # Log ƒë·ªÉ debug
                print(f"‚úÖ [BULK_RECREATE] ƒê√£ t·∫°o l·∫°i b·∫£n ghi cho {user_name} ng√†y {date_str} (ƒë√£ x√≥a {deleted_count} b·∫£n ghi c≈©)")

            except Exception as e:
                db.session.rollback()  # Rollback transaction on error
                import traceback
                error_msg = f"L·ªói khi t·∫°o l·∫°i b·∫£n ghi cho {user_name} ng√†y {date_str}: {str(e)}"
                error_trace = traceback.format_exc()
                print(f"‚ùå [BULK_RECREATE_ERROR] {error_msg}")
                print(f"   Traceback: {error_trace}")
                errors.append(error_msg)
                continue
        
        # Commit t·∫•t c·∫£ thay ƒë·ªïi
        db.session.commit()
        
        # Log audit
        log_audit_action(
            user_id=user.id,
            action='BULK_RECREATE_ATTENDANCE',
            table_name='attendances',
            record_id=None,
            old_values={'date_from': date_from.isoformat(), 'date_to': date_to.isoformat()},
            new_values={'recreated_count': recreated_count, 'skipped_count': skipped_count}
        )
        
        message = f'ƒê√£ t·∫°o l·∫°i {recreated_count} b·∫£n ghi ch·∫•m c√¥ng th√†nh c√¥ng'
        if skipped_count > 0:
            message += f'. B·ªè qua {skipped_count} b·∫£n ghi (ƒë√£ t·ªìn t·∫°i)'
        if errors:
            message += f'. C√≥ {len(errors)} l·ªói x·∫£y ra'
        
        return jsonify({
            'success': True,
            'message': message,
            'recreated_count': recreated_count,
            'skipped_count': skipped_count,
            'error_count': len(errors),
            'errors': errors[:10] if errors else []  # Ch·ªâ tr·∫£ v·ªÅ 10 l·ªói ƒë·∫ßu ti√™n
        })
        
    except Exception as e:
        db.session.rollback()
        import traceback
        print(f"‚ùå [BULK_RECREATE_ERROR] L·ªói khi t·∫°o l·∫°i h√†ng lo·∫°t b·∫£n ghi ch·∫•m c√¥ng: {e}")
        print(traceback.format_exc())
        return jsonify({'error': f'ƒê√£ x·∫£y ra l·ªói khi t·∫°o l·∫°i h√†ng lo·∫°t b·∫£n ghi ch·∫•m c√¥ng: {str(e)}'}), 500


@app.route('/api/attendance/<int:attendance_id>/duplicate', methods=['POST'])
@rate_limit(max_requests=100, window_seconds=60)
def duplicate_attendance(attendance_id):
    """
    T·∫°o l·∫°i b·∫£n ghi ch·∫•m c√¥ng t·ª´ b·∫£n ghi ƒë√£ ph√™ duy·ªát
    Ch·ªâ ADMIN m·ªõi c√≥ quy·ªÅn s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y
    """
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    
    # Ch·ªâ ADMIN m·ªõi c√≥ quy·ªÅn
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    current_role = session.get('current_role', user.roles.split(',')[0])
    if current_role != 'ADMIN':
        return jsonify({'error': 'Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ quy·ªÅn t·∫°o l·∫°i b·∫£n ghi ch·∫•m c√¥ng'}), 403
    
    try:
        # L·∫•y b·∫£n ghi ƒë√£ ph√™ duy·ªát
        source_attendance = db.session.get(Attendance, attendance_id)
        if not source_attendance:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y b·∫£n ghi ch·∫•m c√¥ng'}), 404
        
        # Ki·ªÉm tra b·∫£n ghi ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát ch∆∞a
        if source_attendance.status != 'approved':
            return jsonify({
                'error': 'Ch·ªâ c√≥ th·ªÉ t·∫°o l·∫°i t·ª´ b·∫£n ghi ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát',
                'current_status': source_attendance.status
            }), 400
        
        # Ki·ªÉm tra xem ƒë√£ c√≥ b·∫£n ghi cho ng√†y n√†y ch∆∞a
        existing_attendance = Attendance.query.filter_by(
            user_id=source_attendance.user_id,
            date=source_attendance.date
        ).first()
        
        if existing_attendance and existing_attendance.status != 'rejected':
            return jsonify({
                'error': f'ƒê√£ t·ªìn t·∫°i b·∫£n ghi ch·∫•m c√¥ng cho ng√†y {source_attendance.date.strftime("%d/%m/%Y")}',
                'existing_id': existing_attendance.id,
                'existing_status': existing_attendance.status
            }), 400
        
        # N·∫øu c√≥ b·∫£n ghi rejected, x√≥a n√≥ tr∆∞·ªõc
        if existing_attendance and existing_attendance.status == 'rejected':
            db.session.delete(existing_attendance)
            db.session.flush()
        
        # T·∫°o b·∫£n ghi m·ªõi t·ª´ b·∫£n ghi ƒë√£ ph√™ duy·ªát
        new_attendance = Attendance(
            user_id=source_attendance.user_id,
            date=source_attendance.date,
            check_in=source_attendance.check_in,
            check_out=source_attendance.check_out,
            break_time=source_attendance.break_time,
            comp_time_regular_minutes=source_attendance.comp_time_regular_minutes,
            comp_time_overtime_minutes=source_attendance.comp_time_overtime_minutes,
            comp_time_ot_before_22_minutes=source_attendance.comp_time_ot_before_22_minutes,
            comp_time_ot_after_22_minutes=source_attendance.comp_time_ot_after_22_minutes,
            overtime_comp_time_minutes=source_attendance.overtime_comp_time_minutes,
            is_holiday=source_attendance.is_holiday,
            holiday_type=source_attendance.holiday_type,
            status='pending',  # Reset v·ªÅ pending ƒë·ªÉ ph√™ duy·ªát l·∫°i
            note=source_attendance.note,  # Gi·ªØ nguy√™n ghi ch√∫
            total_work_hours=source_attendance.total_work_hours,
            regular_work_hours=source_attendance.regular_work_hours,
            overtime_before_22=source_attendance.overtime_before_22,
            overtime_after_22=source_attendance.overtime_after_22,
            shift_code=source_attendance.shift_code,
            shift_start=source_attendance.shift_start,
            shift_end=source_attendance.shift_end,
            required_hours=source_attendance.required_hours,
            signature=source_attendance.signature,  # Gi·ªØ ch·ªØ k√Ω c·ªßa employee
            # Reset c√°c th√¥ng tin ph√™ duy·ªát
            approved=False,
            approved_by=None,
            approved_at=None,
            team_leader_signature=None,
            manager_signature=None,
            team_leader_signer_id=None,
            manager_signer_id=None
        )
        
        db.session.add(new_attendance)
        db.session.commit()
        
        # Log audit
        log_audit_action(
            user_id=user.id,
            action='DUPLICATE_ATTENDANCE',
            table_name='attendances',
            record_id=new_attendance.id,
            old_values={'source_id': source_attendance.id, 'source_status': source_attendance.status},
            new_values={'new_id': new_attendance.id, 'new_status': new_attendance.status}
        )
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ t·∫°o l·∫°i b·∫£n ghi ch·∫•m c√¥ng th√†nh c√¥ng. B·∫£n ghi m·ªõi ·ªü tr·∫°ng th√°i ch·ªù ph√™ duy·ªát.',
            'new_attendance_id': new_attendance.id,
            'date': new_attendance.date.strftime('%Y-%m-%d'),
            'user_name': source_attendance.user.name if source_attendance.user else 'Unknown',
            'status': new_attendance.status
        })
        
    except Exception as e:
        db.session.rollback()
        import traceback
        print(f"‚ùå [DUPLICATE_ERROR] L·ªói khi t·∫°o l·∫°i b·∫£n ghi ch·∫•m c√¥ng: {e}")
        print(traceback.format_exc())
        return jsonify({'error': f'ƒê√£ x·∫£y ra l·ªói khi t·∫°o l·∫°i b·∫£n ghi ch·∫•m c√¥ng: {str(e)}'}), 500


def check_attendance_access_permission(user_id, attendance_id, action='read'):
    """Check if user has permission to access specific attendance record"""
    user = db.session.get(User, user_id)
    if not user:
        return False, "‚ùå KH√îNG T√åM TH·∫§Y NG∆Ø·ªúI D√ôNG"
    
    attendance = db.session.get(Attendance, attendance_id)
    if not attendance:
        return False, "‚ùå KH√îNG T√åM TH·∫§Y B·∫¢N GHI CH·∫§M C√îNG"
    
    current_role = session.get('current_role', user.roles.split(',')[0])
    
    # ADMIN c√≥ th·ªÉ truy c·∫≠p t·∫•t c·∫£
    if current_role == 'ADMIN':
        return True, ""
    
    # MANAGER c√≥ th·ªÉ truy c·∫≠p nh√¢n vi√™n c√πng ph√≤ng ban
    if current_role == 'MANAGER':
        if not attendance.user or attendance.user.department != user.department:
            return False, "‚ùå KH√îNG C√ôNG PH√íNG BAN: Ch·ªâ xem ƒë∆∞·ª£c nh√¢n vi√™n c√πng ph√≤ng"
        return True, ""
    
    # TEAM_LEADER c√≥ th·ªÉ truy c·∫≠p nh√¢n vi√™n c√πng ph√≤ng ban
    if current_role == 'TEAM_LEADER':
        if not attendance.user or attendance.user.department != user.department:
            return False, "‚ùå KH√îNG C√ôNG PH√íNG BAN: Ch·ªâ xem ƒë∆∞·ª£c nh√¢n vi√™n c√πng ph√≤ng"
        return True, ""
    
    # EMPLOYEE ch·ªâ c√≥ th·ªÉ truy c·∫≠p b·∫£n ghi c·ªßa ch√≠nh m√¨nh
    if current_role == 'EMPLOYEE':
        if attendance.user_id != user_id:
            return False, "‚ùå CH·ªà XEM ƒê∆Ø·ª¢C B·∫¢N GHI C·ª¶A M√åNH"
        return True, ""
    
    return False, "‚ùå KH√îNG C√ì QUY·ªÄN XEM B·∫¢N GHI N√ÄY"

def check_request_access_permission(user_id, request_id, action='read'):
    """Check if user has permission to access specific request record"""
    user = db.session.get(User, user_id)
    if not user:
        return False, "‚ùå KH√îNG T√åM TH·∫§Y NG∆Ø·ªúI D√ôNG"
    
    req = Request.query.options(joinedload(Request.user)).get(request_id)
    if not req:
        return False, "‚ùå KH√îNG T√åM TH·∫§Y Y√äU C·∫¶U"
    
    current_role = session.get('current_role', user.roles.split(',')[0])
    
    # ADMIN c√≥ th·ªÉ truy c·∫≠p t·∫•t c·∫£
    if current_role == 'ADMIN':
        return True, ""
    
    # MANAGER c√≥ th·ªÉ truy c·∫≠p y√™u c·∫ßu c·ªßa nh√¢n vi√™n c√πng ph√≤ng ban
    if current_role == 'MANAGER':
        if not req.user or req.user.department != user.department:
            return False, "‚ùå KH√îNG C√ôNG PH√íNG BAN: Ch·ªâ xem ƒë∆∞·ª£c y√™u c·∫ßu c√πng ph√≤ng"
        return True, ""
    
    # TEAM_LEADER c√≥ th·ªÉ truy c·∫≠p y√™u c·∫ßu c·ªßa nh√¢n vi√™n c√πng ph√≤ng ban
    if current_role == 'TEAM_LEADER':
        if not req.user or req.user.department != user.department:
            return False, "‚ùå KH√îNG C√ôNG PH√íNG BAN: Ch·ªâ xem ƒë∆∞·ª£c y√™u c·∫ßu c√πng ph√≤ng"
        return True, ""
    
    # EMPLOYEE ch·ªâ c√≥ th·ªÉ truy c·∫≠p y√™u c·∫ßu c·ªßa ch√≠nh m√¨nh
    if current_role == 'EMPLOYEE':
        if req.user_id != user_id:
            return False, "‚ùå CH·ªà XEM ƒê∆Ø·ª¢C Y√äU C·∫¶U C·ª¶A M√åNH"
        return True, ""
    
    return False, "‚ùå KH√îNG C√ì QUY·ªÄN XEM Y√äU C·∫¶U N√ÄY"

# Import session utilities from utils
from utils.session import check_session_timeout, update_session_activity, log_audit_action

def require_role(required_role):
    """Decorator to require specific role for route"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not session.get('user_id'):
                return redirect(url_for('login'))
            
            # Ki·ªÉm tra vai tr√≤ hi·ªán t·∫°i trong session
            current_role = session.get('current_role')
            if current_role != required_role:
                flash(f'‚ö†Ô∏è C·∫¶N CHUY·ªÇN VAI TR√í: Chuy·ªÉn sang vai tr√≤ {required_role} ƒë·ªÉ truy c·∫≠p trang n√†y', 'error')
                return redirect(url_for('dashboard'))
            
            # Ki·ªÉm tra user c√≥ role n√†y trong database kh√¥ng
            if not has_role(session['user_id'], required_role):
                flash('‚ùå KH√îNG C√ì QUY·ªÄN: B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p trang n√†y', 'error')
                return redirect(url_for('dashboard'))
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# Role-based route decorators
def require_admin(f):
    return require_role('ADMIN')(f)

def require_manager(f):
    return require_role('MANAGER')(f)

def require_team_lead(f):
    return require_role('TEAM_LEADER')(f)

def require_employee(f):
    return require_role('EMPLOYEE')(f)

@app.route('/admin/users')
@require_admin
def admin_users():
    page = request.args.get('page', 1, type=int)
    per_page = 10  # M·∫∑c ƒë·ªãnh 10/trang, kh√¥ng cho ch·ªçn
    search = request.args.get('search', '', type=str).strip()
    department_filter = request.args.get('department', '', type=str).strip()
    maternity_filter = request.args.get('maternity', '', type=str).strip()  # 'active' = ch·ªâ m·∫π <12m ƒëang √°p d·ª•ng

    # Ng√†y hi·ªán t·∫°i ƒë·ªÉ t√≠nh to√°n ch√≠nh s√°ch m·∫π <12 th√°ng
    today = date.today()

    query = User.query.filter_by(is_deleted=False)  # Ch·ªâ hi·ªÉn th·ªã users ch∆∞a b·ªã soft delete
    if search:
        # C·∫£i thi·ªán t√¨m ki·∫øm: chuy·ªÉn v·ªÅ lowercase v√† s·ª≠ d·ª•ng func.lower() ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng
        search_lower = search.lower().strip()
        # T√°ch t·ª´ kh√≥a t√¨m ki·∫øm th√†nh c√°c t·ª´ ri√™ng l·∫ª
        search_words = search_lower.split()
        
        # T·∫°o ƒëi·ªÅu ki·ªán t√¨m ki·∫øm ƒë∆°n gi·∫£n - t√¨m theo t·ª´ng t·ª´ ri√™ng l·∫ª
        name_conditions = []
        for word in search_words:
            name_conditions.append(func.lower(User.name).contains(word))
        
        # Th√™m ƒëi·ªÅu ki·ªán t√¨m ki·∫øm theo m√£ nh√¢n vi√™n
        name_conditions.append(func.lower(func.cast(User.employee_id, db.String)).contains(search_lower))
        
        # K·∫øt h·ª£p t·∫•t c·∫£ ƒëi·ªÅu ki·ªán v·ªõi OR
        query = query.filter(db.or_(*name_conditions))
    if department_filter:
        query = query.filter(User.department == department_filter)

    # L·ªçc theo ch√≠nh s√°ch m·∫π c√≥ con <12 th√°ng (ƒëang hi·ªáu l·ª±c)
    if maternity_filter == 'active':
        query = query.filter(
            User.is_maternity_flex.is_(True),
            db.or_(User.maternity_flex_from.is_(None), User.maternity_flex_from <= today),
            db.or_(User.maternity_flex_until.is_(None), today <= User.maternity_flex_until),
        )
    query = query.order_by(User.name.asc())

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    users = pagination.items

    # B·ªï sung th√¥ng tin ch√≠nh s√°ch m·∫π c√≥ con <12 th√°ng cho view
    for u in users:
        # ƒêang √°p d·ª•ng: trong kho·∫£ng th·ªùi gian ƒë∆∞·ª£c h∆∞·ªüng ch√≠nh s√°ch
        flex_active = bool(
            u.is_maternity_flex
            and (u.maternity_flex_from is None or u.maternity_flex_from <= today)
            and (u.maternity_flex_until is None or today <= u.maternity_flex_until)
        )

        # C√≤n bao nhi√™u ng√†y ƒë·∫øn khi h·∫øt ch√≠nh s√°ch (n·∫øu c√≥ ng√†y k·∫øt th√∫c)
        remaining_days = None
        if u.maternity_flex_until:
            remaining_days = (u.maternity_flex_until - today).days

        # Tr·∫°ng th√°i "t·∫°m ng∆∞ng" ch·ªâ hi·ªÉn th·ªã khi ƒë√£ c·∫•u h√¨nh nh∆∞ng ch∆∞a t·ªõi ng√†y b·∫Øt ƒë·∫ßu
        # Sau khi h·∫øt th·ªùi gian h∆∞·ªüng ch√≠nh s√°ch th√¨ kh√¥ng coi l√† "t·∫°m ng∆∞ng" n·ªØa,
        # user tr·ªü v·ªÅ tr·∫°ng th√°i nh√¢n vi√™n b√¨nh th∆∞·ªùng.
        flex_pending = bool(
            u.is_maternity_flex
            and not flex_active
            and u.maternity_flex_from is not None
            and u.maternity_flex_from > today
        )

        # g√°n t·∫°m thu·ªôc t√≠nh hi·ªÉn th·ªã
        u.flex_active = flex_active
        u.flex_pending = flex_pending
        u.flex_remaining_days = remaining_days

    # L·∫•y danh s√°ch ph√≤ng ban t·ª´ database (unique, kh√¥ng null)
    db_departments = db.session.query(User.department).filter(
        User.is_deleted == False,
        User.department != None,
        User.department != ''
    ).distinct().order_by(User.department).all()
    departments = sorted(set([d[0] for d in db_departments if d[0]]))

    # Calculate statistics
    admin_count = sum(1 for user in users if 'ADMIN' in user.roles.split(','))
    active_count = sum(1 for user in users if user.is_active)
    department_count = len(set(user.department for user in users))
    # T√≠nh to√°n ph√¢n trang ƒë·∫πp (hi·ªÉn th·ªã 5 trang quanh trang hi·ªán t·∫°i)
    start_page = max(1, pagination.page - 2)
    end_page = min(pagination.pages, pagination.page + 2)
    if end_page - start_page < 4:
        end_page = min(pagination.pages, start_page + 4)
        start_page = max(1, end_page - 4)
    page_range = range(start_page, end_page + 1)

    return render_template(
        'admin/users.html',
        users=users,
        admin_count=admin_count,
        active_count=active_count,
        department_count=department_count,
        pagination=pagination,
        search=search,
        departments=departments,
        department_filter=department_filter,
        maternity_filter=maternity_filter,
        per_page=per_page,
        page_range=page_range
    )

@app.route('/admin/departments', methods=['GET', 'POST'])
@require_admin
def admin_departments():
    """Qu·∫£n l√Ω ph√≤ng ban v√† mapping v·ªõi Google Sheet"""
    from database.models import Department
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'add':
            name = request.form.get('name', '').strip().upper()
            timesheet_file = request.form.get('timesheet_file', '').strip()
            
            if not name or not timesheet_file:
                flash('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!', 'error')
                return redirect(url_for('admin_departments'))
            
            # Ki·ªÉm tra tr√πng t√™n
            existing = Department.query.filter_by(name=name).first()
            if existing:
                flash(f'Ph√≤ng ban "{name}" ƒë√£ t·ªìn t·∫°i!', 'error')
                return redirect(url_for('admin_departments'))
            
            # T·∫°o m·ªõi
            new_dept = Department(name=name, timesheet_file=timesheet_file, is_active=True)
            db.session.add(new_dept)
            db.session.commit()
            
            flash(f'ƒê√£ th√™m ph√≤ng ban "{name}" th√†nh c√¥ng!', 'success')
            
        elif action == 'edit':
            dept_id = request.form.get('dept_id', type=int)
            name = request.form.get('name', '').strip().upper()
            timesheet_file = request.form.get('timesheet_file', '').strip()
            
            dept = Department.query.get(dept_id)
            if dept:
                dept.name = name
                dept.timesheet_file = timesheet_file
                db.session.commit()
                
                flash(f'ƒê√£ c·∫≠p nh·∫≠t ph√≤ng ban "{name}" th√†nh c√¥ng!', 'success')
            else:
                flash('Kh√¥ng t√¨m th·∫•y ph√≤ng ban!', 'error')
                
        elif action == 'delete':
            dept_id = request.form.get('dept_id', type=int)
            dept = Department.query.get(dept_id)
            if dept:
                name = dept.name
                db.session.delete(dept)
                db.session.commit()
                
                flash(f'ƒê√£ x√≥a ph√≤ng ban "{name}" th√†nh c√¥ng!', 'success')
            else:
                flash('Kh√¥ng t√¨m th·∫•y ph√≤ng ban!', 'error')
        
        return redirect(url_for('admin_departments'))
    
    # GET: Hi·ªÉn th·ªã danh s√°ch ph√≤ng ban
    departments = Department.query.order_by(Department.name).all()
    return render_template('admin/departments.html', departments=departments)


def _notify_missing_holidays():
    """G·ª≠i th√¥ng b√°o cho admin khi ch∆∞a c·∫•u h√¨nh ng√†y l·ªÖ (gi·ªëng c∆° ch·∫ø refresh token)."""
    try:
        current_year = datetime.now().year
        message = (
            f"‚ö†Ô∏è CH∆ØA C·∫§U H√åNH NG√ÄY L·ªÑ CHO NƒÇM {current_year}\n\n"
            "Vui l√≤ng v√†o m·ª•c 'Qu·∫£n l√Ω ng√†y l·ªÖ' ƒë·ªÉ th√™m c√°c ng√†y ngh·ªâ l·ªÖ Vi·ªát Nam / Nh·∫≠t B·∫£n "
            "tr∆∞·ªõc khi ch·∫°y b·∫£ng ch·∫•m c√¥ng."
        )
        # Th√¥ng b√°o qua k√™nh SSE gi·ªëng refresh token (n·∫øu front-end ƒëang l·∫Øng nghe)
        try:
            publish_token_status('expired', message, needs_reauth=False)
        except Exception:
            pass
        # G·ª≠i th√™m qua Telegram (n·∫øu ƒë√£ c·∫•u h√¨nh BOT_TOKEN, CHAT_ID)
        try:
            send_telegram_message(message)
        except Exception:
            pass
    except Exception:
        # Kh√¥ng ƒë·ªÉ l·ªói th√¥ng b√°o l√†m h·ªèng request ch√≠nh
        pass


@app.route('/admin/holidays', methods=['GET', 'POST'])
@require_admin
def admin_holidays():
    """Qu·∫£n l√Ω ng√†y l·ªÖ Vi·ªát Nam v√† Nh·∫≠t B·∫£n"""
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'add':
            date_str = request.form.get('date', '').strip()
            holiday_type = request.form.get('holiday_type', '').strip()
            name = request.form.get('name', '').strip()
            description = request.form.get('description', '').strip()
            
            if not date_str or not holiday_type:
                flash('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!', 'error')
                return redirect(url_for('admin_holidays'))
            
            if holiday_type not in ['vietnamese_holiday', 'japanese_holiday']:
                flash('Lo·∫°i ng√†y l·ªÖ kh√¥ng h·ª£p l·ªá!', 'error')
                return redirect(url_for('admin_holidays'))
            
            try:
                from datetime import datetime
                date = datetime.strptime(date_str, '%Y-%m-%d').date()
            except ValueError:
                flash('Ng√†y kh√¥ng h·ª£p l·ªá!', 'error')
                return redirect(url_for('admin_holidays'))
            
            # Ki·ªÉm tra tr√πng ng√†y
            existing = Holiday.query.filter_by(date=date).first()
            if existing:
                flash(f'Ng√†y {date_str} ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† {existing.holiday_type}!', 'error')
                return redirect(url_for('admin_holidays'))
            
            # T·∫°o m·ªõi
            # L∆∞u ng∆∞·ªùi t·∫°o d·ª±a tr√™n session (h·ªá th·ªëng ƒëang d√πng session ƒë·ªÉ qu·∫£n l√Ω ƒëƒÉng nh·∫≠p)
            creator_id = session.get('user_id')
            new_holiday = Holiday(
                date=date,
                holiday_type=holiday_type,
                name=name if name else None,
                description=description if description else None,
                created_by=creator_id
            )
            db.session.add(new_holiday)
            db.session.commit()
            
            flash(f'ƒê√£ th√™m ng√†y l·ªÖ th√†nh c√¥ng!', 'success')
            
        elif action == 'edit':
            holiday_id = request.form.get('holiday_id', type=int)
            date_str = request.form.get('date', '').strip()
            holiday_type = request.form.get('holiday_type', '').strip()
            name = request.form.get('name', '').strip()
            description = request.form.get('description', '').strip()
            
            holiday = Holiday.query.get(holiday_id)
            if not holiday:
                flash('Kh√¥ng t√¨m th·∫•y ng√†y l·ªÖ!', 'error')
                return redirect(url_for('admin_holidays'))
            
            if not date_str or not holiday_type:
                flash('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!', 'error')
                return redirect(url_for('admin_holidays'))
            
            if holiday_type not in ['vietnamese_holiday', 'japanese_holiday']:
                flash('Lo·∫°i ng√†y l·ªÖ kh√¥ng h·ª£p l·ªá!', 'error')
                return redirect(url_for('admin_holidays'))
            
            try:
                from datetime import datetime
                date = datetime.strptime(date_str, '%Y-%m-%d').date()
            except ValueError:
                flash('Ng√†y kh√¥ng h·ª£p l·ªá!', 'error')
                return redirect(url_for('admin_holidays'))
            
            # Ki·ªÉm tra tr√πng ng√†y v·ªõi ng√†y l·ªÖ kh√°c
            existing = Holiday.query.filter_by(date=date).first()
            if existing and existing.id != holiday_id:
                flash(f'Ng√†y {date_str} ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† {existing.holiday_type}!', 'error')
                return redirect(url_for('admin_holidays'))
            
            holiday.date = date
            holiday.holiday_type = holiday_type
            holiday.name = name if name else None
            holiday.description = description if description else None
            db.session.commit()
            
            flash(f'ƒê√£ c·∫≠p nh·∫≠t ng√†y l·ªÖ th√†nh c√¥ng!', 'success')
                
        elif action == 'delete':
            holiday_id = request.form.get('holiday_id', type=int)
            holiday = Holiday.query.get(holiday_id)
            if holiday:
                date_str = holiday.date.strftime('%d/%m/%Y')
                db.session.delete(holiday)
                db.session.commit()
                
                flash(f'ƒê√£ x√≥a ng√†y l·ªÖ {date_str} th√†nh c√¥ng!', 'success')
            else:
                flash('Kh√¥ng t√¨m th·∫•y ng√†y l·ªÖ!', 'error')
        
        return redirect(url_for('admin_holidays'))
    
    # GET: Hi·ªÉn th·ªã danh s√°ch ng√†y l·ªÖ
    holidays = Holiday.query.order_by(Holiday.date.desc()).all()
    return render_template('admin/holidays.html', holidays=holidays)


@app.route('/api/get-day-type', methods=['GET'])
def get_day_type():
    """API ƒë·ªÉ l·∫•y lo·∫°i ng√†y d·ª±a tr√™n ng√†y ƒë∆∞·ª£c ch·ªçn"""
    # Ki·ªÉm tra session-based authentication (·ª©ng d·ª•ng n√†y d√πng session thay v√¨ Flask-Login)
    if 'user_id' not in session:
        return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p', 'day_type': 'normal', 'reason': 'Ng√†y th∆∞·ªùng (fallback)'}), 401
    
    try:
        
        date_str = request.args.get('date')
        print(f"DEBUG: date_str = {date_str}")
        if not date_str:
            return jsonify({'error': 'Vui l√≤ng cung c·∫•p ng√†y'}), 400
        
        try:
            from datetime import datetime
            date = datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({'error': 'Ng√†y kh√¥ng h·ª£p l·ªá'}), 400
        
        # Ki·ªÉm tra th·ª© trong tu·∫ßn (0 = Monday, 6 = Sunday)
        weekday = date.weekday()  # 0-6 (Monday-Sunday)
        is_weekend = weekday >= 5  # Saturday (5) or Sunday (6)
        
        # Ki·ªÉm tra ng√†y l·ªÖ trong database (v·ªõi x·ª≠ l√Ω l·ªói n·∫øu b·∫£ng ch∆∞a t·ªìn t·∫°i)
        holiday = None
        try:
            holiday = Holiday.query.filter_by(date=date).first()
        except Exception as e:
            # N·∫øu b·∫£ng holidays ch∆∞a t·ªìn t·∫°i, b·ªè qua v√† ch·ªâ d·ª±a v√†o th·ª© trong tu·∫ßn
            print(f"Warning: Kh√¥ng th·ªÉ query Holiday table: {e}")
            holiday = None
        
        # ƒê·ªô ∆∞u ti√™n: L·ªÖ Vi·ªát Nam > Cu·ªëi tu·∫ßn > L·ªÖ Nh·∫≠t
        if holiday and holiday.holiday_type == 'vietnamese_holiday':
            return jsonify({
                'day_type': 'vietnamese_holiday',
                'reason': 'L·ªÖ Vi·ªát Nam',
                'holiday_name': holiday.name if holiday.name else None
            })
        elif is_weekend:
            return jsonify({
                'day_type': 'weekend',
                'reason': 'Cu·ªëi tu·∫ßn'
            })
        elif holiday and holiday.holiday_type == 'japanese_holiday':
            return jsonify({
                'day_type': 'japanese_holiday',
                'reason': 'L·ªÖ Nh·∫≠t B·∫£n',
                'holiday_name': holiday.name if holiday.name else None
            })
        else:
            return jsonify({
                'day_type': 'normal',
                'reason': 'Ng√†y th∆∞·ªùng'
            })
    except Exception as e:
        # ƒê·∫£m b·∫£o lu√¥n tr·∫£ v·ªÅ JSON ngay c·∫£ khi c√≥ l·ªói
        import traceback
        print(f"Error in get_day_type: {e}")
        print(traceback.format_exc())
        return jsonify({
            'error': 'L·ªói khi x√°c ƒë·ªãnh lo·∫°i ng√†y',
            'day_type': 'normal',
            'reason': 'Ng√†y th∆∞·ªùng (fallback)'
        }), 500


@app.route('/api/get-excluded-days', methods=['GET'])
def get_excluded_days():
    """API ƒë·ªÉ l·∫•y danh s√°ch c√°c ng√†y ngh·ªâ l·ªÖ v√† cu·ªëi tu·∫ßn trong kho·∫£ng th·ªùi gian
    Tr·∫£ v·ªÅ danh s√°ch c√°c ng√†y c·∫ßn lo·∫°i tr·ª´ khi t√≠nh s·ªë ng√†y ph√©p
    """
    if 'user_id' not in session:
        return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p', 'excluded_days': []}), 401

    try:
        from_date_str = request.args.get('from_date')
        to_date_str = request.args.get('to_date')

        if not from_date_str or not to_date_str:
            return jsonify({'error': 'Vui l√≤ng cung c·∫•p from_date v√† to_date'}), 400

        try:
            from datetime import datetime, timedelta
            from_date = datetime.strptime(from_date_str, '%Y-%m-%d').date()
            to_date = datetime.strptime(to_date_str, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({'error': 'Ng√†y kh√¥ng h·ª£p l·ªá (format: YYYY-MM-DD)'}), 400

        if from_date > to_date:
            return jsonify({'error': 'from_date ph·∫£i nh·ªè h∆°n ho·∫∑c b·∫±ng to_date'}), 400

        excluded_days = []
        current_date = from_date

        # L·∫•y t·∫•t c·∫£ ng√†y l·ªÖ trong kho·∫£ng th·ªùi gian t·ª´ database
        holidays_in_range = {}
        try:
            holidays = Holiday.query.filter(
                Holiday.date >= from_date,
                Holiday.date <= to_date
            ).all()
            for h in holidays:
                holidays_in_range[h.date] = {
                    'type': h.holiday_type,
                    'name': h.name or ''
                }
        except Exception as e:
            print(f"Warning: Kh√¥ng th·ªÉ query Holiday table: {e}")

        # Duy·ªát qua t·ª´ng ng√†y trong kho·∫£ng
        while current_date <= to_date:
            weekday = current_date.weekday()  # 0=Monday, 6=Sunday
            is_weekend = weekday >= 5  # Saturday (5) or Sunday (6)

            date_str = current_date.strftime('%Y-%m-%d')

            # Ki·ªÉm tra ng√†y l·ªÖ Vi·ªát Nam (∆∞u ti√™n cao nh·∫•t)
            if current_date in holidays_in_range and holidays_in_range[current_date]['type'] == 'vietnamese_holiday':
                excluded_days.append({
                    'date': date_str,
                    'type': 'vietnamese_holiday',
                    'reason': 'L·ªÖ Vi·ªát Nam',
                    'name': holidays_in_range[current_date]['name']
                })
            # Ki·ªÉm tra cu·ªëi tu·∫ßn
            elif is_weekend:
                day_name = 'Th·ª© 7' if weekday == 5 else 'Ch·ªß nh·∫≠t'
                excluded_days.append({
                    'date': date_str,
                    'type': 'weekend',
                    'reason': f'Cu·ªëi tu·∫ßn ({day_name})',
                    'name': ''
                })
            # Ki·ªÉm tra ng√†y l·ªÖ Nh·∫≠t B·∫£n
            elif current_date in holidays_in_range and holidays_in_range[current_date]['type'] == 'japanese_holiday':
                excluded_days.append({
                    'date': date_str,
                    'type': 'japanese_holiday',
                    'reason': 'L·ªÖ Nh·∫≠t B·∫£n',
                    'name': holidays_in_range[current_date]['name']
                })

            current_date += timedelta(days=1)

        return jsonify({
            'excluded_days': excluded_days,
            'total_excluded': len(excluded_days),
            'from_date': from_date_str,
            'to_date': to_date_str
        })

    except Exception as e:
        import traceback
        print(f"Error in get_excluded_days: {e}")
        print(traceback.format_exc())
        return jsonify({
            'error': 'L·ªói khi l·∫•y danh s√°ch ng√†y lo·∫°i tr·ª´',
            'excluded_days': []
        }), 500


@app.route('/api/admin/pending-sync', methods=['GET'])
@require_admin
def get_pending_sync_requests():
    """API ƒë·ªÉ xem danh s√°ch c√°c ƒë∆°n ngh·ªâ ph√©p ƒë√£ approved nh∆∞ng ch∆∞a ƒë·ªìng b·ªô l√™n Google Sheet"""
    try:
        # L·∫•y c√°c ƒë∆°n ƒë√£ approved nh∆∞ng ch∆∞a sync ho·∫∑c sync th·∫•t b·∫°i
        pending_sync = LeaveRequest.query.filter(
            LeaveRequest.status == 'approved',
            db.or_(
                LeaveRequest.google_sheet_synced == False,
                LeaveRequest.google_sheet_synced == None
            )
        ).order_by(LeaveRequest.admin_approved_at.desc()).all()

        # L·∫•y c√°c ƒë∆°n ƒë√£ sync th·∫•t b·∫°i (c√≥ l·ªói)
        failed_sync = LeaveRequest.query.filter(
            LeaveRequest.status == 'approved',
            LeaveRequest.google_sheet_synced == False,
            LeaveRequest.google_sheet_sync_error != None
        ).order_by(LeaveRequest.admin_approved_at.desc()).all()

        # Format k·∫øt qu·∫£
        pending_list = []
        for lr in pending_sync:
            pending_list.append({
                'id': lr.id,
                'employee_name': lr.employee_name,
                'employee_code': lr.employee_code,
                'team': lr.team,
                'leave_from': f"{lr.leave_from_day:02d}/{lr.leave_from_month:02d}/{lr.leave_from_year}",
                'leave_to': f"{lr.leave_to_day:02d}/{lr.leave_to_month:02d}/{lr.leave_to_year}",
                'total_days': lr.get_total_requested_days(),
                'approved_at': lr.admin_approved_at.strftime('%d/%m/%Y %H:%M') if lr.admin_approved_at else None,
                'sync_attempts': lr.google_sheet_sync_attempts or 0,
                'sync_error': lr.google_sheet_sync_error,
                'request_type': lr.request_type
            })

        failed_list = []
        for lr in failed_sync:
            failed_list.append({
                'id': lr.id,
                'employee_name': lr.employee_name,
                'employee_code': lr.employee_code,
                'team': lr.team,
                'leave_from': f"{lr.leave_from_day:02d}/{lr.leave_from_month:02d}/{lr.leave_from_year}",
                'leave_to': f"{lr.leave_to_day:02d}/{lr.leave_to_month:02d}/{lr.leave_to_year}",
                'total_days': lr.get_total_requested_days(),
                'approved_at': lr.admin_approved_at.strftime('%d/%m/%Y %H:%M') if lr.admin_approved_at else None,
                'sync_attempts': lr.google_sheet_sync_attempts or 0,
                'sync_error': lr.google_sheet_sync_error,
                'request_type': lr.request_type
            })

        return jsonify({
            'success': True,
            'pending_sync': {
                'count': len(pending_list),
                'items': pending_list
            },
            'failed_sync': {
                'count': len(failed_list),
                'items': failed_list
            },
            'total_pending': len(pending_list),
            'total_failed': len(failed_list)
        })

    except Exception as e:
        import traceback
        print(f"Error in get_pending_sync_requests: {e}")
        print(traceback.format_exc())
        return jsonify({
            'success': False,
            'error': str(e),
            'pending_sync': {'count': 0, 'items': []},
            'failed_sync': {'count': 0, 'items': []}
        }), 500


@app.route('/api/admin/retry-sync/<int:request_id>', methods=['POST'])
@require_admin
def retry_sync_request(request_id):
    """API ƒë·ªÉ Admin retry ƒë·ªìng b·ªô Google Sheet cho ƒë∆°n ngh·ªâ ph√©p b·ªã l·ªói"""
    try:
        # L·∫•y th√¥ng tin user hi·ªán t·∫°i
        user_id = session.get('user_id')
        if not user_id:
            return jsonify({'success': False, 'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p'}), 401

        user = User.query.get(user_id)
        if not user:
            return jsonify({'success': False, 'error': 'Kh√¥ng t√¨m th·∫•y th√¥ng tin ng∆∞·ªùi d√πng'}), 401

        # L·∫•y ƒë∆°n ngh·ªâ ph√©p
        leave_request = LeaveRequest.query.get(request_id)
        if not leave_request:
            return jsonify({'success': False, 'error': f'Kh√¥ng t√¨m th·∫•y ƒë∆°n ngh·ªâ ph√©p #{request_id}'}), 404

        # Ki·ªÉm tra tr·∫°ng th√°i ƒë∆°n
        if leave_request.status != 'approved':
            return jsonify({
                'success': False,
                'error': f'ƒê∆°n #{request_id} ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát (status: {leave_request.status})'
            }), 400

        # Ki·ªÉm tra xem ƒë√£ sync th√†nh c√¥ng ch∆∞a
        if leave_request.google_sheet_synced:
            return jsonify({
                'success': False,
                'error': f'ƒê∆°n #{request_id} ƒë√£ ƒë∆∞·ª£c ƒë·ªìng b·ªô th√†nh c√¥ng tr∆∞·ªõc ƒë√≥',
                'synced_at': leave_request.google_sheet_sync_at.strftime('%d/%m/%Y %H:%M') if leave_request.google_sheet_sync_at else None
            }), 400

        # Ki·ªÉm tra token Google tr∆∞·ªõc khi retry
        token_status = check_google_token_status(use_cache=False)
        if not token_status.get('valid'):
            return jsonify({
                'success': False,
                'error': 'Token Google kh√¥ng h·ª£p l·ªá. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i Google Drive.',
                'token_status': token_status
            }), 400

        # Reset tr·∫°ng th√°i l·ªói v√† trigger sync l·∫°i
        leave_request.google_sheet_sync_error = None
        db.session.commit()

        # Trigger async sync
        trigger_schedule_leave_sheet_updates_async(request_id, user_id)

        return jsonify({
            'success': True,
            'message': f'ƒê√£ kh·ªüi ƒë·ªông l·∫°i qu√° tr√¨nh ƒë·ªìng b·ªô cho ƒë∆°n #{request_id}',
            'request_id': request_id,
            'previous_attempts': leave_request.google_sheet_sync_attempts or 0,
            'note': 'Vui l√≤ng ki·ªÉm tra l·∫°i sau v√†i gi√¢y ƒë·ªÉ xem k·∫øt qu·∫£ ƒë·ªìng b·ªô'
        })

    except Exception as e:
        db.session.rollback()  # Rollback transaction on error
        import traceback
        print(f"Error in retry_sync_request: {e}")
        print(traceback.format_exc())
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/admin/bulk-retry-sync', methods=['POST'])
@require_admin
def bulk_retry_sync():
    """API ƒë·ªÉ Admin retry ƒë·ªìng b·ªô Google Sheet cho nhi·ªÅu ƒë∆°n c√πng l√∫c"""
    try:
        # L·∫•y th√¥ng tin user hi·ªán t·∫°i
        user_id = session.get('user_id')
        if not user_id:
            return jsonify({'success': False, 'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p'}), 401

        user = User.query.get(user_id)
        if not user:
            return jsonify({'success': False, 'error': 'Kh√¥ng t√¨m th·∫•y th√¥ng tin ng∆∞·ªùi d√πng'}), 401

        # L·∫•y danh s√°ch request_ids t·ª´ body
        data = request.get_json() or {}
        request_ids = data.get('request_ids', [])

        if not request_ids:
            # N·∫øu kh√¥ng c√≥ request_ids, retry t·∫•t c·∫£ c√°c ƒë∆°n pending sync
            pending_requests = LeaveRequest.query.filter(
                LeaveRequest.status == 'approved',
                db.or_(
                    LeaveRequest.google_sheet_synced == False,
                    LeaveRequest.google_sheet_synced == None
                )
            ).all()
            request_ids = [lr.id for lr in pending_requests]

        if not request_ids:
            return jsonify({
                'success': True,
                'message': 'Kh√¥ng c√≥ ƒë∆°n n√†o c·∫ßn retry',
                'retried_count': 0
            })

        # Ki·ªÉm tra token Google tr∆∞·ªõc khi retry
        token_status = check_google_token_status(use_cache=False)
        if not token_status.get('valid'):
            return jsonify({
                'success': False,
                'error': 'Token Google kh√¥ng h·ª£p l·ªá. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i Google Drive.',
                'token_status': token_status
            }), 400

        # Retry t·ª´ng ƒë∆°n
        retried = []
        skipped = []
        for rid in request_ids:
            lr = LeaveRequest.query.get(rid)
            if not lr:
                skipped.append({'id': rid, 'reason': 'Kh√¥ng t√¨m th·∫•y'})
                continue
            if lr.status != 'approved':
                skipped.append({'id': rid, 'reason': f'Status kh√¥ng ph·∫£i approved ({lr.status})'})
                continue
            if lr.google_sheet_synced:
                skipped.append({'id': rid, 'reason': 'ƒê√£ sync th√†nh c√¥ng'})
                continue

            # Reset l·ªói v√† trigger sync
            lr.google_sheet_sync_error = None
            db.session.commit()
            trigger_schedule_leave_sheet_updates_async(rid, user_id)
            retried.append(rid)

        return jsonify({
            'success': True,
            'message': f'ƒê√£ kh·ªüi ƒë·ªông retry cho {len(retried)} ƒë∆°n',
            'retried_count': len(retried),
            'retried_ids': retried,
            'skipped_count': len(skipped),
            'skipped': skipped
        })

    except Exception as e:
        db.session.rollback()  # Rollback transaction on error
        import traceback
        print(f"Error in bulk_retry_sync: {e}")
        print(traceback.format_exc())
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/admin/users/<int:user_id>/edit', methods=['GET', 'POST'])
@require_admin
def edit_user(user_id):
    user = User.query.get_or_404(user_id)
    if request.method == 'POST':
        try:
            name = validate_input_sanitize(request.form.get('name'))
            department = validate_input_sanitize(request.form.get('department'))
            email = request.form.get('email', '').strip()
            is_maternity_flex = request.form.get('is_maternity_flex') == 'on'
            flex_from_str = (request.form.get('maternity_flex_from') or '').strip()
            flex_until_str = (request.form.get('maternity_flex_until') or '').strip()
            
            if not name:
                flash('T√™n ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá', 'error')
                return redirect(url_for('edit_user', user_id=user_id))
            if not department:
                flash('Ph√≤ng ban kh√¥ng h·ª£p l·ªá', 'error')
                return redirect(url_for('edit_user', user_id=user_id))
            
            # Validate email n·∫øu c√≥
            if email:
                email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
                if not re.match(email_pattern, email):
                    flash('Email kh√¥ng h·ª£p l·ªá!', 'error')
                    return redirect(url_for('edit_user', user_id=user_id))
                
                # Ki·ªÉm tra email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi user kh√°c ch∆∞a
                existing_email_user = User.query.filter_by(email=email, is_deleted=False).first()
                if existing_email_user and existing_email_user.id != user_id:
                    flash('Email n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi nh√¢n vi√™n kh√°c!', 'error')
                    return redirect(url_for('edit_user', user_id=user_id))
            
            # Parse ng√†y linh ho·∫°t (cho ph√©p ƒë·ªÉ tr·ªëng)
            def _parse_date(val, label):
                if not val:
                    return None
                try:
                    return datetime.strptime(val, '%Y-%m-%d').date()
                except ValueError:
                    flash(f'Ng√†y {label} kh√¥ng h·ª£p l·ªá (ƒë·ªãnh d·∫°ng YYYY-MM-DD)', 'error')
                    raise
            
            flex_from_date = None
            flex_until_date = None
            try:
                flex_from_date = _parse_date(flex_from_str, 'b·∫Øt ƒë·∫ßu √°p d·ª•ng')
                flex_until_date = _parse_date(flex_until_str, 'h·∫øt hi·ªáu l·ª±c')
            except ValueError:
                return redirect(url_for('edit_user', user_id=user_id))
            
            if flex_from_date and flex_until_date and flex_until_date < flex_from_date:
                flash('Ng√†y h·∫øt hi·ªáu l·ª±c ph·∫£i l·ªõn h∆°n ho·∫∑c b·∫±ng ng√†y b·∫Øt ƒë·∫ßu', 'error')
                return redirect(url_for('edit_user', user_id=user_id))
            
            # Get selected roles from checkboxes
            selected_roles = []
            role_mapping = {
                'EMPLOYEE': 'EMPLOYEE',
                'TEAM_LEADER': 'TEAM_LEADER', 
                'MANAGER': 'MANAGER',
                'ADMIN': 'ADMIN'
            }
            
            for role_key, role_value in role_mapping.items():
                if request.form.get(f'role_{role_key}') == 'on':
                    selected_roles.append(role_value)
            
            if not selected_roles:
                flash('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt vai tr√≤!', 'error')
                return redirect(url_for('edit_user', user_id=user_id))
            
            # Update user
            old_values = {
                'name': user.name,
                'department': user.department,
                'roles': user.roles,
                'email': user.email,
                'is_maternity_flex': user.is_maternity_flex,
                'maternity_flex_from': user.maternity_flex_from.isoformat() if user.maternity_flex_from else None,
                'maternity_flex_until': user.maternity_flex_until.isoformat() if user.maternity_flex_until else None
            }
            
            user.name = name
            user.roles = ','.join(selected_roles)
            user.department = department
            user.email = email if email else None
            user.is_maternity_flex = is_maternity_flex
            user.maternity_flex_from = flex_from_date
            user.maternity_flex_until = flex_until_date
            
            db.session.commit()
            
            # Log the action
            log_audit_action(
                user_id=session['user_id'],
                action='UPDATE_USER',
                table_name='users',
                record_id=user_id,
                old_values=old_values,
                new_values={
                    'name': name,
                    'department': department,
                    'roles': ','.join(selected_roles),
                    'email': email if email else None,
                    'is_maternity_flex': is_maternity_flex,
                    'maternity_flex_from': flex_from_date.isoformat() if flex_from_date else None,
                    'maternity_flex_until': flex_until_date.isoformat() if flex_until_date else None
                }
            )
            
            flash('C·∫≠p nh·∫≠t ng∆∞·ªùi d√πng th√†nh c√¥ng', 'success')
            return redirect(url_for('admin_users'))
        except Exception as e:
            db.session.rollback()  # Rollback transaction on error
            # print(f"Error updating user: {str(e)}")
            flash('ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t ng∆∞·ªùi d√πng!', 'error')
            return redirect(url_for('edit_user', user_id=user_id))
    # L·∫•y danh s√°ch ph√≤ng ban t·ª´ b·∫£ng Department trong database
    from database.models import Department
    db_departments = Department.query.filter_by(is_active=True).order_by(Department.name).all()
    departments = [d.name for d in db_departments]
    
    return render_template('admin/edit_user.html', user=user, departments=departments)

@app.route('/admin/users/create', methods=['GET', 'POST'])
@require_admin
def create_user():
    # L·∫•y danh s√°ch ph√≤ng ban ngay t·ª´ ƒë·∫ßu ƒë·ªÉ d√πng cho t·∫•t c·∫£ c√°c tr∆∞·ªùng h·ª£p render template
    from database.models import Department
    db_departments = Department.query.filter_by(is_active=True).order_by(Department.name).all()
    departments = [d.name for d in db_departments]

    if request.method == 'POST':
        try:
            # Validate input
            employee_id_str = request.form.get('employee_id')
            password = request.form.get('password')
            name = validate_input_sanitize(request.form.get('name'))
            department = validate_input_sanitize(request.form.get('department'))
            is_maternity_flex = request.form.get('is_maternity_flex') == 'on'
            flex_from_str = (request.form.get('maternity_flex_from') or '').strip()
            flex_until_str = (request.form.get('maternity_flex_until') or '').strip()
            
            # Validate employee_id
            employee_id = validate_employee_id(employee_id_str)
            if not employee_id:
                flash('M√£ nh√¢n vi√™n kh√¥ng h·ª£p l·ªá!', 'error')
                return render_template('admin/create_user.html', departments=departments)
            
            # Validate password
            if not validate_str(password, max_length=100):
                flash('M·∫≠t kh·∫©u kh√¥ng h·ª£p l·ªá!', 'error')
                return render_template('admin/create_user.html', departments=departments)
            
            # Validate name and department
            if not name:
                flash('T√™n ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá', 'error')
                return render_template('admin/create_user.html', departments=departments)
            if not department:
                flash('Ph√≤ng ban kh√¥ng h·ª£p l·ªá', 'error')
                return render_template('admin/create_user.html', departments=departments)
            
            def _parse_date(val, label):
                if not val:
                    return None
                try:
                    return datetime.strptime(val, '%Y-%m-%d').date()
                except ValueError:
                    flash(f'Ng√†y {label} kh√¥ng h·ª£p l·ªá (ƒë·ªãnh d·∫°ng YYYY-MM-DD)', 'error')
                    raise
            
            flex_from_date = None
            flex_until_date = None
            try:
                flex_from_date = _parse_date(flex_from_str, 'b·∫Øt ƒë·∫ßu √°p d·ª•ng')
                flex_until_date = _parse_date(flex_until_str, 'h·∫øt hi·ªáu l·ª±c')
            except ValueError:
                return render_template('admin/create_user.html', departments=departments)
            
            if flex_from_date and flex_until_date and flex_until_date < flex_from_date:
                flash('Ng√†y h·∫øt hi·ªáu l·ª±c ph·∫£i l·ªõn h∆°n ho·∫∑c b·∫±ng ng√†y b·∫Øt ƒë·∫ßu', 'error')
                return render_template('admin/create_user.html', departments=departments)
            
            # Check if employee_id already exists (ch·ªâ ki·ªÉm tra users ch∆∞a b·ªã x√≥a)
            existing_user = User.query.filter_by(employee_id=employee_id, is_deleted=False).first()
            if existing_user:
                flash('M√£ nh√¢n vi√™n ƒë√£ t·ªìn t·∫°i!', 'error')
                return render_template('admin/create_user.html', departments=departments)
            
            # Get selected roles from checkboxes
            selected_roles = []
            role_mapping = {
                'EMPLOYEE': 'EMPLOYEE',
                'TEAM_LEADER': 'TEAM_LEADER', 
                'MANAGER': 'MANAGER',
                'ADMIN': 'ADMIN'
            }
            
            for role_key, role_value in role_mapping.items():
                if request.form.get(f'role_{role_key}') == 'on':
                    selected_roles.append(role_value)
            
            if not selected_roles:
                flash('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt vai tr√≤!', 'error')
                return render_template('admin/create_user.html', departments=departments)
            
            # Create new user
            new_user = User(
                employee_id=employee_id,
                name=name,
                department=department,
                roles=','.join(selected_roles),
                is_active=True,
                is_maternity_flex=is_maternity_flex,
                maternity_flex_from=flex_from_date,
                maternity_flex_until=flex_until_date
            )
            new_user.set_password(password)
            
            db.session.add(new_user)
            db.session.commit()
            
            # Log the action
            log_audit_action(
                user_id=session['user_id'],
                action='CREATE_USER',
                table_name='users',
                record_id=new_user.id,
                new_values={
                    'employee_id': employee_id,
                    'name': name,
                    'department': department,
                    'roles': ','.join(selected_roles),
                    'is_maternity_flex': is_maternity_flex,
                    'maternity_flex_from': flex_from_date.isoformat() if flex_from_date else None,
                    'maternity_flex_until': flex_until_date.isoformat() if flex_until_date else None
                }
            )
            
            flash('T·∫°o ng∆∞·ªùi d√πng th√†nh c√¥ng!', 'success')
            return redirect(url_for('admin_users'))

        except Exception as e:
            db.session.rollback()  # Rollback transaction on error
            return render_template('admin/create_user.html', departments=departments)

    return render_template('admin/create_user.html', departments=departments)

@app.route('/switch-role', methods=['POST'])
def switch_role():
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    data = request.get_json()
    role = validate_role_value(data.get('role'))
    if not role:
        return jsonify({'error': 'Vai tr√≤ kh√¥ng h·ª£p l·ªá'}), 400
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    if role not in user.roles.split(','):
        return jsonify({'error': 'Vai tr√≤ kh√¥ng h·ª£p l·ªá'}), 400
    old_role = session.get('current_role')
    session['current_role'] = role
    
    # Invalidate cache for role switch
    from utils.realtime_updates import invalidate_role_cache
    invalidate_role_cache(user.id, role)
    
    log_audit_action(
        user_id=user.id,
        action='SWITCH_ROLE',
        table_name='users',
        record_id=user.id,
        old_values={'current_role': old_role},
        new_values={'current_role': role}
    )
    
    response = jsonify({'message': 'ƒê√£ chuy·ªÉn vai tr√≤ th√†nh c√¥ng'})
    # Ensure no caching of role switch response
    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

# API endpoint ƒë·ªÉ submit request
@app.route('/api/request/submit', methods=['POST'])
def submit_request():
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    data = request.get_json()
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    # Validate input
    request_type = validate_input_sanitize(data.get('request_type'))
    start_date = validate_date(data.get('start_date'))
    end_date = validate_date(data.get('end_date'))
    reason = validate_reason(data.get('reason'))
    if not request_type:
        return jsonify({'error': 'Lo·∫°i y√™u c·∫ßu kh√¥ng h·ª£p l·ªá'}), 400
    if not start_date:
        return jsonify({'error': 'Ng√†y b·∫Øt ƒë·∫ßu kh√¥ng h·ª£p l·ªá'}), 400
    if not end_date:
        return jsonify({'error': 'Ng√†y k·∫øt th√∫c kh√¥ng h·ª£p l·ªá'}), 400
    if not reason:
        return jsonify({'error': 'L√Ω do kh√¥ng h·ª£p l·ªá'}), 400
    if start_date > end_date:
        return jsonify({'error': 'Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i tr∆∞·ªõc ng√†y k·∫øt th√∫c'}), 400
    if start_date < datetime.now().date():
        return jsonify({'error': 'Kh√¥ng th·ªÉ t·∫°o y√™u c·∫ßu cho ng√†y trong qu√° kh·ª©'}), 400
    leader = User.query.filter_by(department=user.department, roles='TEAM_LEADER', is_deleted=False).first()
    if not leader:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y tr∆∞·ªüng nh√≥m cho ph√≤ng ban n√†y'}), 400
    new_request = Request(
        user_id=user.id,
        request_type=request_type,
        start_date=start_date,
        end_date=end_date,
        reason=reason,
        current_approver_id=leader.id,
        step='leader',
        status='pending'
    )
    db.session.add(new_request)
    db.session.commit()
    return jsonify({'message': 'G·ª≠i y√™u c·∫ßu th√†nh c√¥ng'}), 201

# API endpoint ƒë·ªÉ ph√™ duy·ªát/t·ª´ ch·ªëi request
@app.route('/api/request/<int:request_id>/approve', methods=['POST'])
def approve_request(request_id):
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    data = request.get_json()
    action = data.get('action')  # 'approve' ho·∫∑c 'reject'
    # Ch·ªâ y√™u c·∫ßu c√≥ l√Ω do (kh√¥ng b·∫Øt bu·ªôc 10 k√Ω t·ª±)
    reason_raw = data.get('reason', '') if data.get('action') == 'reject' else ''
    reason = validate_input_sanitize(reason_raw, max_length=500) if reason_raw else ''
    if action not in ['approve', 'reject']:
        return jsonify({'error': 'H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá'}), 400
    if action == 'reject' and not reason:
        return jsonify({'error': 'Vui l√≤ng nh·∫≠p l√Ω do t·ª´ ch·ªëi'}), 400
    has_permission, error_message = check_request_access_permission(session['user_id'], request_id, 'approve')
    if not has_permission:
        return jsonify({'error': error_message}), 403
    req = Request.query.options(joinedload(Request.user)).get_or_404(request_id)
    approver = db.session.get(User, session['user_id'])
    if req.current_approver_id != approver.id:
        return jsonify({'error': 'B·∫°n kh√¥ng c√≥ quy·ªÅn ph√™ duy·ªát y√™u c·∫ßu n√†y'}), 403
    if action == 'approve':
        if req.step == 'leader':
            manager = User.query.filter(
                User.department == req.user.department,
                User.roles.like('%MANAGER%'),
                User.is_deleted == False
            ).first()
            if not manager:
                return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y qu·∫£n l√Ω cho ph√≤ng ban n√†y'}), 400
            req.current_approver_id = manager.id
            req.step = 'manager'
        elif req.step == 'manager':
            admin = User.query.filter(
                User.roles.like('%ADMIN%'),
                User.is_deleted == False
            ).first()
            if not admin:
                return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y qu·∫£n tr·ªã vi√™n'}), 400
            req.current_approver_id = admin.id
            req.step = 'admin'
        elif req.step == 'admin':
            req.status = 'approved'
            req.step = 'done'
    else:  # reject
        req.status = 'rejected'
        req.step = 'employee_edit'
        req.reject_reason = reason
        req.current_approver_id = req.user_id
    db.session.commit()
    return jsonify({'message': 'C·∫≠p nh·∫≠t y√™u c·∫ßu th√†nh c√¥ng'}), 200

@app.route('/api/attendance/<int:attendance_id>', methods=['DELETE'])
def delete_attendance(attendance_id):
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    # Ki·ªÉm tra session timeout
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    
    # C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông cu·ªëi
    update_session_activity()
    
    # Ki·ªÉm tra quy·ªÅn truy c·∫≠p (ch·ªâ EMPLOYEE c√≥ th·ªÉ x√≥a b·∫£n ghi c·ªßa ch√≠nh m√¨nh)
    has_permission, error_message = check_attendance_access_permission(session['user_id'], attendance_id, 'delete')
    if not has_permission:
        return jsonify({'error': error_message}), 403
    
    att = db.session.get(Attendance, attendance_id)
    if not att:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y b·∫£n ghi'}), 404
    if att.approved:
        return jsonify({'error': 'B·∫£n ghi ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát, kh√¥ng th·ªÉ x√≥a!'}), 400
    try:
        # Log attendance deletion
        log_audit_action(
            user_id=session['user_id'],
            action='DELETE_ATTENDANCE',
            table_name='attendances',
            record_id=attendance_id,
            old_values={
                'date': att.date.isoformat(),
                'check_in': att.check_in.isoformat() if att.check_in else None,
                'check_out': att.check_out.isoformat() if att.check_out else None,
                'status': att.status
            }
        )
        
        db.session.delete(att)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': 'L·ªói khi x√≥a b·∫£n ghi!'}), 500

@app.route('/api/attendance/<int:attendance_id>', methods=['GET'])
def get_attendance(attendance_id):
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    # Ki·ªÉm tra session timeout
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    
    # C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông cu·ªëi
    update_session_activity()
    
    # Ki·ªÉm tra quy·ªÅn truy c·∫≠p
    has_permission, error_message = check_attendance_access_permission(session['user_id'], attendance_id, 'read')
    if not has_permission:
        return jsonify({'error': error_message}), 403
    
    attendance = db.session.get(Attendance, attendance_id)
    if not attendance:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y b·∫£n ghi'}), 404
    
    # L·∫•y th√¥ng tin ng∆∞·ªùi d√πng
    user_info = {
        'name': attendance.user.name if attendance.user else 'Unknown',
        'employee_id': attendance.user.employee_id if attendance.user else 'Unknown',
        'department': attendance.user.department if attendance.user else 'Unknown'
    }
    
    # L·∫•y th√¥ng tin ng∆∞·ªùi ph√™ duy·ªát n·∫øu c√≥
    approver_info = None
    if attendance.approved_by:
        approver = db.session.get(User, attendance.approved_by)
        if approver:
            approver_info = {
                'name': approver.name,
                'employee_id': approver.employee_id,
                'department': approver.department,
                'roles': approver.roles
            }
    
    return jsonify({
        'id': attendance.id,
        'date': attendance.date.strftime('%d/%m/%Y'),
        'check_in': attendance.check_in.strftime('%H:%M') if attendance.check_in else None,
        'check_out': attendance.check_out.strftime('%H:%M') if attendance.check_out else None,
        'break_time': attendance._format_hours_minutes(attendance.break_time),
        'comp_time_regular': attendance._format_minutes_to_hhmm(attendance.comp_time_regular_minutes),
        'comp_time_overtime': attendance._format_minutes_to_hhmm(attendance.comp_time_overtime_minutes),
        'comp_time_ot_before_22': attendance._format_minutes_to_hhmm(attendance.comp_time_ot_before_22_minutes),
        'comp_time_ot_after_22': attendance._format_minutes_to_hhmm(attendance.comp_time_ot_after_22_minutes),
        'overtime_comp_time': attendance._format_minutes_to_hhmm(attendance.overtime_comp_time_minutes),
        'is_holiday': attendance.is_holiday,
        'holiday_type': attendance.holiday_type,
        'note': attendance.note,
        'approved': attendance.approved,
        'status': attendance.status,
        'shift_code': attendance.shift_code,
        'shift_start': attendance.shift_start.strftime('%H:%M') if attendance.shift_start else None,
        'shift_end': attendance.shift_end.strftime('%H:%M') if attendance.shift_end else None,
        'signature': attendance.signature,
        'team_leader_signature': attendance.team_leader_signature,
        'manager_signature': attendance.manager_signature,
        'user_name': user_info['name'],
        'user_employee_id': user_info['employee_id'],
        'user_department': user_info['department'],
        'approver_info': approver_info,
        'approved_at': attendance.approved_at.isoformat() if attendance.approved_at else None,
        # TH√äM: T√≠nh checkout_date t·ª´ check_out datetime
        'checkout_date': attendance.check_out.strftime('%d/%m/%Y') if attendance.check_out else attendance.date.strftime('%d/%m/%Y')
    })

@app.route('/api/attendance/<int:attendance_id>', methods=['PUT'])
def update_attendance(attendance_id):
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    has_permission, error_message = check_attendance_access_permission(session['user_id'], attendance_id, 'update')
    if not has_permission:
        return jsonify({'error': error_message}), 403
    attendance = db.session.get(Attendance, attendance_id)
    if not attendance:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y b·∫£n ghi'}), 404
    if attendance.approved:
        return jsonify({'error': 'B·∫£n ghi ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát, kh√¥ng th·ªÉ s·ª≠a!'}), 400
    data = request.get_json()
    # print('DEBUG signature PUT:', data.get('signature'))  # Th√™m log signature
    # Validate input (defensive): utils.validators raises ValidationError on bad/missing values
    try:
        date = validate_date(data.get('date'))
        holiday_type = validate_holiday_type(data.get('holiday_type'))

        check_in_raw = data.get('check_in')
        check_out_raw = data.get('check_out')
        check_in = validate_time(check_in_raw) if check_in_raw else None
        check_out = validate_time(check_out_raw) if check_out_raw else None

        note = validate_note(data.get('note', ''))

        shift_code = data.get('shift_code')
        shift_start_raw = data.get('shift_start')
        shift_end_raw = data.get('shift_end')
        shift_start = validate_time(shift_start_raw) if shift_start_raw else None
        shift_end = validate_time(shift_end_raw) if shift_end_raw else None
    except ValidationError as e:
        return jsonify({'error': e.message}), 400
    
    # Chuy·ªÉn ƒë·ªïi HH:MM sang float cho c√°c tr∆∞·ªùng th·ªùi gian
    def hhmm_to_float(hhmm_str):
        """Chuy·ªÉn ƒë·ªïi HH:MM sang float (gi·ªù)"""
        if not hhmm_str or hhmm_str == "0:00":
            return 0.0
        try:
            if isinstance(hhmm_str, str) and ':' in hhmm_str:
                hours, minutes = hhmm_str.split(':')
                return float(hours) + float(minutes) / 60.0
            else:
                return float(hhmm_str)
        except (ValueError, TypeError):
            return 0.0
    
    break_time = hhmm_to_float(data.get('break_time', '1:00'))
    comp_time_regular = hhmm_to_float(data.get('comp_time_regular', '0:00'))
    comp_time_overtime = hhmm_to_float(data.get('comp_time_overtime', '0:00'))
    comp_time_ot_before_22 = hhmm_to_float(data.get('comp_time_ot_before_22', '0:00'))
    comp_time_ot_after_22 = hhmm_to_float(data.get('comp_time_ot_after_22', '0:00'))
    overtime_comp_time = hhmm_to_float(data.get('overtime_comp_time', '0:00'))
    is_holiday = bool(data.get('is_holiday', False))
    # holiday_type / shift_* already parsed above
    
    # THAY ƒê·ªîI: S·ª≠ d·ª•ng checkout_date thay v√¨ next_day_checkout flag
    checkout_date_str = data.get('checkout_date')  # DD/MM/YYYY ho·∫∑c YYYY-MM-DD
    checkout_date = None
    if checkout_date_str:
        # Parse checkout_date
        try:
            if '/' in checkout_date_str:
                # DD/MM/YYYY format
                d, m, y = checkout_date_str.split('/')
                checkout_date = datetime.strptime(f"{y}-{m.zfill(2)}-{d.zfill(2)}", '%Y-%m-%d').date()
            else:
                # YYYY-MM-DD format
                checkout_date = datetime.strptime(checkout_date_str, '%Y-%m-%d').date()
        except (ValueError, AttributeError):
            # Fallback: s·ª≠ d·ª•ng date (ng√†y v√†o)
            checkout_date = date
    else:
        # N·∫øu kh√¥ng c√≥ checkout_date, d√πng date (ng√†y v√†o)
        checkout_date = date

    if checkout_date and checkout_date < date:
        return jsonify({'error': 'Ng√†y ra kh√¥ng ƒë∆∞·ª£c nh·ªè h∆°n ng√†y v√†o'}), 400
    
    # L·∫•y th√¥ng tin user tr∆∞·ªõc khi s·ª≠ d·ª•ng
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    # T·ª± ƒë·ªông l·∫•y ch·ªØ k√Ω t·ª´ database khi c·∫≠p nh·∫≠t
    signature = data.get('signature', '')
    
    # N·∫øu kh√¥ng c√≥ ch·ªØ k√Ω ho·∫∑c ch·ªØ k√Ω r·ªóng, l·∫•y t·ª´ database
    if not signature:
        auto_signature = signature_manager.get_signature_from_database(user.id, 'EMPLOYEE')
        if auto_signature:
            signature = auto_signature
            attendance.signature = signature
            # print(f"‚úÖ AUTO SIGNATURE UPDATE: User {user.name} using signature from database")
        else:
            pass  # Kh√¥ng c√≤n log debug
    else:
        # N·∫øu c√≥ ch·ªØ k√Ω m·ªõi, c·∫≠p nh·∫≠t
        attendance.signature = signature
        # Kh√¥ng c√≤n log debug
    
    if not holiday_type:
        return jsonify({'error': 'Vui l√≤ng ch·ªçn lo·∫°i ng√†y h·ª£p l·ªá'}), 400
    # Cho ph√©p l·ªÖ Vi·ªát Nam kh√¥ng c·∫ßn nh·∫≠p gi·ªù v√†o/ra (nh√¢n vi√™n ƒë∆∞·ª£c 8h m·∫∑c ƒë·ªãnh)
    if holiday_type != 'vietnamese_holiday' and (not check_in or not check_out):
        return jsonify({'error': 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß gi·ªù v√†o v√† gi·ªù ra h·ª£p l·ªá'}), 400
    if break_time is None:
        return jsonify({'error': 'Th·ªùi gian ngh·ªâ kh√¥ng h·ª£p l·ªá!'}), 400
    if comp_time_regular is None:
        return jsonify({'error': 'Gi·ªù ƒë·ªëi ·ª©ng trong ca kh√¥ng h·ª£p l·ªá!'}), 400
    if comp_time_overtime is None:
        return jsonify({'error': 'Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca kh√¥ng h·ª£p l·ªá!'}), 400
    if comp_time_ot_before_22 is None or comp_time_ot_after_22 is None:
        return jsonify({'error': 'Gi·ªù ƒë·ªëi ·ª©ng tƒÉng ca theo m·ªëc (tr∆∞·ªõc/sau 22h) kh√¥ng h·ª£p l·ªá!'}), 400
    
    # Validation: Ki·ªÉm tra xem c√≥ tƒÉng ca hay kh√¥ng tr∆∞·ªõc khi cho ph√©p ƒë·ªëi ·ª©ng tƒÉng ca
    is_valid, error_message = validate_overtime_comp_time(
        check_in, check_out, shift_start, shift_end, break_time, 
        comp_time_regular, comp_time_overtime, comp_time_ot_before_22, comp_time_ot_after_22,
        date, checkout_date, holiday_type, shift_code
    )
    if not is_valid:
        return jsonify({'error': error_message}), 400
    
    # L·ªÖ Vi·ªát Nam kh√¥ng ƒëi l√†m: kh√¥ng c·∫ßn shift_code, shift_start, shift_end
    if holiday_type != 'vietnamese_holiday' and (not shift_code or not shift_start or not shift_end):
        return jsonify({'error': 'Vui l√≤ng ch·ªçn ca l√†m vi·ªác h·ª£p l·ªá!'}), 400
    
    # Ki·ªÉm tra xem c√≥ b·∫£n ghi kh√°c c√πng ng√†y kh√¥ng (tr·ª´ b·∫£n ghi hi·ªán t·∫°i)
    
    existing_attendance = Attendance.query.filter(
        Attendance.user_id == user.id,
        Attendance.date == date,
        Attendance.id != attendance_id
    ).first()
    
    if existing_attendance:
        if existing_attendance.status != 'rejected':
            return jsonify({'error': 'B·∫°n ƒë√£ ch·∫•m c√¥ng cho ng√†y n√†y r·ªìi, kh√¥ng th·ªÉ ch·∫•m c√¥ng 2 l·∫ßn trong 1 ng√†y.'}), 400
        else:
            db.session.delete(existing_attendance)
            db.session.commit()
    
    attendance.date = date
    attendance.check_in = datetime.combine(date, check_in)
    
    # THAY ƒê·ªîI: S·ª≠ d·ª•ng checkout_date thay v√¨ next_day_checkout
    # K·∫øt h·ª£p checkout_date v·ªõi check_out time
    attendance.check_out = datetime.combine(checkout_date, check_out)
    
    attendance.note = note
    attendance.break_time = break_time
    attendance.comp_time_regular_minutes = int(round(comp_time_regular * 60)) if comp_time_regular else 0
    attendance.comp_time_overtime_minutes = int(round(comp_time_overtime * 60)) if comp_time_overtime else 0
    attendance.comp_time_ot_before_22_minutes = int(round(comp_time_ot_before_22 * 60)) if comp_time_ot_before_22 else 0
    attendance.comp_time_ot_after_22_minutes = int(round(comp_time_ot_after_22 * 60)) if comp_time_ot_after_22 else 0
    attendance.overtime_comp_time_minutes = int(round(overtime_comp_time * 60)) if overtime_comp_time else 0
    attendance.is_holiday = is_holiday
    attendance.holiday_type = holiday_type
    attendance.shift_code = shift_code
    attendance.shift_start = shift_start
    attendance.shift_end = shift_end
    if attendance.status == 'rejected':
        attendance.status = 'pending'
    if date > datetime.now().date():
        return jsonify({'error': 'Kh√¥ng th·ªÉ ch·∫•m c√¥ng cho ng√†y trong t∆∞∆°ng lai!'}), 400
    attendance.update_work_hours()
    try:
        db.session.commit()
        log_audit_action(
            user_id=session['user_id'],
            action='UPDATE_ATTENDANCE',
            table_name='attendances',
            record_id=attendance_id,
            old_values={
                'date': attendance.date.isoformat(),
                'check_in': attendance.check_in.isoformat() if attendance.check_in else None,
                'check_out': attendance.check_out.isoformat() if attendance.check_out else None,
                'status': attendance.status
            },
            new_values={
                'date': date.isoformat(),
                'check_in': datetime.combine(date, check_in).isoformat(),
                'check_out': attendance.check_out.isoformat(),
                'status': attendance.status
            }
        )
        message = 'C·∫≠p nh·∫≠t ch·∫•m c√¥ng th√†nh c√¥ng'
        return jsonify({
            'message': message,
            'work_hours': attendance.total_work_hours,
            'overtime_before_22': attendance.overtime_before_22,
            'overtime_after_22': attendance.overtime_after_22
        })
    except Exception as e:
        # print(f"Database error: {str(e)}")
        db.session.rollback()
        return jsonify({'error': 'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t d·ªØ li·ªáu'}), 500

@app.route('/api/signature/check', methods=['POST'])
def check_signature_status():
    """API ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i ch·ªØ k√Ω cho ph√™ duy·ªát"""
    # print(f"DEBUG: check_signature_status called with data: {request.get_json()}")
    
    if 'user_id' not in session:
        # print("DEBUG: No user_id in session")
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        # print("DEBUG: Session timeout")
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    
    data = request.get_json()
    attendance_id = data.get('attendance_id')
    request_id = data.get('request_id')
    check_session = data.get('check_session', False)
    current_role = session.get('current_role')
    user_id = session['user_id']
    
    # N·∫øu ch·ªâ ki·ªÉm tra session signature
    if check_session:
        session_signature, session_meta = signature_manager.get_signature_from_session(user_id, current_role)
        return jsonify({
            'session_signature': session_signature if session_signature else None
        })
    
    # S·ª≠ d·ª•ng Signature Manager ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i
    signature_status = signature_manager.check_signature_status(user_id, current_role, attendance_id)
    return jsonify(signature_status)

@app.route('/api/signature/validate-quality', methods=['POST'])
def validate_signature_quality():
    """È™åËØÅÁ≠æÂêçË¥®Èáè"""
    if 'user_id' not in session:
        return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p'}), 401
    
    data = request.get_json()
    signature = data.get('signature')
    
    if not signature:
        return jsonify({
            'valid': False,
            'error': 'Kh√¥ng c√≥ d·ªØ li·ªáu ch·ªØ k√Ω'
        })
    
    # ‰ΩøÁî®Á≠æÂêçÂ§ÑÁêÜÂô®È™åËØÅË¥®Èáè
    quality_result = signature_manager.validate_signature_quality(signature)
    
    return jsonify(quality_result)

@app.route('/api/signature/fit-to-form', methods=['POST'])
def fit_signature_to_form():
    """ƒêi·ªÅu ch·ªânh ch·ªØ k√Ω v·ª´a kh√≠t v·ªõi √¥ k√Ω trong bi·ªÉu m·∫´u"""
    if 'user_id' not in session:
        return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p'}), 401
    
    data = request.get_json()
    signature = data.get('signature')
    box_type = data.get('box_type', 'default')
    
    if not signature:
        return jsonify({
            'success': False,
            'error': 'Kh√¥ng c√≥ d·ªØ li·ªáu ch·ªØ k√Ω'
        })
    
    # ƒêi·ªÅu ch·ªânh ch·ªØ k√Ω v·ª´a kh√≠t v·ªõi √¥
    fitted_signature = signature_manager.fit_signature_to_form_box(signature, box_type)
    
    # Ki·ªÉm tra xem c√≥ v·ª´a kh√¥ng
    fit_result = signature_manager.validate_signature_fit(signature, box_type)
    
    return jsonify({
        'success': True,
        'fitted_signature': fitted_signature,
        'fit_result': fit_result
    })

@app.route('/api/signature/create-form-signatures', methods=['POST'])
def create_form_signatures():
    """T·∫°o ch·ªØ k√Ω cho to√†n b·ªô bi·ªÉu m·∫´u"""
    if 'user_id' not in session:
        return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p'}), 401
    
    data = request.get_json()
    signatures = data.get('signatures', {})
    
    if not signatures:
        return jsonify({
            'success': False,
            'error': 'Kh√¥ng c√≥ d·ªØ li·ªáu ch·ªØ k√Ω'
        })
    
    # T·∫°o ch·ªØ k√Ω cho to√†n b·ªô bi·ªÉu m·∫´u
    form_signatures = signature_manager.create_form_signatures(signatures)
    
    return jsonify({
        'success': True,
        'form_signatures': form_signatures
    })

@app.route('/api/signature/save-session', methods=['POST'])
def save_signature_to_session():
    """API ƒë·ªÉ l∆∞u ch·ªØ k√Ω v√†o session"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    
    data = request.get_json()
    signature = data.get('signature')
    signature_type = data.get('type', 'new')  # 'new', 'reused', 'session_reused', 'database_reused'
    dont_ask_again = data.get('dont_ask_again', False)
    
    if not signature:
        return jsonify({'error': 'Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá'}), 400
    
    current_role = session.get('current_role')
    user_id = session['user_id']
    
    # L∆∞u ch·ªØ k√Ω v√†o session v·ªõi flag don't ask again
    success = signature_manager.save_signature_to_session(
        user_id, current_role, signature, signature_type, dont_ask_again
    )
    
    if success:
        # Ghi log chi ti·∫øt
        signature_manager.log_signature_action(
            user_id=user_id,
            action='SAVE_SESSION',
            signature_type=signature_type,
            additional_data={'dont_ask_again': dont_ask_again}
        )
        
        message = 'ƒê√£ l∆∞u ch·ªØ k√Ω v√†o phi√™n'
        if dont_ask_again:
            message += ' v√† ƒë·∫∑t kh√¥ng h·ªèi l·∫°i trong phi√™n n√†y'
        
        return jsonify({'success': True, 'message': message})
    else:
        return jsonify({'error': 'Kh√¥ng th·ªÉ l∆∞u ch·ªØ k√Ω'}), 500

@app.route('/api/signature/clear-session', methods=['POST'])
def clear_session_signature():
    """API ƒë·ªÉ x√≥a ch·ªØ k√Ω kh·ªèi session"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    
    current_role = session.get('current_role')
    user_id = session['user_id']
    
    success = signature_manager.clear_session_signature(user_id, current_role)
    
    if success:
        return jsonify({'success': True, 'message': 'ƒê√£ x√≥a ch·ªØ k√Ω kh·ªèi phi√™n'})
    else:
        return jsonify({'error': 'Kh√¥ng th·ªÉ x√≥a ch·ªØ k√Ω'}), 500

@app.route('/api/attendance/<int:attendance_id>/approve', methods=['POST'])
@rate_limit(max_requests=200, window_seconds=60)
def approve_attendance(attendance_id):
    """Ph√™ duy·ªát ch·∫•m c√¥ng - ƒê√É T·ªêI ∆ØU: Database commit tr∆∞·ªõc, Google Sheet background"""
    import sys
    from datetime import datetime as dt
    
    # Log b·∫Øt ƒë·∫ßu
    timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
    try:
        print(f"\n{'='*80}", flush=True, file=sys.stderr)
        print(f"üöÄ [APPROVE_START] {timestamp} - B·∫Øt ƒë·∫ßu ph√™ duy·ªát attendance ID: {attendance_id}", flush=True, file=sys.stderr)
        print(f"{'='*80}", flush=True, file=sys.stderr)
    except Exception:
        pass
    
    # Ki·ªÉm tra session
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    
    # L·∫•y user
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    current_role = session.get('current_role', user.roles.split(',')[0])
    if current_role not in ['TEAM_LEADER', 'MANAGER', 'ADMIN']:
        return jsonify({'error': 'B·∫°n kh√¥ng c√≥ quy·ªÅn ph√™ duy·ªát ch·∫•m c√¥ng'}), 403
    
    # Ki·ªÉm tra quy·ªÅn
    has_permission, error_message = check_approval_permission(user.id, attendance_id, current_role)
    if not has_permission:
        return jsonify({'error': error_message}), 403
    
    # L·∫•y d·ªØ li·ªáu
    data = request.get_json()
    action = data.get('action')
    reason = validate_reason(data.get('reason', '')) if data.get('action') == 'reject' else ''
    approver_signature = data.get('signature')
    
    if action not in ['approve', 'reject']:
        return jsonify({'error': 'H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá'}), 400
    
    # L·∫•y attendance
    attendance = db.session.get(Attendance, attendance_id)
    if not attendance:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y b·∫£n ghi ch·∫•m c√¥ng'}), 404

    # B3: Optimistic locking - get expected version from request
    expected_version = data.get('version')

    try:
        # X·ª¨ L√ù PH√ä DUY·ªÜT
        if action == 'approve':
            # X·ª≠ l√Ω ch·ªØ k√Ω
            if current_role == 'ADMIN':
                approver_signature = None
                signature_type = 'admin_no_signature'
            else:
                if not user.has_personal_signature():
                    return jsonify({
                        'error': 'B·∫°n ch∆∞a c√≥ ch·ªØ k√Ω c√° nh√¢n. Vui l√≤ng thi·∫øt l·∫≠p ch·ªØ k√Ω trong ph·∫ßn C√†i ƒë·∫∑t tr∆∞·ªõc khi ph√™ duy·ªát.',
                        'redirect_to_settings': True
                    }), 400
                
                if user.has_personal_signature():
                    approver_signature = user.personal_signature
                    signature_type = 'personal_signature'
                else:
                    session_signature, session_meta = signature_manager.get_signature_from_session(user.id, current_role)
                    if session_signature and signature_manager.should_use_session_signature(user.id, current_role):
                        approver_signature = session_signature
                        signature_type = 'session_reused'
                    else:
                        db_signature = signature_manager.get_signature_from_database(user.id, current_role, attendance_id)
                        if db_signature:
                            approver_signature = db_signature
                            signature_type = 'database_reused'
                        elif approver_signature:
                            signature_type = 'new'
                        else:
                            return jsonify({'error': 'Ch·ªØ k√Ω l√† b·∫Øt bu·ªôc khi ph√™ duy·ªát. Vui l√≤ng k√Ω t√™n ƒë·ªÉ x√°c nh·∫≠n.'}), 400
            
            old_status = attendance.status

            # B3: Optimistic locking check - prevent race conditions in approval
            if expected_version is not None:
                current_version = getattr(attendance, 'version', 1) or 1
                if current_version != expected_version:
                    return jsonify({
                        'error': 'B·∫£n ghi ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·ªüi ng∆∞·ªùi kh√°c. Vui l√≤ng t·∫£i l·∫°i trang v√† th·ª≠ l·∫°i.',
                        'error_code': 'version_conflict',
                        'current_version': current_version
                    }), 409

            # C·∫≠p nh·∫≠t theo vai tr√≤
            if current_role == 'TEAM_LEADER':
                if attendance.status != 'pending':
                    return jsonify({'error': 'B·∫£n ghi kh√¥ng ·ªü tr·∫°ng th√°i ch·ªù duy·ªát'}), 400
                attendance.status = 'pending_manager'
                attendance.approved_by = user.id
                attendance.approved_at = datetime.now()
                if approver_signature:
                    attendance.team_leader_signature = approver_signature
                attendance.team_leader_signer_id = user.id
                # B3: Increment version on status change
                attendance.version = (getattr(attendance, 'version', 1) or 1) + 1
                message = 'ƒê√£ chuy·ªÉn l√™n Qu·∫£n l√Ω ph√™ duy·ªát'

            elif current_role == 'MANAGER':
                if attendance.status != 'pending_manager':
                    return jsonify({'error': 'B·∫£n ghi ch∆∞a ƒë∆∞·ª£c Tr∆∞·ªüng nh√≥m ph√™ duy·ªát'}), 400
                attendance.status = 'pending_admin'
                attendance.approved_by = user.id
                attendance.approved_at = datetime.now()
                if approver_signature:
                    attendance.manager_signature = approver_signature
                attendance.manager_signer_id = user.id
                # B3: Increment version on status change
                attendance.version = (getattr(attendance, 'version', 1) or 1) + 1
                message = 'ƒê√£ ph√™ duy·ªát th√†nh c√¥ng'

            elif current_role == 'ADMIN':
                # Admin c√≥ th·ªÉ ph√™ duy·ªát t·∫•t c·∫£ tr·∫°ng th√°i ch·ªù duy·ªát: pending, pending_manager, pending_admin
                if attendance.status not in ['pending', 'pending_manager', 'pending_admin']:
                    return jsonify({'error': 'B·∫£n ghi kh√¥ng ·ªü tr·∫°ng th√°i ch·ªù duy·ªát'}), 400
                
                # Check Google API token tr∆∞·ªõc khi ADMIN approve
                token_status = check_google_token_status()
                if not token_status.get('can_approve', False):
                    # Publish notification to all admins
                    publish_token_status('expired', token_status.get('message', 'Token h·∫øt h·∫°n'), needs_reauth=True)
                    return jsonify({
                        'error': f"‚ö†Ô∏è Token Google API h·∫øt h·∫°n. {token_status.get('message', 'Vui l√≤ng refresh token tr∆∞·ªõc khi ph√™ duy·ªát.')}",
                        'error_code': 'token_expired',
                        'needs_reauth': True
                    }), 503
                
                # L∆∞u ch·ªØ k√Ω tr∆∞·ªüng nh√≥m n·∫øu tr·∫°ng th√°i l√† pending v√† c√≥ ch·ªØ k√Ω
                if attendance.status == 'pending' and user.has_personal_signature():
                    attendance.team_leader_signature = user.personal_signature
                    attendance.team_leader_signer_id = user.id
                
                # L∆∞u ch·ªØ k√Ω qu·∫£n l√Ω n·∫øu tr·∫°ng th√°i l√† pending_manager v√† c√≥ ch·ªØ k√Ω
                if attendance.status == 'pending_manager' and user.has_personal_signature():
                    attendance.manager_signature = user.personal_signature
                    attendance.manager_signer_id = user.id
                
                # L∆∞u ch·ªØ k√Ω qu·∫£n l√Ω n·∫øu tr·∫°ng th√°i l√† pending_admin v√† c√≥ ch·ªØ k√Ω
                if attendance.status == 'pending_admin' and user.has_personal_signature():
                    attendance.manager_signature = user.personal_signature
                    attendance.manager_signer_id = user.id
                
                # Store original status for potential rollback
                original_status = attendance.status
                
                # L∆∞u ch·ªØ k√Ω tr∆∞·ªüng nh√≥m n·∫øu tr·∫°ng th√°i l√† pending v√† c√≥ ch·ªØ k√Ω
                if attendance.status == 'pending' and user.has_personal_signature():
                    attendance.team_leader_signature = user.personal_signature
                    attendance.team_leader_signer_id = user.id
                
                # L∆∞u ch·ªØ k√Ω qu·∫£n l√Ω n·∫øu tr·∫°ng th√°i l√† pending_manager v√† c√≥ ch·ªØ k√Ω
                if attendance.status == 'pending_manager' and user.has_personal_signature():
                    attendance.manager_signature = user.personal_signature
                    attendance.manager_signer_id = user.id
                
                # L∆∞u ch·ªØ k√Ω qu·∫£n l√Ω n·∫øu tr·∫°ng th√°i l√† pending_admin v√† c√≥ ch·ªØ k√Ω
                if attendance.status == 'pending_admin' and user.has_personal_signature():
                    attendance.manager_signature = user.personal_signature
                    attendance.manager_signer_id = user.id
                
                # ===== CHU·∫®N B·ªä D·ªÆ LI·ªÜU CHO GOOGLE SHEET =====
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                try:
                    print(f"\n{'='*80}", flush=True, file=sys.stderr)
                    print(f"üîµ [ADMIN_APPROVE] {timestamp} - ADMIN ƒëang ph√™ duy·ªát", flush=True, file=sys.stderr)
                    print(f"   Attendance ID: {attendance_id}", flush=True, file=sys.stderr)
                    print(f"   User: {attendance.user.name if attendance.user else 'Unknown'}", flush=True, file=sys.stderr)
                    print(f"   Original Status: {original_status}", flush=True, file=sys.stderr)
                    print(f"{'='*80}", flush=True, file=sys.stderr)
                except Exception:
                    pass
                
                # VALIDATION: Ki·ªÉm tra user
                if not attendance.user:
                    error_msg = "‚ùå Attendance kh√¥ng c√≥ th√¥ng tin user"
                    try:
                        print(f"[VALIDATION_ERROR] {error_msg}", flush=True, file=sys.stderr)
                    except Exception:
                        pass
                    return jsonify({'error': error_msg}), 400
                
                employee_team = attendance.user.department if attendance.user.department else None
                employee_id = attendance.user.employee_id if attendance.user.employee_id else None
                
                # Fallback for employee_id
                if not employee_id:
                    employee_id = str(attendance.user.id) if attendance.user.id else attendance.user.name
                    try:
                        print(f"‚ö†Ô∏è [FALLBACK] S·ª≠ d·ª•ng fallback employee_id: {employee_id}", flush=True, file=sys.stderr)
                    except Exception:
                        pass
                
                # Fallback for team
                if not employee_team or employee_team == "Unknown":
                    employee_team = getattr(attendance.user, 'team', None) or "Unknown"
                    try:
                        print(f"‚ö†Ô∏è [FALLBACK] S·ª≠ d·ª•ng fallback team: {employee_team}", flush=True, file=sys.stderr)
                    except Exception:
                        pass
                
                # Prepare attendance data
                break_time_value = attendance._format_hours_minutes(attendance.break_time) if attendance.break_time else '0:00'
                note_value = attendance.note if attendance.note else ''
                
                comp_time_regular_value = attendance._format_minutes_to_hhmm(attendance.comp_time_regular_minutes)
                comp_time_overtime_value = attendance._format_minutes_to_hhmm(attendance.comp_time_overtime_minutes)
                comp_time_ot_before_22_value = attendance._format_minutes_to_hhmm(attendance.comp_time_ot_before_22_minutes)
                comp_time_ot_after_22_value = attendance._format_minutes_to_hhmm(attendance.comp_time_ot_after_22_minutes)
                overtime_comp_time_value = attendance._format_minutes_to_hhmm(attendance.overtime_comp_time_minutes)
                
                overtime_before_22_val = attendance.overtime_before_22 or '0:00'
                overtime_after_22_val = attendance.overtime_after_22 or '0:00'
                
                # Calculate total comp time
                def hhmm_to_minutes_safe(v):
                    try:
                        if not v or v in ['0', '0:00']:
                            return 0
                        if isinstance(v, str) and ':' in v:
                            h, m = v.split(':', 1)
                            return int(h or '0') * 60 + int(m or '0')
                    except Exception:
                        pass
                    return 0
                
                total_comp_minutes = (
                    hhmm_to_minutes_safe(comp_time_regular_value) +
                    hhmm_to_minutes_safe(comp_time_ot_before_22_value) +
                    hhmm_to_minutes_safe(comp_time_ot_after_22_value) +
                    hhmm_to_minutes_safe(comp_time_overtime_value) +
                    hhmm_to_minutes_safe(overtime_comp_time_value)
                )
                total_comp_display = f"{total_comp_minutes // 60}:{total_comp_minutes % 60:02d}"
                
                doi_ung_parts = []
                if comp_time_regular_value not in [None, '', 0, '0', '0:00']:
                    doi_ung_parts.append(f"B√π gi·ªù th∆∞·ªùng: {comp_time_regular_value}")
                if comp_time_overtime_value not in [None, '', 0, '0', '0:00']:
                    doi_ung_parts.append(f"B√π gi·ªù tƒÉng ca: {comp_time_overtime_value}")
                if comp_time_ot_before_22_value not in [None, '', 0, '0', '0:00']:
                    doi_ung_parts.append(f"B√π OT <22h: {comp_time_ot_before_22_value}")
                if comp_time_ot_after_22_value not in [None, '', 0, '0', '0:00']:
                    doi_ung_parts.append(f"B√π OT >22h: {comp_time_ot_after_22_value}")
                if overtime_comp_time_value not in [None, '', 0, '0', '0:00']:
                    doi_ung_parts.append(f"ƒê·ªëi ·ª©ng OT: {overtime_comp_time_value}")
                
                doi_ung_summary = f"{total_comp_display} [ " + ' | '.join(doi_ung_parts) + " ]" if doi_ung_parts else total_comp_display
                
                regular_work_display = attendance._format_hours_minutes(attendance.calculate_regular_work_hours())
                total_hours_value = getattr(attendance, 'total_hours', None) or getattr(attendance, 'total_work_hours', '')
                
                def to_hhmm_from_decimal(hours_val):
                    try:
                        if hours_val is None or hours_val == '':
                            return ''
                        if isinstance(hours_val, str):
                            if ':' in hours_val:
                                return hours_val
                            hours_float = float(hours_val)
                        else:
                            hours_float = float(hours_val)
                        total_minutes = int(round(hours_float * 60))
                        return f"{total_minutes // 60}:{total_minutes % 60:02d}"
                    except Exception:
                        return str(hours_val)
                
                total_hours_display = to_hhmm_from_decimal(total_hours_value)
                
                attendance_data = {
                    'id': attendance.id,
                    'user_name': attendance.user.name if attendance.user else 'Unknown',
                    'date': attendance.date.strftime('%Y-%m-%d') if attendance.date else '',
                    'check_in': attendance.check_in.strftime('%H:%M') if attendance.check_in else '',
                    'check_out': attendance.check_out.strftime('%H:%M') if attendance.check_out else '',
                    'total_hours': total_hours_display,
                    'regular_work_hours': regular_work_display,
                    'break_time': break_time_value,
                    'overtime_before_22': overtime_before_22_val,
                    'overtime_after_22': overtime_after_22_val,
                    'comp_time_regular': comp_time_regular_value,
                    'comp_time_overtime': comp_time_overtime_value,
                    'comp_time_ot_before_22': comp_time_ot_before_22_value,
                    'comp_time_ot_after_22': comp_time_ot_after_22_value,
                    'overtime_comp_time': overtime_comp_time_value,
                    'note': note_value,
                    'doi_ung': doi_ung_summary,
                    'doi_ung_total': total_comp_display,
                    'status': 'approved',  # Will be approved if Google Sheet succeeds
                    'approved_by': user.name,
                    'approved_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'holiday_type': attendance.holiday_type if hasattr(attendance, 'holiday_type') else None,
                    'is_holiday': attendance.is_holiday if hasattr(attendance, 'is_holiday') else False
                }
                
                # ===== ƒê·ªíNG B·ªò C·∫¨P NH·∫¨T GOOGLE SHEET TR∆Ø·ªöC KHI COMMIT DATABASE =====
                try:
                    print(f"üöÄ [SYNC_SHEET_START] B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t Google Sheet ƒê·ªíNG B·ªò...", flush=True, file=sys.stderr)
                except Exception:
                    pass
                
                sheet_success, sheet_error = update_google_sheet_sync(
                    attendance_id=attendance_id,
                    employee_team=employee_team,
                    employee_id=employee_id,
                    attendance_data=attendance_data
                )
                
                if sheet_success:
                    # ===== GOOGLE SHEET TH√ÄNH C√îNG - COMMIT AS APPROVED =====
                    try:
                        print(f"‚úÖ [SHEET_SUCCESS] Google Sheet c·∫≠p nh·∫≠t th√†nh c√¥ng!", flush=True, file=sys.stderr)
                        print(f"üíæ [DB_COMMIT] ƒêang commit database v·ªõi status = 'approved'...", flush=True, file=sys.stderr)
                    except Exception:
                        pass
                    
                    attendance.status = 'approved'
                    attendance.approved = True
                    attendance.approved_by = user.id
                    attendance.approved_at = datetime.now()
                    # B3: Increment version on final approval
                    attendance.version = (getattr(attendance, 'version', 1) or 1) + 1
                    message = 'Ph√™ duy·ªát ho√†n t·∫•t v√† ƒë√£ c·∫≠p nh·∫≠t l√™n Google Sheet th√†nh c√¥ng'
                    
                else:
                    # ===== GOOGLE SHEET TH·∫§T B·∫†I - ROLLBACK TO pending_manager =====
                    try:
                        print(f"‚ùå [SHEET_FAILED] Google Sheet c·∫≠p nh·∫≠t th·∫•t b·∫°i!", flush=True, file=sys.stderr)
                        print(f"   Error: {sheet_error}", flush=True, file=sys.stderr)
                        print(f"üîÑ [ROLLBACK] Keeping status as '{original_status}'...", flush=True, file=sys.stderr)
                    except Exception:
                        pass
                    
                    # Keep status at current level (pending_manager or pending_admin)
                    # Do NOT mark as approved
                    # Clear approval fields so admin can retry
                    attendance.approved = False
                    attendance.approved_by = None
                    attendance.approved_at = None
                    
                    # Preserve signatures if already added above
                    # (they will be re-used when admin retries)
                    
                    # Commit the rollback state
                    try:
                        db.session.commit()
                        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                        try:
                            print(f"üíæ [ROLLBACK_COMMIT] {timestamp} - Database rolled back to '{attendance.status}'", flush=True, file=sys.stderr)
                            print(f"{'='*80}\n", flush=True, file=sys.stderr)
                        except Exception:
                            pass
                    except Exception as commit_error:
                        db.session.rollback()
                        try:
                            print(f"‚ùå [ROLLBACK_ERROR] L·ªói commit rollback: {str(commit_error)}", flush=True, file=sys.stderr)
                        except Exception:
                            pass
                        return jsonify({'error': 'L·ªói l∆∞u database'}), 500
                    
                    # Return error to user with specific message
                    error_response = {
                        'error': f'‚ö†Ô∏è Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t Google Sheet: {sheet_error}',
                        'error_detail': sheet_error,
                        'attendance_id': attendance_id,
                        'current_status': attendance.status,
                        'message': f'B·∫£n ghi v·∫´n ·ªü tr·∫°ng th√°i "{original_status}". Vui l√≤ng kh·∫Øc ph·ª•c l·ªói v√† th·ª≠ ph√™ duy·ªát l·∫°i.'
                    }
                    try:
                        print(f"üì§ [ERROR_RESPONSE] Tr·∫£ v·ªÅ l·ªói cho client", flush=True, file=sys.stderr)
                        print(f"   Status ƒë∆∞·ª£c gi·ªØ: {attendance.status}", flush=True, file=sys.stderr)
                        print(f"{'='*80}\n", flush=True, file=sys.stderr)
                    except Exception:
                        pass
                    
                    return jsonify(error_response), 400

            
            # Log audit
            log_audit_action(
                user_id=user.id,
                action='APPROVE_ATTENDANCE',
                table_name='attendances',
                record_id=attendance_id,
                old_values={'status': old_status},
                new_values={'status': attendance.status, 'approved_by': user.id, 'approved_at': attendance.approved_at.isoformat()}
            )
            
            # Log ch·ªØ k√Ω n·∫øu c√≥
            if approver_signature and current_role != 'ADMIN':
                signature_manager.log_signature_action(
                    user_id=user.id,
                    action='APPROVAL',
                    signature_type=signature_type if 'signature_type' in locals() else 'new',
                    attendance_id=attendance_id,
                    additional_data={
                        'approver_role': current_role,
                        'approver_name': user.name,
                        'approval_status': attendance.status
                    }
                )
        
        else:  # reject
            old_status = attendance.status
            attendance.status = 'rejected'
            attendance.note = f"B·ªã t·ª´ ch·ªëi b·ªüi {current_role}: {reason}"
            message = 'T·ª´ ch·ªëi th√†nh c√¥ng'
            
            log_audit_action(
                user_id=user.id,
                action='REJECT_ATTENDANCE',
                table_name='attendances',
                record_id=attendance_id,
                old_values={'status': old_status},
                new_values={'status': attendance.status, 'reason': reason}
            )
        
        # Commit cho TEAM_LEADER v√† MANAGER (ADMIN ƒë√£ commit tr∆∞·ªõc ƒë√≥)
        if current_role in ['TEAM_LEADER', 'MANAGER']:
            try:
                db.session.commit()
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                try:
                    print(f"‚úÖ [{current_role}_COMMIT] {timestamp} - Database committed", flush=True, file=sys.stderr)
                except Exception:
                    pass
            except Exception as e:
                db.session.rollback()
                timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                try:
                    print(f"‚ùå [{current_role}_COMMIT_ERROR] {timestamp} - Error: {e}", flush=True, file=sys.stderr)
                except Exception:
                    pass
                return jsonify({'error': 'L·ªói l∆∞u database'}), 500
        
        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        try:
            print(f"\n{'='*80}", flush=True, file=sys.stderr)
            print(f"‚úÖ [APPROVE_SUCCESS] {timestamp} - Ph√™ duy·ªát th√†nh c√¥ng!", flush=True, file=sys.stderr)
            print(f"   User: {user.name} ({current_role})", flush=True, file=sys.stderr)
            print(f"   Attendance ID: {attendance_id}", flush=True, file=sys.stderr)
            print(f"   New Status: {attendance.status}", flush=True, file=sys.stderr)
            print(f"{'='*80}\n", flush=True, file=sys.stderr)
        except Exception:
            pass
        
        return jsonify({'message': message})
        
    except ValidationError as ve:
        db.session.rollback()
        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        try:
            print(f"‚ùå [VALIDATION_ERROR] {timestamp} - {ve.message}", flush=True, file=sys.stderr)
        except Exception:
            pass
        return jsonify({'error': ve.message}), 400
        
    except SQLAlchemyError as se:
        db.session.rollback()
        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        try:
            print(f"‚ùå [DB_ERROR] {timestamp} - {str(se)}", flush=True, file=sys.stderr)
        except Exception:
            pass
        return jsonify({'error': 'L·ªói c∆° s·ªü d·ªØ li·ªáu'}), 500
        
    except Exception as e:
        db.session.rollback()
        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        try:
            import traceback
            print(f"\n{'='*80}", flush=True, file=sys.stderr)
            print(f"‚ùå [APPROVE_ERROR] {timestamp} - L·ªói kh√¥ng mong mu·ªën", flush=True, file=sys.stderr)
            print(f"   Error: {str(e)}", flush=True, file=sys.stderr)
            print(f"   Type: {type(e).__name__}", flush=True, file=sys.stderr)
            print(f"   Traceback:", flush=True, file=sys.stderr)
            print(traceback.format_exc(), flush=True, file=sys.stderr)
            print(f"{'='*80}\n", flush=True, file=sys.stderr)
        except Exception:
            pass
        return jsonify({'error': f'L·ªói h·ªá th·ªëng: {str(e)}'}), 500

@app.route('/test-google-api')
@require_admin
def test_google_api():
    """Test endpoint ƒë·ªÉ ki·ªÉm tra Google API"""
    try:
        google_api = GoogleDriveAPI()
        
        result = {
            'sheets_service_available': bool(google_api.sheets_service),
            'drive_service_available': bool(google_api.drive_service),
            'creds_exists': bool(google_api.creds),
            'creds_valid': google_api.creds.valid if google_api.creds else False,
            'creds_expired': google_api.creds.expired if google_api.creds else None,
            'has_refresh_token': bool(google_api.creds.refresh_token) if google_api.creds else False
        }
        
        # Test list files
        try:
            if google_api.drive_service:
                results = google_api.drive_service.files().list(pageSize=1).execute()
                result['can_list_files'] = True
                result['test_list_success'] = True
            else:
                result['can_list_files'] = False
                result['test_list_success'] = False
        except Exception as e:
            result['can_list_files'] = False
            result['test_list_error'] = str(e)
        
        return jsonify(result)
        
    except Exception as e:
        return jsonify({
            'error': str(e),
            'error_type': type(e).__name__
        }), 500


def translate_holiday_type(holiday_type_en):
    """Translates holiday type from English to Vietnamese."""
    if not holiday_type_en:
        return '-'
    translations = {
        'normal': 'Ng√†y th∆∞·ªùng',
        'weekend': 'Cu·ªëi tu·∫ßn',
        'vietnamese_holiday': 'L·ªÖ Vi·ªát Nam',
        'japanese_holiday': 'L·ªÖ Nh·∫≠t B·∫£n'
    }
    return translations.get(holiday_type_en, holiday_type_en)

@app.route('/api/attendance/pending')
def get_pending_attendance():
    if 'user_id' not in session:
        return jsonify({'total': 0, 'page': 1, 'per_page': 10, 'data': []})
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'total': 0, 'page': 1, 'per_page': 10, 'data': []})
    current_role = session.get('current_role', user.roles.split(',')[0])
    page = validate_int(request.args.get('page', 1), min_val=1)
    per_page = validate_int(request.args.get('per_page', 10), min_val=1, max_val=100)
    search = validate_input_sanitize(request.args.get('search', '').strip())
    department = validate_input_sanitize(request.args.get('department', '').strip())
    date_from = validate_date(request.args.get('date_from', '').strip()) if request.args.get('date_from') else None
    date_to = validate_date(request.args.get('date_to', '').strip()) if request.args.get('date_to') else None
    force_refresh = request.args.get('force_refresh', '0') == '1'
    requested_role = request.args.get('role', '')
    
    if page is None or per_page is None:
        return jsonify({'error': 'Tham s·ªë ph√¢n trang kh√¥ng h·ª£p l·ªá'}), 400
    
    # Add real-time data freshness check
    from utils.realtime_updates import check_data_freshness, invalidate_role_cache
    freshness = check_data_freshness(user.id, current_role)
    
    # Force refresh if requested or role mismatch
    if force_refresh or (requested_role and requested_role != current_role):
        freshness['needs_refresh'] = True
        freshness['force_refresh'] = True
    
    # Use optimized query for fastest performance
    from utils.query_optimizer import optimize_pending_attendance_query
    
    # Debug logging ƒë·ªÉ ki·ªÉm tra v·∫•n ƒë·ªÅ
    print(f"üîç [PENDING_API] User: {user.name}, ID: {user.id}", flush=True)
    print(f"üîç [PENDING_API] Role: {current_role}, Department: [{user.department}]", flush=True)
    
    records, total = optimize_pending_attendance_query(
        current_role=current_role, user=user, search=search, department=department,
        date_from=date_from, date_to=date_to, page=page, per_page=per_page
    )
    
    print(f"üîç [PENDING_API] Found {total} records for role {current_role}", flush=True)
    
    result = []
    for att in records:
        result.append({
            'id': att.id,
            'date': att.date.strftime('%d/%m/%Y'),
            'check_in': att.check_in.strftime('%H:%M') if att.check_in else None,
            'check_out': att.check_out.strftime('%H:%M') if att.check_out else None,
            'break_time': att._format_hours_minutes(att.break_time),
            'comp_time_regular': att._format_minutes_to_hhmm(att.comp_time_regular_minutes),
            'comp_time_overtime': att._format_minutes_to_hhmm(att.comp_time_overtime_minutes),
            'comp_time_ot_before_22': att._format_minutes_to_hhmm(att.comp_time_ot_before_22_minutes),
            'comp_time_ot_after_22': att._format_minutes_to_hhmm(att.comp_time_ot_after_22_minutes),
            'overtime_comp_time': att._format_minutes_to_hhmm(att.overtime_comp_time_minutes),
            'total_work_hours': att._format_hours_minutes(att.total_work_hours) if att.total_work_hours is not None else "0:00",
            'work_hours_display': att._format_hours_minutes(att.calculate_regular_work_hours()),
            'overtime_before_22': att.overtime_before_22,
            'overtime_after_22': att.overtime_after_22,
            'holiday_type': translate_holiday_type(att.holiday_type),
            'user_name': att.user.name if att.user else '',
            'department': att.user.department if att.user else '',
            'note': att.note,
            'status': att.status,
            'approved': att.approved,
            'signature': att.signature,
            'team_leader_signature': att.team_leader_signature,
            'manager_signature': att.manager_signature
        })
    resp = jsonify({
        'total': total,
        'page': page,
        'per_page': per_page,
        'data': result,
        'freshness': freshness  # Include real-time freshness data
    })
    # Disable caching to ensure fresh data after role switch
    resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
    resp.headers['Pragma'] = 'no-cache'
    resp.headers['Expires'] = '0'
    return resp

@app.route('/api/attendance/debug/status')
def debug_attendance_status():
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    current_role = session.get('current_role', user.roles.split(',')[0])
    if current_role != 'ADMIN':
        return jsonify({'error': 'Ch·ªâ ADMIN m·ªõi c√≥ th·ªÉ truy c·∫≠p endpoint n√†y'}), 403
    if not has_role(session['user_id'], 'ADMIN'):
        return jsonify({'error': 'B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p debug endpoint'}), 403
    all_statuses = db.session.query(Attendance.status).distinct().all()
    status_counts = {}
    for status in ['pending', 'pending_manager', 'pending_admin', 'approved', 'rejected']:
        count = Attendance.query.filter_by(status=status).count()
        status_counts[status] = count
    sample_records = {}
    for status in ['pending', 'pending_manager', 'pending_admin']:
        records = Attendance.query.options(joinedload(Attendance.user)).filter_by(status=status).limit(5).all()
        sample_records[status] = [
            {
                'id': r.id,
                'user_id': r.user_id,
                'date': r.date.strftime('%d/%m/%Y'),
                'status': r.status,
                'approved': r.approved,
                'user_name': r.user.name if r.user else 'Unknown'
            }
            for r in records
        ]
    return jsonify({
        'all_statuses': [s[0] for s in all_statuses],
        'status_counts': status_counts,
        'sample_records': sample_records
    })


@app.route('/api/attendance/debug/team-leader')
def debug_team_leader_attendance():
    """Debug endpoint for TEAM_LEADER to check department and pending attendance"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    update_session_activity()
    
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    current_role = session.get('current_role', user.roles.split(',')[0])
    
    # Th√¥ng tin user hi·ªán t·∫°i
    user_info = {
        'id': user.id,
        'name': user.name,
        'employee_id': user.employee_id,
        'department': user.department,
        'department_upper': (user.department or '').strip().upper(),
        'role': current_role
    }
    
    # L·∫•y t·∫•t c·∫£ ph√≤ng ban trong database
    all_departments = db.session.query(User.department, func.count(User.id)).filter(
        User.is_deleted == False
    ).group_by(User.department).all()
    
    dept_list = [{'name': d[0], 'upper': (d[0] or '').strip().upper(), 'count': d[1]} for d in all_departments]
    
    # T√¨m nh√¢n vi√™n c√πng ph√≤ng ban (exact match)
    user_dept = user.department
    exact_match_employees = User.query.filter(
        User.department == user_dept,
        User.is_deleted == False
    ).all()
    
    # T√¨m nh√¢n vi√™n c√πng ph√≤ng ban (case-insensitive)
    user_dept_upper = (user.department or '').strip().upper()
    case_insensitive_employees = User.query.filter(
        func.upper(func.trim(User.department)) == user_dept_upper,
        User.is_deleted == False
    ).all()
    
    # L·∫•y t·∫•t c·∫£ attendance c√≥ status='pending'
    all_pending = Attendance.query.filter(Attendance.status == 'pending').all()
    
    pending_list = []
    for att in all_pending:
        emp = db.session.get(User, att.user_id)
        pending_list.append({
            'id': att.id,
            'user_id': att.user_id,
            'user_name': emp.name if emp else 'Unknown',
            'user_dept': emp.department if emp else 'Unknown',
            'user_dept_upper': (emp.department or '').strip().upper() if emp else 'Unknown',
            'date': att.date.strftime('%Y-%m-%d'),
            'status': att.status,
            'matches_exact': (emp.department == user_dept) if emp else False,
            'matches_case_insensitive': ((emp.department or '').strip().upper() == user_dept_upper) if emp else False
        })
    
    # L·∫•y pending attendance c·ªßa nh√¢n vi√™n c√πng ph√≤ng ban (case-insensitive)
    team_user_ids = [u.id for u in case_insensitive_employees]
    team_pending = Attendance.query.filter(
        Attendance.status == 'pending',
        Attendance.user_id.in_(team_user_ids)
    ).all() if team_user_ids else []
    
    return jsonify({
        'current_user': user_info,
        'all_departments': dept_list,
        'exact_match_employees': [
            {'id': u.id, 'name': u.name, 'department': u.department}
            for u in exact_match_employees
        ],
        'case_insensitive_employees': [
            {'id': u.id, 'name': u.name, 'department': u.department}
            for u in case_insensitive_employees
        ],
        'all_pending_records': pending_list,
        'team_pending_count': len(team_pending),
        'team_pending_records': [
            {
                'id': att.id,
                'user_id': att.user_id,
                'date': att.date.strftime('%Y-%m-%d'),
                'status': att.status
            }
            for att in team_pending
        ]
    })












# Exempt certain API endpoints from CSRF protection if needed
# GET endpoints don't need CSRF protection
try:
    csrf.exempt(app.view_functions['get_attendance'])
    csrf.exempt(app.view_functions['get_attendance_history'])
    csrf.exempt(app.view_functions['get_pending_attendance'])
    csrf.exempt(app.view_functions['debug_attendance_status'])
    # Temporarily exempt signature APIs for testing
    csrf.exempt(app.view_functions['check_signature_status'])
    csrf.exempt(app.view_functions['save_signature_to_session'])
    csrf.exempt(app.view_functions['clear_session_signature'])
except KeyError:
    pass  # Routes might not exist yet


@app.route('/admin/users/<int:user_id>/reset_password', methods=['POST'])
@require_admin
def admin_reset_user_password(user_id):
    """Admin reset password cho user"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    
    update_session_activity()
    
    current_user = db.session.get(User, session['user_id'])
    if not current_user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    if 'ADMIN' not in current_user.roles.split(','):
        return jsonify({'error': 'Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y'}), 403
    
    try:
        data = request.get_json()
        if not data or 'password' not in data:
            return jsonify({'error': 'Thi·∫øu m·∫≠t kh·∫©u m·ªõi'}), 400
        
        new_password = data.get('password', '').strip()
        if len(new_password) < 6:
            return jsonify({'error': 'M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±'}), 400
        
        target_user = db.session.get(User, user_id)
        if not target_user:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
        
        # L∆∞u gi√° tr·ªã c≈© ƒë·ªÉ log
        old_password_hash = target_user.password_hash
        
        # ƒê·∫∑t m·∫≠t kh·∫©u m·ªõi
        target_user.set_password(new_password)
        
        db.session.commit()
        
        # Log audit
        log_audit_action(
            user_id=current_user.id,
            action='ADMIN_RESET_PASSWORD',
            table_name='users',
            record_id=user_id,
            old_values={'password': '***'},
            new_values={'password': '***', 'reset_by': current_user.id}
        )
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u cho {target_user.name} (M√£ NV: {target_user.employee_id})'
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå L·ªói khi ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'ƒê√£ x·∫£y ra l·ªói: {str(e)}'}), 500

@app.route('/admin/users/<int:user_id>/soft_delete', methods=['POST'])
@require_admin
def soft_delete_user(user_id):
    """Soft delete user - set is_deleted to True"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    user = db.session.get(User, user_id)
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    # Kh√¥ng cho ph√©p x√≥a ch√≠nh m√¨nh
    if user.id == session['user_id']:
        return jsonify({'error': 'Kh√¥ng th·ªÉ x√≥a t√†i kho·∫£n c·ªßa ch√≠nh m√¨nh'}), 400
    
    try:
        # Soft delete user
        user.soft_delete()
        db.session.commit()
        
        # Log the action
        log_audit_action(
            user_id=session['user_id'],
            action='SOFT_DELETE_USER',
            table_name='users',
            record_id=user_id,
            old_values={'is_deleted': False, 'is_active': True},
            new_values={'is_deleted': True, 'is_active': False}
        )
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ x√≥a ng∆∞·ªùi d√πng {user.name} th√†nh c√¥ng'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Error soft deleting user: {str(e)}")
        return jsonify({'error': 'ƒê√£ x·∫£y ra l·ªói khi x√≥a ng∆∞·ªùi d√πng'}), 500

@app.route('/admin/users/<int:user_id>/restore', methods=['POST'])
@require_admin
def restore_user(user_id):
    """Restore soft deleted user"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    user = db.session.get(User, user_id)
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    if not user.is_soft_deleted():
        return jsonify({'error': 'Ng∆∞·ªùi d√πng n√†y ch∆∞a b·ªã x√≥a'}), 400
    
    try:
        # Restore user
        user.restore()
        db.session.commit()
        
        # Log the action
        log_audit_action(
            user_id=session['user_id'],
            action='RESTORE_USER',
            table_name='users',
            record_id=user_id,
            old_values={'is_deleted': True, 'is_active': False},
            new_values={'is_deleted': False, 'is_active': True}
        )
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ kh√¥i ph·ª•c ng∆∞·ªùi d√πng {user.name} th√†nh c√¥ng'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Error restoring user: {str(e)}")
        return jsonify({'error': 'ƒê√£ x·∫£y ra l·ªói khi kh√¥i ph·ª•c ng∆∞·ªùi d√πng'}), 500

@app.route('/admin/yearly-reset/status', methods=['GET'])
@require_admin
def admin_yearly_reset_status():
    """Ki·ªÉm tra tr·∫°ng th√°i reset l·ªãch h√†ng nƒÉm v√† d·ªØ li·ªáu th√°ng 12"""
    try:
        if not session.get('user_id'):
            return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p'}), 401
        
        user = User.query.get(session['user_id'])
        if not user or not user.has_role('ADMIN'):
            return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn'}), 403
        
        current_year = datetime.now().year
        next_year = current_year + 1
        next_jan_1 = datetime(next_year, 1, 1)
        days_until_reset = (next_jan_1 - datetime.now()).days
        
        # Ki·ªÉm tra d·ªØ li·ªáu th√°ng 12
        check_result = check_december_data_complete(current_year)
        
        # Ki·ªÉm tra nƒÉm ƒë√£ reset g·∫ßn nh·∫•t
        global _last_reset_year
        last_reset_info = f"NƒÉm {_last_reset_year}" if _last_reset_year else "Ch∆∞a c√≥"
        
        return jsonify({
            'current_year': current_year,
            'next_reset_date': f"1/1/{next_year}",
            'days_until_reset': days_until_reset,
            'last_reset_year': _last_reset_year,
            'december_data': check_result,
            'status': 'ready' if days_until_reset > 0 else 'reset_pending'
        }), 200
    except Exception as e:
        return jsonify({'error': f'L·ªói: {str(e)}'}), 500

@app.route('/admin/yearly-reset/manual', methods=['POST'])
@require_admin
def admin_manual_yearly_reset():
    """Reset l·ªãch h√†ng nƒÉm th·ªß c√¥ng (ch·ªâ d√πng trong tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát)"""
    try:
        if not session.get('user_id'):
            return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p'}), 401
        
        user = User.query.get(session['user_id'])
        if not user or not user.has_role('ADMIN'):
            return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn'}), 403
        
        # Ki·ªÉm tra x√°c nh·∫≠n
        confirm = request.json.get('confirm', False)
        if not confirm:
            return jsonify({'error': 'C·∫ßn x√°c nh·∫≠n ƒë·ªÉ th·ª±c hi·ªán reset'}), 400
        
        # Th·ª±c hi·ªán reset
        success, deleted_count = reset_yearly_schedule()
        
        if success:
            global _last_reset_year
            _last_reset_year = datetime.now().year
            
            log_audit_action(
                user_id=user.id,
                action='MANUAL_YEARLY_RESET',
                table_name='attendances',
                record_id=None,
                old_values={},
                new_values={'deleted_count': deleted_count, 'reset_by': user.name}
            )
            
            return jsonify({
                'message': f'ƒê√£ reset l·ªãch th√†nh c√¥ng. ƒê√£ x√≥a {deleted_count} b·∫£n ghi.',
                'deleted_count': deleted_count
            }), 200
        else:
            return jsonify({'error': 'L·ªói khi reset l·ªãch'}), 500
    except Exception as e:
        return jsonify({'error': f'L·ªói: {str(e)}'}), 500

@app.route('/admin/users/deleted/delete-all', methods=['POST'])
@require_admin
def delete_all_deleted_users():
    """X√≥a vƒ©nh vi·ªÖn t·∫•t c·∫£ ng∆∞·ªùi d√πng ƒë√£ b·ªã soft delete - y√™u c·∫ßu x√°c minh m·∫≠t kh·∫©u"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    try:
        # L·∫•y d·ªØ li·ªáu t·ª´ request
        data = request.get_json()
        password = data.get('password', '').strip() if data else ''
        
        if not password:
            return jsonify({'error': 'Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ x√°c nh·∫≠n'}), 400
        
        # L·∫•y current user v√† x√°c minh m·∫≠t kh·∫©u
        current_user = db.session.get(User, session['user_id'])
        if not current_user:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng hi·ªán t·∫°i'}), 404
        
        if not current_user.check_password(password):
            return jsonify({'error': 'M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng. Vui l√≤ng th·ª≠ l·∫°i.'}), 401
        
        # L·∫•y t·∫•t c·∫£ users ƒë√£ b·ªã soft delete
        deleted_users = User.query.filter_by(is_deleted=True).all()
        total_count = len(deleted_users)
        
        if total_count == 0:
            return jsonify({'error': 'Kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o ƒë·ªÉ x√≥a'}), 400
        
        # L∆∞u th√¥ng tin ƒë·ªÉ audit log
        deleted_user_ids = [user.id for user in deleted_users]
        deleted_user_info = [
            {
                'employee_id': user.employee_id,
                'name': user.name,
                'email': user.email,
                'department': user.department
            }
            for user in deleted_users
        ]
        
        # X√≥a vƒ©nh vi·ªÖn t·∫•t c·∫£ users (hard delete)
        for user in deleted_users:
            db.session.delete(user)
        
        db.session.commit()
        
        # Log the action
        log_audit_action(
            user_id=session['user_id'],
            action='DELETE_ALL_DELETED_USERS',
            table_name='users',
            record_id=None,
            old_values={'deleted_users': deleted_user_info},
            new_values={'deleted_count': total_count}
        )
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ x√≥a vƒ©nh vi·ªÖn {total_count} ng∆∞·ªùi d√πng ƒë√£ x√≥a'
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå L·ªói khi x√≥a t·∫•t c·∫£ ng∆∞·ªùi d√πng ƒë√£ x√≥a: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói khi x√≥a t·∫•t c·∫£ ng∆∞·ªùi d√πng: {str(e)}'}), 500

@app.route('/admin/system/clear-all-data', methods=['POST'])
@require_admin
def clear_all_data():
    """X√≥a to√†n b·ªô d·ªØ li·ªáu h·ªá th·ªëng, ch·ªâ gi·ªØ l·∫°i admin Nguy·ªÖn C√¥ng ƒê·∫°t"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    try:
        # L·∫•y d·ªØ li·ªáu t·ª´ request
        data = request.get_json()
        password = data.get('password', '').strip() if data else ''
        
        if not password:
            return jsonify({'error': 'Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ x√°c nh·∫≠n'}), 400
        
        # L·∫•y current user v√† x√°c minh m·∫≠t kh·∫©u
        current_user = db.session.get(User, session['user_id'])
        if not current_user:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng hi·ªán t·∫°i'}), 404
        
        if not current_user.check_password(password):
            return jsonify({'error': 'M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng. Vui l√≤ng th·ª≠ l·∫°i.'}), 401
        
        # T√¨m admin Nguy·ªÖn C√¥ng ƒê·∫°t ƒë·ªÉ gi·ªØ l·∫°i (case-insensitive)
        all_users = User.query.all()
        admin_user = None
        for user in all_users:
            name_lower = user.name.lower()
            if 'nguy·ªÖn c√¥ng ƒë·∫°t' in name_lower or 'nguyen cong dat' in name_lower:
                admin_user = user
                break
        
        if not admin_user:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y admin Nguy·ªÖn C√¥ng ƒê·∫°t. Kh√¥ng th·ªÉ x√≥a d·ªØ li·ªáu.'}), 400
        
        # ƒê·∫£m b·∫£o admin n√†y c√≥ quy·ªÅn ADMIN
        if 'ADMIN' not in admin_user.get_roles_list():
            admin_user.roles = 'ADMIN'
            admin_user.is_active = True
            admin_user.is_deleted = False
        
        # ƒê·∫øm s·ªë l∆∞·ª£ng d·ªØ li·ªáu tr∆∞·ªõc khi x√≥a
        attendance_count = Attendance.query.count()
        leave_request_count = LeaveRequest.query.count()
        request_count = Request.query.count()
        audit_log_count = AuditLog.query.count()
        password_token_count = PasswordResetToken.query.count()
        user_count = User.query.count()
        
        # X√≥a t·∫•t c·∫£ Attendance records
        Attendance.query.delete()
        
        # X√≥a t·∫•t c·∫£ LeaveRequest records
        LeaveRequest.query.delete()
        
        # X√≥a t·∫•t c·∫£ Request records
        Request.query.delete()
        
        # X√≥a t·∫•t c·∫£ AuditLog records
        AuditLog.query.delete()
        
        # X√≥a t·∫•t c·∫£ PasswordResetToken records
        PasswordResetToken.query.delete()
        
        # X√≥a t·∫•t c·∫£ Users tr·ª´ admin Nguy·ªÖn C√¥ng ƒê·∫°t
        User.query.filter(User.id != admin_user.id).delete()
        
        # Commit t·∫•t c·∫£ thay ƒë·ªïi
        db.session.commit()
        
        # Log action (sau khi commit ƒë·ªÉ tr√°nh l·ªói)
        try:
            from utils.session import log_audit_action
            log_audit_action(
                user_id=current_user.id,
                action='CLEAR_ALL_SYSTEM_DATA',
                table_name='system',
                record_id=None,
                old_values={
                    'attendance_count': attendance_count,
                    'leave_request_count': leave_request_count,
                    'request_count': request_count,
                    'audit_log_count': audit_log_count,
                    'password_token_count': password_token_count,
                    'user_count': user_count
                },
                new_values={
                    'kept_admin': {
                        'id': admin_user.id,
                        'name': admin_user.name,
                        'employee_id': admin_user.employee_id,
                        'email': admin_user.email
                    },
                    'final_user_count': 1
                }
            )
        except Exception as log_err:
            print(f"Warning: Kh√¥ng th·ªÉ log audit action: {log_err}")
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ x√≥a to√†n b·ªô d·ªØ li·ªáu h·ªá th·ªëng th√†nh c√¥ng. ƒê√£ gi·ªØ l·∫°i admin: {admin_user.name} (M√£ NV: {admin_user.employee_id})',
            'deleted_counts': {
                'attendances': attendance_count,
                'leave_requests': leave_request_count,
                'requests': request_count,
                'audit_logs': audit_log_count,
                'password_tokens': password_token_count,
                'users': user_count - 1  # Tr·ª´ admin ƒë∆∞·ª£c gi·ªØ l·∫°i
            },
            'kept_admin': {
                'name': admin_user.name,
                'employee_id': admin_user.employee_id,
                'email': admin_user.email
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå L·ªói khi x√≥a to√†n b·ªô d·ªØ li·ªáu: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói khi x√≥a d·ªØ li·ªáu: {str(e)}'}), 500

@app.route('/admin/system/clear-attendances', methods=['POST'])
@require_admin
def clear_all_attendances():
    """X√≥a to√†n b·ªô b·∫£n ghi ch·∫•m c√¥ng, gi·ªØ nguy√™n th√¥ng tin nh√¢n vi√™n v√† ngh·ªâ ph√©p"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    try:
        # L·∫•y d·ªØ li·ªáu t·ª´ request
        data = request.get_json()
        password = data.get('password', '').strip() if data else ''
        
        if not password:
            return jsonify({'error': 'Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ x√°c nh·∫≠n'}), 400
        
        # L·∫•y current user v√† x√°c minh m·∫≠t kh·∫©u
        current_user = db.session.get(User, session['user_id'])
        if not current_user:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng hi·ªán t·∫°i'}), 404
        
        if not current_user.check_password(password):
            return jsonify({'error': 'M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng. Vui l√≤ng th·ª≠ l·∫°i.'}), 401
        
        # ƒê·∫øm s·ªë l∆∞·ª£ng d·ªØ li·ªáu tr∆∞·ªõc khi x√≥a
        attendance_count = Attendance.query.count()
        
        # X√≥a t·∫•t c·∫£ Attendance records
        Attendance.query.delete()
        
        # Commit thay ƒë·ªïi
        db.session.commit()
        
        # Log action
        try:
            audit_logger.audit_action(
                action='CLEAR_ALL_ATTENDANCES',
                table_name='attendances',
                record_id=None,
                old_values={'attendance_count': attendance_count},
                new_values={'cleared_by': current_user.name}
            )
        except Exception as log_err:
            print(f"Warning: Kh√¥ng th·ªÉ log audit action: {log_err}")
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ x√≥a th√†nh c√¥ng {attendance_count} b·∫£n ghi ch·∫•m c√¥ng. Th√¥ng tin nh√¢n vi√™n v√† ngh·ªâ ph√©p v·∫´n ƒë∆∞·ª£c gi·ªØ nguy√™n.',
            'deleted_count': attendance_count
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå L·ªói khi x√≥a ch·∫•m c√¥ng: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói khi x√≥a ch·∫•m c√¥ng: {str(e)}'}), 500

@app.route('/admin/system/clear-leave-requests', methods=['POST'])
@require_admin
def clear_all_leave_requests():
    """X√≥a to√†n b·ªô ƒë∆°n ngh·ªâ ph√©p, gi·ªØ nguy√™n th√¥ng tin nh√¢n vi√™n v√† ch·∫•m c√¥ng"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    try:
        # L·∫•y d·ªØ li·ªáu t·ª´ request
        data = request.get_json()
        password = data.get('password', '').strip() if data else ''
        
        if not password:
            return jsonify({'error': 'Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ x√°c nh·∫≠n'}), 400
        
        # L·∫•y current user v√† x√°c minh m·∫≠t kh·∫©u
        current_user = db.session.get(User, session['user_id'])
        if not current_user:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng hi·ªán t·∫°i'}), 404
        
        if not current_user.check_password(password):
            return jsonify({'error': 'M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng. Vui l√≤ng th·ª≠ l·∫°i.'}), 401
        
        # ƒê·∫øm s·ªë l∆∞·ª£ng d·ªØ li·ªáu tr∆∞·ªõc khi x√≥a
        leave_request_count = LeaveRequest.query.count()
        request_count = Request.query.count()
        
        # X√≥a t·∫•t c·∫£ LeaveRequest records
        LeaveRequest.query.delete()
        
        # X√≥a t·∫•t c·∫£ Request records (legacy)
        Request.query.delete()
        
        # Commit thay ƒë·ªïi
        db.session.commit()
        
        # Log action
        try:
            audit_logger.audit_action(
                action='CLEAR_ALL_LEAVE_REQUESTS',
                table_name='leave_requests',
                record_id=None,
                old_values={'leave_request_count': leave_request_count, 'request_count': request_count},
                new_values={'cleared_by': current_user.name}
            )
        except Exception as log_err:
            print(f"Warning: Kh√¥ng th·ªÉ log audit action: {log_err}")
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ x√≥a th√†nh c√¥ng {leave_request_count} ƒë∆°n ngh·ªâ ph√©p v√† {request_count} request kh√°c. Th√¥ng tin nh√¢n vi√™n v√† ch·∫•m c√¥ng v·∫´n ƒë∆∞·ª£c gi·ªØ nguy√™n.',
            'deleted_counts': {
                'leave_requests': leave_request_count,
                'requests': request_count
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå L·ªói khi x√≥a ngh·ªâ ph√©p: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói khi x√≥a ngh·ªâ ph√©p: {str(e)}'}), 500

@app.route('/admin/system/clear-records-only', methods=['POST'])
@require_admin
def clear_records_only():
    """X√≥a to√†n b·ªô ch·∫•m c√¥ng v√† ngh·ªâ ph√©p, gi·ªØ nguy√™n th√¥ng tin nh√¢n vi√™n"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    try:
        # L·∫•y d·ªØ li·ªáu t·ª´ request
        data = request.get_json()
        password = data.get('password', '').strip() if data else ''
        
        if not password:
            return jsonify({'error': 'Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ x√°c nh·∫≠n'}), 400
        
        # L·∫•y current user v√† x√°c minh m·∫≠t kh·∫©u
        current_user = db.session.get(User, session['user_id'])
        if not current_user:
            return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng hi·ªán t·∫°i'}), 404
        
        if not current_user.check_password(password):
            return jsonify({'error': 'M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng. Vui l√≤ng th·ª≠ l·∫°i.'}), 401
        
        # ƒê·∫øm s·ªë l∆∞·ª£ng d·ªØ li·ªáu tr∆∞·ªõc khi x√≥a
        attendance_count = Attendance.query.count()
        leave_request_count = LeaveRequest.query.count()
        request_count = Request.query.count()
        
        # X√≥a t·∫•t c·∫£ Attendance records
        Attendance.query.delete()
        
        # X√≥a t·∫•t c·∫£ LeaveRequest records
        LeaveRequest.query.delete()
        
        # X√≥a t·∫•t c·∫£ Request records (legacy)
        Request.query.delete()
        
        # Commit thay ƒë·ªïi
        db.session.commit()
        
        # Log action
        try:
            audit_logger.audit_action(
                action='CLEAR_RECORDS_ONLY',
                table_name='attendances+leave_requests',
                record_id=None,
                old_values={
                    'attendance_count': attendance_count,
                    'leave_request_count': leave_request_count,
                    'request_count': request_count
                },
                new_values={'cleared_by': current_user.name}
            )
        except Exception as log_err:
            print(f"Warning: Kh√¥ng th·ªÉ log audit action: {log_err}")
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ x√≥a th√†nh c√¥ng {attendance_count} b·∫£n ghi ch·∫•m c√¥ng v√† {leave_request_count} ƒë∆°n ngh·ªâ ph√©p. Th√¥ng tin nh√¢n vi√™n v·∫´n ƒë∆∞·ª£c gi·ªØ nguy√™n.',
            'deleted_counts': {
                'attendances': attendance_count,
                'leave_requests': leave_request_count,
                'requests': request_count
            }
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå L·ªói khi x√≥a b·∫£n ghi: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói khi x√≥a b·∫£n ghi: {str(e)}'}), 500

@app.route('/admin/users/deleted')
@require_admin
def admin_deleted_users():
    """Show soft deleted users"""
    page = request.args.get('page', 1, type=int)
    per_page = 10
    search = request.args.get('search', '', type=str).strip()
    department_filter = request.args.get('department', '', type=str).strip()

    query = User.query.filter_by(is_deleted=True)  # Ch·ªâ hi·ªÉn th·ªã users ƒë√£ b·ªã soft delete
    if search:
        search_lower = search.lower().strip()
        # T√°ch t·ª´ kh√≥a t√¨m ki·∫øm th√†nh c√°c t·ª´ ri√™ng l·∫ª
        search_words = search_lower.split()
        
        # T·∫°o ƒëi·ªÅu ki·ªán t√¨m ki·∫øm cho t·ª´ng t·ª´
        name_conditions = []
        for word in search_words:
            name_conditions.append(func.lower(User.name).contains(word))
        
        # T·∫°o ƒëi·ªÅu ki·ªán t√¨m ki·∫øm ƒë∆°n gi·∫£n - t√¨m theo t·ª´ng t·ª´ ri√™ng l·∫ª
        name_conditions = []
        for word in search_words:
            name_conditions.append(func.lower(User.name).contains(word))
        
        # Th√™m ƒëi·ªÅu ki·ªán t√¨m ki·∫øm theo m√£ nh√¢n vi√™n
        name_conditions.append(func.lower(func.cast(User.employee_id, db.String)).contains(search_lower))
        
        # K·∫øt h·ª£p t·∫•t c·∫£ ƒëi·ªÅu ki·ªán v·ªõi OR
        query = query.filter(db.or_(*name_conditions))
    if department_filter:
        query = query.filter(User.department == department_filter)
    query = query.order_by(User.name.asc())

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    users = pagination.items

    # L·∫•y danh s√°ch ph√≤ng ban t·ª´ b·∫£ng Department trong database
    from database.models import Department
    db_departments = Department.query.filter_by(is_active=True).order_by(Department.name).all()
    departments = [d.name for d in db_departments]

    # Calculate statistics
    deleted_count = len(users)
    
    # T√≠nh to√°n ph√¢n trang
    start_page = max(1, pagination.page - 2)
    end_page = min(pagination.pages, pagination.page + 2)
    if end_page - start_page < 4:
        end_page = min(pagination.pages, start_page + 4)
        start_page = max(1, end_page - 4)
    page_range = range(start_page, end_page + 1)

    return render_template(
        'admin/deleted_users.html',
        users=users,
        deleted_count=deleted_count,
        pagination=pagination,
        search=search,
        departments=departments,
        department_filter=department_filter,
        per_page=per_page,
        page_range=page_range
    )

@app.route('/admin/users/upload', methods=['POST'])
@require_admin
def upload_users():
    """Upload nh√¢n vi√™n t·ª´ file TXT ho·∫∑c XLSX
    
    Format file TXT:
    - M·ªói d√≤ng l√† 1 nh√¢n vi√™n
    - Format: M√£ NV|H·ªç v√† T√™n|Ph√≤ng Ban|Vai Tr√≤|Email|M·∫≠t kh·∫©u
    - Nhi·ªÅu vai tr√≤ c√°ch nhau b·∫±ng d·∫•u ph·∫©y: EMPLOYEE,TEAM_LEADER
    
    Format file XLSX:
    - H√†ng ƒë·∫ßu ti√™n c√≥ th·ªÉ l√† header (s·∫Ω b·ªè qua)
    - M·ªói h√†ng l√† 1 nh√¢n vi√™n
    - C·ªôt A: M√£ NV
    - C·ªôt B: H·ªç v√† T√™n
    - C·ªôt C: Ph√≤ng Ban
    - C·ªôt D: Vai Tr√≤
    - C·ªôt E: Email (t√πy ch·ªçn)
    - C·ªôt F: M·∫≠t kh·∫©u (t√πy ch·ªçn)
    
    V√≠ d·ª• TXT:
    1395|Nguy·ªÖn VƒÉn A|OFFICE|EMPLOYEE|email@dmi.com|123456
    1396|Tr·∫ßn Th·ªã B|PRODUCTION|EMPLOYEE,TEAM_LEADER||
    """
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    
    update_session_activity()
    
    # L·∫•y user hi·ªán t·∫°i
    current_user = db.session.get(User, session['user_id'])
    if not current_user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    # Ki·ªÉm tra quy·ªÅn admin
    if 'ADMIN' not in current_user.roles.split(','):
        return jsonify({'error': 'Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y'}), 403
    
    # Ki·ªÉm tra file
    if 'file' not in request.files:
        return jsonify({'error': 'Kh√¥ng c√≥ file ƒë∆∞·ª£c t·∫£i l√™n'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'Ch∆∞a ch·ªçn file'}), 400
    
    # Ki·ªÉm tra ƒë·ªãnh d·∫°ng file
    filename_lower = file.filename.lower()
    is_txt = filename_lower.endswith('.txt')
    is_xlsx = filename_lower.endswith('.xlsx') or filename_lower.endswith('.xls')
    
    if not (is_txt or is_xlsx):
        return jsonify({'error': 'File ph·∫£i c√≥ ƒë·ªãnh d·∫°ng .txt ho·∫∑c .xlsx/.xls'}), 400
    
    try:
        # ƒê·ªçc d·ªØ li·ªáu t·ª´ file
        rows_data = []
        
        if is_txt:
            # ƒê·ªçc file TXT
            content = file.read()
            try:
                # Th·ª≠ decode UTF-8
                text = content.decode('utf-8')
            except UnicodeDecodeError:
                try:
                    # Th·ª≠ decode UTF-8 v·ªõi BOM
                    text = content.decode('utf-8-sig')
                except UnicodeDecodeError:
                    # Fallback v·ªÅ Windows-1252 (th∆∞·ªùng d√πng cho ti·∫øng Vi·ªát)
                    text = content.decode('windows-1252')
            
            lines = text.strip().split('\n')
            for line in lines:
                line = line.strip()
                # B·ªè qua d√≤ng tr·ªëng v√† d√≤ng comment
                if not line or line.startswith('#'):
                    continue
                # Parse d√≤ng: M√£ NV|H·ªç v√† T√™n|Ph√≤ng Ban|Vai Tr√≤|Email|M·∫≠t kh·∫©u
                parts = line.split('|')
                rows_data.append(parts)
        else:
            # ƒê·ªçc file Excel
            file.seek(0)  # Reset file pointer
            wb = load_workbook(file, read_only=True, data_only=True)
            ws = wb.active
            
            # T·ª± ƒë·ªông ph√°t hi·ªán th·ª© t·ª± c·ªôt t·ª´ header (n·∫øu c√≥)
            column_mapping = None  # [idx_ma_nv, idx_ten, idx_phong_ban, idx_vai_tro, idx_email, idx_mat_khau]
            
            # ƒê·ªçc h√†ng ƒë·∫ßu ti√™n ƒë·ªÉ ph√°t hi·ªán header
            first_row = None
            for row in ws.iter_rows(min_row=1, max_row=1, values_only=True):
                first_row = [str(cell).strip().upper() if cell is not None else '' for cell in row]
                break
            
            # Ph√°t hi·ªán th·ª© t·ª± c·ªôt t·ª´ header
            if first_row:
                idx_ma_nv = -1
                idx_ten = -1
                idx_phong_ban = -1
                idx_vai_tro = -1
                idx_email = -1
                idx_mat_khau = -1
                
                for i, cell in enumerate(first_row):
                    cell_upper = str(cell).upper()
                    # T√¨m c·ªôt M√£ NV
                    if idx_ma_nv == -1 and any(kw in cell_upper for kw in ['M√É', 'M√É NV', 'M√É NH√ÇN VI√äN', 'EMPLOYEE ID', 'ID', 'M√É NV']):
                        idx_ma_nv = i
                    # T√¨m c·ªôt H·ªç v√† T√™n
                    elif idx_ten == -1 and any(kw in cell_upper for kw in ['H·ªå', 'T√äN', 'H·ªå V√Ä T√äN', 'NAME', 'T√äN NH√ÇN VI√äN']):
                        idx_ten = i
                    # T√¨m c·ªôt Ph√≤ng Ban
                    elif idx_phong_ban == -1 and any(kw in cell_upper for kw in ['PH√íNG', 'BAN', 'PH√íNG BAN', 'DEPARTMENT', 'TEAM']):
                        idx_phong_ban = i
                    # T√¨m c·ªôt Vai Tr√≤
                    elif idx_vai_tro == -1 and any(kw in cell_upper for kw in ['VAI', 'TR√í', 'VAI TR√í', 'ROLE', 'ROLES']):
                        idx_vai_tro = i
                    # T√¨m c·ªôt Email
                    elif idx_email == -1 and 'EMAIL' in cell_upper:
                        idx_email = i
                    # T√¨m c·ªôt M·∫≠t kh·∫©u
                    elif idx_mat_khau == -1 and any(kw in cell_upper for kw in ['M·∫¨T', 'KH·∫®U', 'M·∫¨T KH·∫®U', 'PASSWORD', 'PASS']):
                        idx_mat_khau = i
                
                # N·∫øu t√¨m th·∫•y ƒë·ªß c√°c c·ªôt b·∫Øt bu·ªôc, t·∫°o mapping
                if idx_ma_nv != -1 and idx_ten != -1 and idx_phong_ban != -1 and idx_vai_tro != -1:
                    column_mapping = [idx_ma_nv, idx_ten, idx_phong_ban, idx_vai_tro, idx_email, idx_mat_khau]
            
            # ƒê·ªçc t·∫•t c·∫£ c√°c h√†ng d·ªØ li·ªáu
            start_row = 2 if column_mapping else 1  # B·ªè qua header n·∫øu c√≥ mapping
            
            for row_idx, row in enumerate(ws.iter_rows(min_row=start_row, values_only=True), start=start_row):
                # B·ªè qua h√†ng tr·ªëng
                if not any(cell for cell in row):
                    continue
                
                # Chuy·ªÉn ƒë·ªïi gi√° tr·ªã None th√†nh chu·ªói r·ªóng v√† strip
                row_data = [str(cell).strip() if cell is not None else '' for cell in row]
                
                # N·∫øu c√≥ mapping, s·∫Øp x·∫øp l·∫°i theo th·ª© t·ª± chu·∫©n
                if column_mapping:
                    mapped_data = []
                    for idx in column_mapping:
                        if idx != -1 and idx < len(row_data):
                            mapped_data.append(row_data[idx])
                        else:
                            mapped_data.append('')
                    row_data = mapped_data
                else:
                    # Kh√¥ng c√≥ mapping, gi·∫£ ƒë·ªãnh th·ª© t·ª± chu·∫©n: M√£ NV | H·ªç v√† T√™n | Ph√≤ng Ban | Vai Tr√≤ | Email | M·∫≠t kh·∫©u
                    # Ho·∫∑c th·ª≠ ph√°t hi·ªán: n·∫øu c·ªôt ƒë·∫ßu l√† s·ªë th√¨ l√† M√£ NV, n·∫øu l√† ch·ªØ th√¨ l√† T√™n
                    if len(row_data) >= 2:
                        first_cell = row_data[0]
                        second_cell = row_data[1] if len(row_data) > 1 else ''
                        # N·∫øu c·ªôt ƒë·∫ßu l√† s·ªë (M√£ NV) v√† c·ªôt 2 l√† ch·ªØ (T√™n) -> ƒë√∫ng th·ª© t·ª±
                        # N·∫øu c·ªôt ƒë·∫ßu l√† ch·ªØ (T√™n) v√† c·ªôt 2 l√† s·ªë (M√£ NV) -> ƒë·∫£o ng∆∞·ª£c
                        try:
                            int(first_cell)
                            # C·ªôt ƒë·∫ßu l√† s·ªë -> ƒë√∫ng th·ª© t·ª±
                            row_data = row_data[:6]
                        except (ValueError, TypeError):
                            # C·ªôt ƒë·∫ßu kh√¥ng ph·∫£i s·ªë -> ƒë·∫£o ng∆∞·ª£c c·ªôt 0 v√† 1
                            if len(row_data) >= 2:
                                row_data = [row_data[1], row_data[0]] + row_data[2:6]
                            else:
                                row_data = row_data[:6]
                    else:
                        row_data = row_data[:6]
                
                rows_data.append(row_data)
            
            wb.close()
        
        lines = rows_data
        
        # Parse t·ª´ng d√≤ng
        results = {
            'success': [],
            'errors': [],
            'skipped': [],
            'conflicts': []  # Th√™m conflicts ƒë·ªÉ h·ªèi user
        }
        
        default_password = request.form.get('default_password', '123456')  # M·∫≠t kh·∫©u m·∫∑c ƒë·ªãnh
        
        # T·ªëi ∆∞u: Load t·∫•t c·∫£ existing users v√† emails v√†o memory tr∆∞·ªõc ƒë·ªÉ tr√°nh query trong v√≤ng l·∫∑p
        all_users = User.query.filter_by(is_deleted=False).all()
        existing_users = {user.employee_id: user for user in all_users}
        # Load emails v·ªõi normalize (lowercase v√† strip) ƒë·ªÉ so s√°nh ch√≠nh x√°c
        # ƒê·∫£m b·∫£o normalize gi·ªëng h·ªát nh∆∞ khi ki·ªÉm tra trong v√≤ng l·∫∑p
        existing_emails = {}
        for user in all_users:
            if user.email:
                # Normalize email: strip whitespace, lowercase, v√† lo·∫°i b·ªè t·∫•t c·∫£ whitespace ·∫©n
                # C√°ch normalize n√†y ph·∫£i gi·ªëng h·ªát v·ªõi c√°ch normalize khi ki·ªÉm tra trong v√≤ng l·∫∑p
                email_normalized = str(user.email).strip().lower()
                # Lo·∫°i b·ªè t·∫•t c·∫£ c√°c k√Ω t·ª± whitespace ·∫©n (space, tab, newline, etc.)
                email_normalized = ''.join(email_normalized.split())
                if email_normalized:
                    existing_emails[email_normalized] = user
        
        # Track emails v√† employee_ids ƒë√£ th√™m trong batch n√†y ƒë·ªÉ tr√°nh duplicate trong c√πng file
        batch_emails = set()
        batch_employee_ids = set()
        
        for line_num, parts in enumerate(lines, 1):
            # parts ƒë√£ l√† list t·ª´ vi·ªác parse TXT ho·∫∑c Excel
            
            # L·ªçc b·ªè c√°c ph·∫ßn t·ª≠ r·ªóng ·ªü cu·ªëi
            parts = [p for p in parts if p] if parts else []
            
            if len(parts) < 4:
                row_content = '|'.join(parts) if parts else '(d√≤ng tr·ªëng)'
                results['errors'].append({
                    'line': line_num,
                    'content': row_content,
                    'error': 'ƒê·ªãnh d·∫°ng kh√¥ng ƒë√∫ng. C·∫ßn: M√£ NV|H·ªç v√† T√™n|Ph√≤ng Ban|Vai Tr√≤ (ho·∫∑c th√™m Email|M·∫≠t kh·∫©u)'
                })
                continue
            
            employee_id_str = str(parts[0]).strip() if parts[0] else ''
            name = str(parts[1]).strip() if len(parts) > 1 and parts[1] else ''
            department = str(parts[2]).strip() if len(parts) > 2 and parts[2] else ''
            roles_str = str(parts[3]).strip() if len(parts) > 3 and parts[3] else ''
            
            # Email v√† m·∫≠t kh·∫©u (t√πy ch·ªçn - n·∫øu c√≥ 6 tr∆∞·ªùng)
            # ∆Øu ti√™n: M·∫≠t kh·∫©u t·ª´ file Excel > M·∫≠t kh·∫©u m·∫∑c ƒë·ªãnh t·ª´ form
            email = str(parts[4]).strip() if len(parts) > 4 and parts[4] else None
            password_from_file = str(parts[5]).strip() if len(parts) > 5 and parts[5] else None
            
            # L√†m s·∫°ch email (lo·∫°i b·ªè None v√† chu·ªói r·ªóng)
            email = email if email and email.lower() != 'none' and email.strip() else None
            
            # X·ª≠ l√Ω m·∫≠t kh·∫©u: ∆Øu ti√™n t·ª´ file, n·∫øu kh√¥ng c√≥ ho·∫∑c r·ªóng th√¨ d√πng m·∫∑c ƒë·ªãnh
            password = None
            if password_from_file and password_from_file.lower() != 'none' and password_from_file.strip():
                password = password_from_file.strip()
            # N·∫øu kh√¥ng c√≥ m·∫≠t kh·∫©u trong file, s·∫Ω d√πng default_password sau khi validate
            
            # Validate d·ªØ li·ªáu
            try:
                employee_id = validate_employee_id(employee_id_str)
                if not employee_id:
                    row_content = '|'.join([str(p) for p in parts[:6]])
                    results['errors'].append({
                        'line': line_num,
                        'content': row_content,
                        'error': f'M√£ nh√¢n vi√™n kh√¥ng h·ª£p l·ªá: {employee_id_str}'
                    })
                    continue
            except Exception as e:
                row_content = '|'.join([str(p) for p in parts[:6]])
                results['errors'].append({
                    'line': line_num,
                    'content': row_content,
                    'error': f'M√£ nh√¢n vi√™n kh√¥ng h·ª£p l·ªá: {str(e)}'
                })
                continue
            
            # Validate name
            name = validate_input_sanitize(name)
            if not name:
                row_content = '|'.join([str(p) for p in parts[:6]])
                results['errors'].append({
                    'line': line_num,
                    'content': row_content,
                    'error': 'T√™n ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá'
                })
                continue
            
            # Validate v√† chu·∫©n h√≥a department
            department = validate_input_sanitize(department)
            if not department:
                row_content = '|'.join([str(p) for p in parts[:6]])
                results['errors'].append({
                    'line': line_num,
                    'content': row_content,
                    'error': 'Ph√≤ng ban kh√¥ng h·ª£p l·ªá'
                })
                continue
            
            # Chu·∫©n h√≥a t√™n ph√≤ng ban: trim, lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a, chuy·ªÉn v·ªÅ ch·ªØ hoa
            department = ' '.join(department.split()).strip().upper()
            
            # Parse roles (c√°ch nhau b·∫±ng d·∫•u ph·∫©y) v√† chu·∫©n h√≥a v·ªÅ ch·ªØ hoa
            roles_list = [r.strip().upper() for r in roles_str.split(',') if r.strip()]
            
            # Chu·∫©n h√≥a t√™n vai tr√≤ (TEAMLEADER -> TEAM_LEADER, etc.)
            normalized_roles = []
            role_mapping = {
                'TEAMLEADER': 'TEAM_LEADER',
                'TEAM LEADER': 'TEAM_LEADER',
                'TEAM-LEADER': 'TEAM_LEADER',
            }
            for role in roles_list:
                # Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a
                role = role.replace(' ', '_').replace('-', '_')
                # √Åp d·ª•ng mapping n·∫øu c√≥
                normalized_role = role_mapping.get(role, role)
                normalized_roles.append(normalized_role)
            roles_list = normalized_roles
            
            # Validate roles (ƒë√£ chu·∫©n h√≥a v·ªÅ ch·ªØ hoa)
            valid_roles = ['EMPLOYEE', 'TEAM_LEADER', 'MANAGER', 'ADMIN']
            invalid_roles = [r for r in roles_list if r not in valid_roles]
            if invalid_roles:
                row_content = '|'.join([str(p) for p in parts[:6]])
                results['errors'].append({
                    'line': line_num,
                    'content': row_content,
                    'error': f'Vai tr√≤ kh√¥ng h·ª£p l·ªá: {", ".join(invalid_roles)}. Vai tr√≤ h·ª£p l·ªá: {", ".join(valid_roles)}'
                })
                continue
            
            if not roles_list:
                row_content = '|'.join([str(p) for p in parts[:6]])
                results['errors'].append({
                    'line': line_num,
                    'content': row_content,
                    'error': 'Ph·∫£i c√≥ √≠t nh·∫•t m·ªôt vai tr√≤'
                })
                continue
            
            # Validate email (n·∫øu c√≥)
            if email:
                email = email.strip()
                # Ki·ªÉm tra format email c∆° b·∫£n
                email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
                if not re.match(email_pattern, email):
                    row_content = '|'.join([str(p) for p in parts[:6]])
                    results['errors'].append({
                    'line': line_num,
                        'content': row_content,
                        'error': f'Email kh√¥ng h·ª£p l·ªá: {email}'
                })
                continue
            
                # B·ªè qua ki·ªÉm tra tr√πng l·∫∑p email - ng∆∞·ªùi d√πng s·∫Ω ki·ªÉm tra tr∆∞·ªõc khi upload
            
            # Validate v√† x·ª≠ l√Ω m·∫≠t kh·∫©u
            # ∆Øu ti√™n: M·∫≠t kh·∫©u t·ª´ file Excel > M·∫≠t kh·∫©u m·∫∑c ƒë·ªãnh t·ª´ form
            if password:
                # C√≥ m·∫≠t kh·∫©u t·ª´ file, validate ƒë·ªô d√†i
                if len(password) < 6:
                    row_content = '|'.join([str(p) for p in parts[:6]])
                    results['errors'].append({
                        'line': line_num,
                        'content': row_content,
                        'error': 'M·∫≠t kh·∫©u t·ª´ file ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±'
                    })
                    continue
            else:
                # Kh√¥ng c√≥ m·∫≠t kh·∫©u trong file ho·∫∑c m·∫≠t kh·∫©u r·ªóng, d√πng m·∫≠t kh·∫©u m·∫∑c ƒë·ªãnh t·ª´ form
                password = default_password
            
            # B·ªè qua ki·ªÉm tra tr√πng l·∫∑p employee_id v√† email - ng∆∞·ªùi d√πng s·∫Ω ki·ªÉm tra tr∆∞·ªõc khi upload
            
            # T·∫°o user m·ªõi - b·ªè qua ki·ªÉm tra tr√πng l·∫∑p, ch·ªâ c·∫ßn try-except ƒë·ªÉ b·ªè qua n·∫øu l·ªói
            try:
                new_user = User(
                    employee_id=employee_id,
                    name=name,
                    department=department,
                    roles=','.join(roles_list),
                    email=email if email else None,
                    is_active=True
                )
                new_user.set_password(password)
                
                db.session.add(new_user)
                db.session.flush()
                
                # C·∫≠p nh·∫≠t cache ƒë·ªÉ tr√°nh duplicate trong c√πng batch
                existing_users[employee_id] = new_user
                batch_employee_ids.add(employee_id)
                if email:
                    # Normalize email gi·ªëng nh∆∞ khi ki·ªÉm tra
                    email_normalized = email.strip().lower()
                    email_normalized = ''.join(email_normalized.split())  # Lo·∫°i b·ªè whitespace ·∫©n
                    existing_emails[email_normalized] = new_user
                    batch_emails.add(email_normalized)
                
                # L∆∞u th√¥ng tin ƒë·ªÉ log sau (batch log ƒë·ªÉ tr√°nh commit t·ª´ng c√°i)
                results['success'].append({
                    'line': line_num,
                        'employee_id': employee_id,
                        'name': name,
                        'department': department,
                        'roles': ','.join(roles_list),
                    'email': email if email else None,
                    'user_id': new_user.id  # L∆∞u ID ƒë·ªÉ log sau
                })
                
            except Exception as e:
                db.session.rollback()
                error_str = str(e)
                
                # N·∫øu l√† l·ªói UNIQUE constraint (email ho·∫∑c employee_id), t√¨m user ƒë√£ t·ªìn t·∫°i v√† update
                if 'UNIQUE constraint' in error_str:
                    existing_user = None
                    
                    # Sau khi rollback, query l·∫°i t·ª´ database
                    # T√¨m user ƒë√£ t·ªìn t·∫°i theo employee_id tr∆∞·ªõc (∆∞u ti√™n)
                    # Th·ª≠ t√¨m c·∫£ user ƒë√£ b·ªã soft delete (c√≥ th·ªÉ c·∫ßn restore)
                    existing_user = User.query.filter_by(employee_id=employee_id).first()

                    # N·∫øu kh√¥ng t√¨m th·∫•y theo employee_id, th·ª≠ t√¨m theo email
                    if not existing_user and email:
                        email_normalized = email.strip().lower()
                        email_normalized = ''.join(email_normalized.split())
                        all_db_users = User.query.all()  # T√¨m c·∫£ user ƒë√£ b·ªã soft delete
                        for db_user in all_db_users:
                            if db_user.email:
                                db_email_normalized = str(db_user.email).strip().lower()
                                db_email_normalized = ''.join(db_email_normalized.split())
                                if db_email_normalized == email_normalized:
                                    existing_user = db_user
                                    break
                    
                    if existing_user:
                        # Update th√¥ng tin user ƒë√£ t·ªìn t·∫°i
                        # N·∫øu user b·ªã soft delete, restore l·∫°i
                        if existing_user.is_deleted:
                            existing_user.is_deleted = False
                            existing_user.is_active = True
                        
                        existing_user.name = name
                        existing_user.department = department
                        existing_user.roles = ','.join(roles_list)
                        if email:
                            existing_user.email = email
                        # Ch·ªâ update m·∫≠t kh·∫©u n·∫øu c√≥ m·∫≠t kh·∫©u t·ª´ file (kh√¥ng ph·∫£i m·∫≠t kh·∫©u m·∫∑c ƒë·ªãnh)
                        if password and password != default_password:
                            existing_user.set_password(password)
                        
                        db.session.add(existing_user)
                        try:
                            db.session.flush()
                        except Exception as update_error:
                            db.session.rollback()
                            row_content = '|'.join([str(p) for p in parts[:6]])
                            results['errors'].append({
                                'line': line_num,
                                'content': row_content,
                                'error': f'L·ªói khi c·∫≠p nh·∫≠t user: {str(update_error)}'
                            })
                            continue

                        # Th√™m v√†o success v·ªõi action l√† 'updated'
                        results['success'].append({
                            'line': line_num,
                            'employee_id': employee_id,
                            'name': name,
                            'department': department,
                            'roles': ','.join(roles_list),
                            'email': email if email else None,
                            'user_id': existing_user.id,
                            'action': 'updated'  # ƒê√°nh d·∫•u l√† ƒë√£ update
                        })
                        # C·∫≠p nh·∫≠t cache
                        existing_users[employee_id] = existing_user
                        if email:
                            email_normalized = email.strip().lower()
                            email_normalized = ''.join(email_normalized.split())
                            existing_emails[email_normalized] = existing_user
                        continue
                    else:
                        # Kh√¥ng t√¨m th·∫•y user, b·ªè qua
                        row_content = '|'.join([str(p) for p in parts[:6]])
                        results['skipped'].append({
                            'line': line_num,
                            'content': row_content,
                            'employee_id': employee_id_str,
                            'name': name,
                            'reason': f'ƒê√£ t·ªìn t·∫°i trong h·ªá th·ªëng nh∆∞ng kh√¥ng t√¨m th·∫•y ƒë·ªÉ c·∫≠p nh·∫≠t'
                        })
                        continue
                
                # C√°c l·ªói kh√°c
                row_content = '|'.join([str(p) for p in parts[:6]])
                results['errors'].append({
                    'line': line_num,
                    'content': row_content,
                    'error': f'L·ªói khi t·∫°o user: {str(e)}'
                })
        
        # Commit t·∫•t c·∫£ users th√†nh c√¥ng (batch commit)
        if results['success']:
            try:
                db.session.commit()
                
                # Batch log audit actions (t·∫°o audit logs nh∆∞ng kh√¥ng commit t·ª´ng c√°i)
                audit_logs = []
                for success_item in results['success']:
                    user_id = success_item.get('user_id')
                    if user_id:
                        try:
                            from database.models import AuditLog
                            # X√°c ƒë·ªãnh action: CREATE ho·∫∑c UPDATE
                            action = 'UPDATE_USER_UPLOAD' if success_item.get('action') == 'updated' else 'CREATE_USER_UPLOAD'
                            audit_log = AuditLog(
                                user_id=current_user.id,
                                action=action,
                                table_name='users',
                                record_id=user_id,
                                new_values={
                                    'employee_id': success_item['employee_id'],
                                    'name': success_item['name'],
                                    'department': success_item['department'],
                                    'roles': success_item['roles'],
                                    'email': success_item.get('email'),
                                    'source': 'file_upload'
                                },
                                ip_address=request.remote_addr,
                                user_agent=request.headers.get('User-Agent')
                            )
                            db.session.add(audit_log)
                            audit_logs.append(audit_log)
                        except Exception as log_err:
                            # N·∫øu log l·ªói, b·ªè qua nh∆∞ng kh√¥ng l√†m fail upload
                            print(f"Warning: Kh√¥ng th·ªÉ log audit cho user {user_id}: {log_err}")
                
                # Commit t·∫•t c·∫£ audit logs m·ªôt l·∫ßn
                if audit_logs:
                    try:
                        db.session.commit()
                    except Exception as log_commit_err:
                        # N·∫øu commit log l·ªói, rollback nh∆∞ng kh√¥ng ·∫£nh h∆∞·ªüng users ƒë√£ t·∫°o
                        db.session.rollback()
                        print(f"Warning: Kh√¥ng th·ªÉ commit audit logs: {log_commit_err}")
                
                # X√≥a user_id kh·ªèi dict ƒë·ªÉ tr√°nh serialize l·ªói khi tr·∫£ v·ªÅ JSON
                for success_item in results['success']:
                    success_item.pop('user_id', None)
            except Exception as e:
                db.session.rollback()
                return jsonify({
                    'error': f'L·ªói khi l∆∞u d·ªØ li·ªáu: {str(e)}',
                    'partial_results': results
                }), 500
        
        # T·ªïng k·∫øt
        total_lines = len(lines)
        success_count = len(results['success'])
        # Ph√¢n lo·∫°i created vs updated
        created_count = sum(1 for item in results['success'] if item.get('action') != 'updated')
        updated_count = sum(1 for item in results['success'] if item.get('action') == 'updated')
        error_count = len(results['errors'])
        skipped_count = len(results['skipped'])
        conflict_count = len(results['conflicts'])
        
        message_parts = []
        if created_count > 0:
            message_parts.append(f'ƒê√£ t·∫°o th√†nh c√¥ng {created_count} nh√¢n vi√™n')
        if updated_count > 0:
            message_parts.append(f'ƒê√£ c·∫≠p nh·∫≠t {updated_count} nh√¢n vi√™n')
        if not message_parts:
            message_parts.append('Kh√¥ng c√≥ nh√¢n vi√™n n√†o ƒë∆∞·ª£c t·∫°o ho·∫∑c c·∫≠p nh·∫≠t')
        if skipped_count > 0:
            message_parts.append(f'b·ªè qua {skipped_count} nh√¢n vi√™n')
        if conflict_count > 0:
            message_parts.append(f'{conflict_count} nh√¢n vi√™n c·∫ßn x√°c nh·∫≠n (tr√πng l·∫∑p)')
        if error_count > 0:
            message_parts.append(f'{error_count} d√≤ng l·ªói')
        message = ', '.join(message_parts)
        
        # N·∫øu c√≥ conflicts, tr·∫£ v·ªÅ ƒë·ªÉ h·ªèi user
        has_conflicts = conflict_count > 0
        
        return jsonify({
            'success': True,
            'message': message,
            'results': results,
            'summary': {
                'total_lines': total_lines,
                'success_count': success_count,
                'error_count': error_count,
                'skipped_count': skipped_count,
                'conflict_count': conflict_count
            },
            'has_conflicts': has_conflicts
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå L·ªói khi upload users: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω file: {str(e)}'}), 500

@app.route('/admin/users/download', methods=['GET'])
@require_admin
def download_users():
    """T·∫£i danh s√°ch nh√¢n vi√™n ra file XLSX."""
    try:
        if 'user_id' not in session:
            return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401

        if check_session_timeout():
            return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401

        update_session_activity()

        current_user = db.session.get(User, session['user_id'])
        if not current_user or 'ADMIN' not in current_user.roles.split(','):
            return jsonify({'error': 'Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y'}), 403

        users = User.query.order_by(User.employee_id.asc()).all()

        wb = Workbook()
        ws = wb.active
        ws.title = "Users"

        headers = ["M√£ NV", "H·ªç v√† T√™n", "Ph√≤ng Ban", "Vai Tr√≤", "Email", "M·∫≠t kh·∫©u"]
        ws.append(headers)

        for u in users:
            ws.append([
                u.employee_id or "",
                u.name or "",
                u.department or "",
                u.roles or "",
                u.email or "",
                ""  # Kh√¥ng xu·∫•t m·∫≠t kh·∫©u (ƒë·ªÉ tr·ªëng)
            ])

        # CƒÉn gi·ªØa to√†n b·ªô n·ªôi dung
        from openpyxl.styles import Alignment
        center_align = Alignment(horizontal="center", vertical="center")
        for row in ws.iter_rows():
            for cell in row:
                cell.alignment = center_align

        for col in ws.columns:
            max_len = max(len(str(cell.value)) if cell.value else 0 for cell in col)
            col_letter = get_column_letter(col[0].column)
            ws.column_dimensions[col_letter].width = max(12, min(max_len + 2, 40))

        output = BytesIO()
        wb.save(output)
        output.seek(0)

        return send_file(
            output,
            as_attachment=True,
            download_name='thongtin_nhanvien.xlsx',
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
    except Exception as e:
        print(f"‚ùå L·ªói khi download users: {e}")
        return jsonify({'error': f'L·ªói khi t·∫£i danh s√°ch: {str(e)}'}), 500

@app.route('/admin/users/upload/resolve-conflicts', methods=['POST'])
@require_admin
def resolve_upload_conflicts():
    """X·ª≠ l√Ω conflicts khi upload nh√¢n vi√™n - user ch·ªçn gi·ªØ nguy√™n ho·∫∑c c·∫≠p nh·∫≠t"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    
    update_session_activity()
    
    current_user = db.session.get(User, session['user_id'])
    if not current_user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    if 'ADMIN' not in current_user.roles.split(','):
        return jsonify({'error': 'Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y'}), 403
    
    try:
        data = request.get_json()
        if not data or 'decisions' not in data:
            return jsonify({'error': 'Thi·∫øu d·ªØ li·ªáu quy·∫øt ƒë·ªãnh'}), 400
        
        decisions = data['decisions']  # List of {conflict_id, action: 'keep' or 'update', fields_to_update: []}
        
        results = {
            'updated': [],
            'skipped': [],
            'errors': []
        }
        
        for decision in decisions:
            conflict_id = decision.get('conflict_id')
            action = decision.get('action')  # 'keep' or 'update'
            conflict_data = decision.get('conflict_data')
            fields_to_update = decision.get('fields_to_update', [])  # Danh s√°ch c√°c tr∆∞·ªùng mu·ªën c·∫≠p nh·∫≠t: ['name', 'department', 'roles', 'email', 'password']
            
            if not conflict_data:
                results['errors'].append({
                    'conflict_id': conflict_id,
                    'error': 'Thi·∫øu d·ªØ li·ªáu conflict'
                })
                continue
            
            existing_user_id = conflict_data.get('existing_user_id')
            existing_user = db.session.get(User, existing_user_id)
            
            if not existing_user:
                results['errors'].append({
                    'conflict_id': conflict_id,
                    'error': f'Kh√¥ng t√¨m th·∫•y user v·ªõi ID {existing_user_id}'
                })
                continue
            
            if action == 'keep':
                # Gi·ªØ nguy√™n, b·ªè qua
                results['skipped'].append({
                    'conflict_id': conflict_id,
                    'employee_id': conflict_data.get('employee_id'),
                    'name': conflict_data.get('name'),
                    'reason': 'Ng∆∞·ªùi d√πng ch·ªçn gi·ªØ nguy√™n d·ªØ li·ªáu c≈©'
                })
            elif action == 'update':
                # C·∫≠p nh·∫≠t d·ªØ li·ªáu m·ªõi - ch·ªâ c·∫≠p nh·∫≠t c√°c tr∆∞·ªùng ƒë∆∞·ª£c ch·ªçn
                try:
                    old_values = {
                        'name': existing_user.name,
                        'department': existing_user.department,
                        'roles': existing_user.roles,
                        'email': existing_user.email
                    }
                    
                    updated_fields = []
                    
                    # C·∫≠p nh·∫≠t t·ª´ng tr∆∞·ªùng n·∫øu ƒë∆∞·ª£c ch·ªçn
                    if 'name' in fields_to_update:
                        existing_user.name = conflict_data.get('name', existing_user.name)
                        updated_fields.append('name')
                    
                    if 'department' in fields_to_update:
                        existing_user.department = conflict_data.get('department', existing_user.department)
                        updated_fields.append('department')
                    
                    if 'roles' in fields_to_update:
                        existing_user.roles = conflict_data.get('roles', existing_user.roles)
                        updated_fields.append('roles')
                    
                    # X·ª≠ l√Ω email - ch·ªâ c·∫≠p nh·∫≠t n·∫øu ƒë∆∞·ª£c ch·ªçn v√† kh√¥ng tr√πng v·ªõi user kh√°c
                    if 'email' in fields_to_update:
                        new_email = conflict_data.get('email')
                        if new_email and new_email.strip():
                            new_email_lower = new_email.strip().lower()
                            # Ki·ªÉm tra email c√≥ tr√πng v·ªõi user kh√°c kh√¥ng
                            other_user = User.query.filter(
                                User.email.ilike(new_email_lower),
                                User.id != existing_user.id,
                                User.is_deleted == False
                            ).first()
                            if other_user:
                                results['errors'].append({
                                    'conflict_id': conflict_id,
                                    'employee_id': conflict_data.get('employee_id'),
                                    'error': f'Email {new_email} ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi nh√¢n vi√™n kh√°c (M√£ NV: {other_user.employee_id})'
                                })
                                continue
                            existing_user.email = new_email.strip()
                            updated_fields.append('email')
                    
                    # C·∫≠p nh·∫≠t m·∫≠t kh·∫©u n·∫øu ƒë∆∞·ª£c ch·ªçn
                    if 'password' in fields_to_update:
                        new_password = conflict_data.get('password')
                        if new_password and new_password.strip():
                            existing_user.set_password(new_password.strip())
                            updated_fields.append('password')
                    
                    if not updated_fields:
                        # Kh√¥ng c√≥ tr∆∞·ªùng n√†o ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ c·∫≠p nh·∫≠t
                        results['skipped'].append({
                            'conflict_id': conflict_id,
                            'employee_id': conflict_data.get('employee_id'),
                            'name': conflict_data.get('name'),
                            'reason': 'Kh√¥ng c√≥ tr∆∞·ªùng n√†o ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ c·∫≠p nh·∫≠t'
                        })
                        continue
                    
                    db.session.flush()
                    
                    # Log audit
                    new_values = {}
                    for field in updated_fields:
                        if field == 'password':
                            new_values['password'] = '***'  # Kh√¥ng l∆∞u m·∫≠t kh·∫©u v√†o log
                        else:
                            new_values[field] = getattr(existing_user, field)
                    
                    log_audit_action(
                        user_id=current_user.id,
                        action='UPDATE_USER_UPLOAD_CONFLICT',
                        table_name='users',
                        record_id=existing_user.id,
                        old_values=old_values,
                        new_values=new_values
                    )
                    
                    results['updated'].append({
                        'conflict_id': conflict_id,
                        'employee_id': conflict_data.get('employee_id'),
                        'name': conflict_data.get('name'),
                        'existing_user_id': existing_user.id,
                        'updated_fields': updated_fields
                    })
                    
                except Exception as e:
                    db.session.rollback()
                    results['errors'].append({
                        'conflict_id': conflict_id,
                        'employee_id': conflict_data.get('employee_id'),
                        'error': f'L·ªói khi c·∫≠p nh·∫≠t: {str(e)}'
                    })
        
        # Commit t·∫•t c·∫£ updates
        if results['updated']:
            try:
                db.session.commit()
            except Exception as e:
                db.session.rollback()
                return jsonify({
                    'error': f'L·ªói khi l∆∞u d·ªØ li·ªáu: {str(e)}',
                    'partial_results': results
                }), 500
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ x·ª≠ l√Ω {len(decisions)} conflicts: {len(results["updated"])} c·∫≠p nh·∫≠t, {len(results["skipped"])} gi·ªØ nguy√™n, {len(results["errors"])} l·ªói',
            'results': results
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå L·ªói khi x·ª≠ l√Ω conflicts: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'ƒê√£ x·∫£y ra l·ªói: {str(e)}'}), 500

@app.route('/admin/users/delete-all', methods=['POST'])
@require_admin
def delete_all_users():
    """X√≥a t·∫•t c·∫£ nh√¢n vi√™n (tr·ª´ user hi·ªán t·∫°i) - y√™u c·∫ßu x√°c nh·∫≠n m·∫≠t kh·∫©u"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    
    update_session_activity()
    
    # L·∫•y user hi·ªán t·∫°i
    current_user = db.session.get(User, session['user_id'])
    if not current_user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    # Ki·ªÉm tra quy·ªÅn admin
    if 'ADMIN' not in current_user.roles.split(','):
        return jsonify({'error': 'Ch·ªâ qu·∫£n tr·ªã vi√™n m·ªõi c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y'}), 403
    
    # L·∫•y m·∫≠t kh·∫©u t·ª´ request
    data = request.get_json()
    password = data.get('password', '')
    
    if not password:
        return jsonify({'error': 'Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ x√°c nh·∫≠n'}), 400
    
    # X√°c th·ª±c m·∫≠t kh·∫©u - s·ª≠ d·ª•ng method check_password c·ªßa User model
    if not current_user.check_password(password):
        return jsonify({'error': 'M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng. Vui l√≤ng th·ª≠ l·∫°i.'}), 400
    
    try:
        # ƒê·∫øm s·ªë l∆∞·ª£ng users s·∫Ω b·ªã x√≥a
        users_to_delete = User.query.filter(
            User.id != current_user.id,
            User.is_deleted == False
        ).all()
        
        total_count = len(users_to_delete)
        
        if total_count == 0:
            return jsonify({'error': 'Kh√¥ng c√≥ nh√¢n vi√™n n√†o ƒë·ªÉ x√≥a'}), 400
        
        # ƒê·∫øm s·ªë admin c√≤n l·∫°i (kh√¥ng t√≠nh user hi·ªán t·∫°i)
        other_admins = [u for u in users_to_delete if 'ADMIN' in u.roles.split(',')]
        other_admins_count = len(other_admins)
        
        # Cho ph√©p x√≥a t·∫•t c·∫£ nh√¢n vi√™n (kh√¥ng ph·∫£i admin)
        # User hi·ªán t·∫°i (admin) s·∫Ω ƒë∆∞·ª£c gi·ªØ l·∫°i t·ª± ƒë·ªông v√¨ kh√¥ng c√≥ trong users_to_delete
        
        # Soft delete t·∫•t c·∫£ users (tr·ª´ user hi·ªán t·∫°i v√† c√°c admin kh√°c)
        # Ch·ªâ x√≥a c√°c user kh√¥ng ph·∫£i admin - s·ª≠ d·ª•ng bulk update ƒë·ªÉ nhanh h∆°n
        # L·∫•y danh s√°ch ID c·ªßa c√°c admin ƒë·ªÉ lo·∫°i tr·ª´ (gi·ªØ l·∫°i t·∫•t c·∫£ admin)
        admin_ids = [u.id for u in users_to_delete if 'ADMIN' in u.roles.split(',')]
        
        # L·∫•y danh s√°ch ID c·ªßa c√°c user s·∫Ω b·ªã x√≥a (kh√¥ng ph·∫£i admin, kh√¥ng ph·∫£i user hi·ªán t·∫°i)
        user_ids_to_delete = [u.id for u in users_to_delete if 'ADMIN' not in u.roles.split(',')]
        
        if not user_ids_to_delete:
            return jsonify({
                'error': 'Kh√¥ng c√≥ nh√¢n vi√™n n√†o ƒë·ªÉ x√≥a. T·∫•t c·∫£ ng∆∞·ªùi d√πng c√≤n l·∫°i ƒë·ªÅu l√† qu·∫£n tr·ªã vi√™n v√† c·∫ßn ƒë∆∞·ª£c gi·ªØ l·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o h·ªá th·ªëng ho·∫°t ƒë·ªông.'
            }), 400
        
        # Bulk update: x√≥a t·∫•t c·∫£ users trong danh s√°ch (ch·ªâ nh√¢n vi√™n th∆∞·ªùng, kh√¥ng ph·∫£i admin)
        deleted_count = User.query.filter(
            User.id.in_(user_ids_to_delete)
        ).update({
            'is_deleted': True,
            'is_active': False
        }, synchronize_session=False)
        
        # Ghi log h√†nh ƒë·ªông
        remaining_admins = other_admins_count + 1  # +1 cho user hi·ªán t·∫°i
        log_audit_action(
            user_id=current_user.id,
            action='DELETE_ALL_USERS',
            table_name='users',
            record_id=None,
            old_values={'total_users': total_count, 'total_admins': other_admins_count + 1},
            new_values={
                'deleted_count': deleted_count, 
                'remaining_users': total_count - deleted_count + 1,  # +1 cho user hi·ªán t·∫°i
                'remaining_admins': remaining_admins
            }
        )
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'ƒê√£ x√≥a th√†nh c√¥ng {deleted_count} nh√¢n vi√™n. H·ªá th·ªëng v·∫´n c√≤n {remaining_admins} qu·∫£n tr·ªã vi√™n.',
            'deleted_count': deleted_count,
            'remaining_admins': remaining_admins
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå L·ªói khi x√≥a t·∫•t c·∫£ nh√¢n vi√™n: {e}")
        import traceback
        traceback.print_exc()
        # Tr·∫£ v·ªÅ JSON error response thay v√¨ HTML error page
        return jsonify({
            'success': False,
            'error': f'ƒê√£ x·∫£y ra l·ªói khi x√≥a nh√¢n vi√™n: {str(e)}'
        }), 500

@app.route('/admin/users/<int:user_id>/toggle_active', methods=['POST'])
@require_admin
def toggle_user_active(user_id):
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    if int(user_id) == int(session['user_id']):
        return jsonify({'error': 'Kh√¥ng th·ªÉ t·ª± kho√° t√†i kho·∫£n c·ªßa m√¨nh!'}), 400
    user = User.query.get_or_404(user_id)
    user.is_active = not user.is_active
    db.session.commit()
    return jsonify({
        'success': True,
        'is_active': user.is_active,
        'user_name': user.name,
        'status_label': 'Ho·∫°t ƒê·ªông' if user.is_active else 'ƒê√£ Kho√°',
        'status_class': 'bg-success' if user.is_active else 'bg-secondary'
    })

@app.route('/admin/attendance/<int:attendance_id>/export-overtime-pdf')
@require_admin
def export_overtime_pdf(attendance_id):
    try:
        # Load attendance v·ªõi t·∫•t c·∫£ c√°c relationship c·∫ßn thi·∫øt
        attendance = Attendance.query.options(
            joinedload(Attendance.user).load_only(User.name, User.employee_id, User.department),
            joinedload(Attendance.team_leader_signer).load_only(User.name),
            joinedload(Attendance.manager_signer).load_only(User.name)
        ).get_or_404(attendance_id)
        
        buffer = io.BytesIO()
        
        # S·ª≠ d·ª•ng h√†m create_overtime_pdf ƒë√£ t√°ch ri√™ng
        create_overtime_pdf(attendance, buffer)
        
        # T·∫°o t√™n file
        safe_name = remove_vietnamese_accents(attendance.user.name)
        safe_empid = str(attendance.user.employee_id)
        safe_date = attendance.date.strftime('%d%m%Y')
        filename = f"tangca_{safe_name}_{safe_empid}_{safe_date}.pdf"
        
        buffer.seek(0)
        return send_file(buffer, as_attachment=True, download_name=filename, mimetype='application/pdf')
        
    except Exception as e:
        print('PDF export error:', e)
        import traceback
        print(traceback.format_exc())
        return jsonify({'error': 'L·ªói khi sinh file PDF', 'detail': str(e)})

@app.route('/admin/attendance/<int:attendance_id>/test-signature-pdf')
@require_admin
def test_signature_on_overtime_pdf(attendance_id):
    """Test hi·ªÉn th·ªã ch·ªØ k√Ω tr√™n form tƒÉng ca th·ª±c t·∫ø"""
    try:
        # L·∫•y b·∫£n ghi attendance v·ªõi t·∫•t c·∫£ c√°c relationship c·∫ßn thi·∫øt
        attendance = Attendance.query.options(
            joinedload(Attendance.user).load_only(User.name, User.employee_id, User.department),
            joinedload(Attendance.team_leader_signer).load_only(User.name),
            joinedload(Attendance.manager_signer).load_only(User.name)
        ).get_or_404(attendance_id)
        
        # T·∫°o ch·ªØ k√Ω m·∫´u cho test
        sample_signature = create_sample_signature_base64()
        
        # T·∫°o b·∫£n copy c·ªßa attendance v·ªõi ch·ªØ k√Ω m·∫´u
        test_attendance = type('TestAttendance', (), {
            'id': attendance.id,
            'date': attendance.date,
            'check_in': attendance.check_in,
            'check_out': attendance.check_out,
            'break_time': attendance.break_time,
            'total_work_hours': attendance.total_work_hours,
            'overtime_before_22': attendance.overtime_before_22,
            'overtime_after_22': attendance.overtime_after_22,
            'note': attendance.note,
            'user': attendance.user,
            'signature': sample_signature,
            'team_leader_signature': sample_signature,
            'manager_signature': sample_signature,
            'team_leader_signer_id': attendance.team_leader_signer_id,
            'manager_signer_id': attendance.manager_signer_id,
            'team_leader_signer': attendance.team_leader_signer,
            'manager_signer': attendance.manager_signer,
            'approved': True,
            'approved_at': datetime.now()
        })()
        
        buffer = io.BytesIO()
        
        # T·∫°o PDF v·ªõi ch·ªØ k√Ω m·∫´u
        create_overtime_pdf(test_attendance, buffer)
        
        # T·∫°o t√™n file test
        safe_name = remove_vietnamese_accents(attendance.user.name)
        safe_empid = str(attendance.user.employee_id)
        safe_date = attendance.date.strftime('%d%m%Y')
        filename = f"test_chu_ky_tangca_{safe_name}_{safe_empid}_{safe_date}.pdf"
        
        buffer.seek(0)
        return send_file(buffer, as_attachment=True, download_name=filename, mimetype='application/pdf')
        
    except Exception as e:
        print('Test signature PDF error:', e)
        import traceback
        print(traceback.format_exc())
        return jsonify({'error': 'L·ªói khi t·∫°o PDF test ch·ªØ k√Ω', 'detail': str(e)})

def create_sample_signature_base64():
    """T·∫°o ch·ªØ k√Ω m·∫´u d·∫°ng base64"""
    try:
        # T·∫°o canvas ƒë·ªÉ v·∫Ω ch·ªØ k√Ω m·∫´u
        from PIL import Image, ImageDraw
        
        # T·∫°o ·∫£nh tr·∫Øng
        img = Image.new('RGB', (200, 100), color='white')
        draw = ImageDraw.Draw(img)
        
        # V·∫Ω ch·ªØ k√Ω m·∫´u v·ªõi m√†u xanh nh∆∞ b√∫t bi
        draw.line([(20, 50), (40, 30), (60, 70), (80, 40), (100, 60), (120, 35), (140, 65), (160, 45), (180, 55)], fill='blue', width=2)
        
        # Chuy·ªÉn th√†nh base64
        import io
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        buffer.seek(0)
        
        import base64
        return base64.b64encode(buffer.getvalue()).decode('utf-8')
        
    except Exception as e:
        print(f"Error creating sample signature: {e}")
        # Tr·∫£ v·ªÅ ch·ªØ k√Ω m·∫´u ƒë∆°n gi·∫£n n·∫øu c√≥ l·ªói
        return "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=="

# H√†m wrap_text cho ph·∫ßn ghi ch√∫ (ƒë·∫∑t ph√≠a tr√™n ƒëo·∫°n s·ª≠ d·ª•ng)
def wrap_text(text, font_name, font_size, max_width, canvas_obj):
    from reportlab.pdfbase.pdfmetrics import stringWidth
    words = text.split(' ')
    lines = []
    current_line = ''
    for word in words:
        test_line = current_line + (' ' if current_line else '') + word
        if stringWidth(test_line, font_name, font_size) <= max_width:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line)
            current_line = word
    if current_line:
        lines.append(current_line)
    return lines

@app.route('/admin/attendance/export-overtime-bulk')
@require_admin
def export_overtime_bulk():
    """
    T·∫°o ZIP ch·ª©a t·∫•t c·∫£ gi·∫•y tƒÉng ca ƒë√£ ph√™ duy·ªát.
    H·ªó tr·ª£ c√°c ch·∫ø ƒë·ªô:
    - Theo nƒÉm: year
    - Theo th√°ng c·ª• th·ªÉ trong nƒÉm: month, year
    - Theo kho·∫£ng ng√†y: date_from, date_to
    - Theo kho·∫£ng th√°ng/nƒÉm: month_from, year_from, month_to, year_to
    """
    try:
        # Tham s·ªë c≈© (gi·ªØ ƒë·ªÉ t∆∞∆°ng th√≠ch)
        month = request.args.get('month')  # C√≥ th·ªÉ None n·∫øu xu·∫•t theo nƒÉm
        year_param = request.args.get('year')

        # Tham s·ªë m·ªõi cho kho·∫£ng ng√†y / kho·∫£ng th√°ng-nƒÉm
        date_from_str = (request.args.get('date_from') or '').strip()
        date_to_str = (request.args.get('date_to') or '').strip()
        month_from = request.args.get('month_from')
        month_to = request.args.get('month_to')
        year_from = request.args.get('year_from')
        year_to = request.args.get('year_to')

        # X√¢y d·ª±ng query filter c∆° b·∫£n
        query_filter = [Attendance.approved == True]

        from datetime import date as _date
        import calendar

        date_from = None
        date_to = None

        # ∆Øu ti√™n kho·∫£ng ng√†y n·∫øu ƒë∆∞·ª£c truy·ªÅn v√†o
        if date_from_str or date_to_str or month_from or month_to or year_from or year_to:
            # 1) Kho·∫£ng ng√†y tr·ª±c ti·∫øp
            if date_from_str:
                date_from = validate_date(date_from_str)
            if date_to_str:
                date_to = validate_date(date_to_str)

            # 2) N·∫øu ch∆∞a c√≥ date_from/date_to nh∆∞ng c√≥ th√°ng/nƒÉm range
            # Ch·ªâ x·ª≠ l√Ω khi c√≥ ƒë·ªß tham s·ªë: c·∫ßn month_from v√† year_from t·ªëi thi·ªÉu
            if not (date_from or date_to) and month_from and year_from:
                try:
                    month_from_val = int(month_from)
                    year_from_val = int(year_from)
                    # N·∫øu c√≥ month_to v√† year_to th√¨ d√πng, n·∫øu kh√¥ng th√¨ d√πng month_from v√† year_from
                    if month_to and year_to:
                        month_to_val = int(month_to)
                        year_to_val = int(year_to)
                    else:
                        month_to_val = month_from_val
                        year_to_val = year_from_val

                    if not (1 <= month_from_val <= 12 and 1 <= month_to_val <= 12):
                        return abort(400, 'Tham s·ªë th√°ng kh√¥ng h·ª£p l·ªá')
                    if not (2000 <= year_from_val <= 2100 and 2000 <= year_to_val <= 2100):
                        return abort(400, 'Tham s·ªë nƒÉm kh√¥ng h·ª£p l·ªá')

                    date_from = _date(year_from_val, month_from_val, 1)
                    last_day = calendar.monthrange(year_to_val, month_to_val)[1]
                    date_to = _date(year_to_val, month_to_val, last_day)
                except Exception:
                    return abort(400, 'Tham s·ªë kho·∫£ng th√°ng/nƒÉm kh√¥ng h·ª£p l·ªá')

            if date_from:
                query_filter.append(Attendance.date >= date_from)
            if date_to:
                query_filter.append(Attendance.date <= date_to)

        else:
            # Gi·ªØ nguy√™n logic c≈©: b·∫Øt bu·ªôc c√≥ year, v√† optional month
            try:
                year = int(year_param or 0)
            except Exception:
                return abort(400, 'Tham s·ªë nƒÉm kh√¥ng h·ª£p l·ªá')

            if not (2000 <= year <= 2100):
                return abort(400, 'Tham s·ªë nƒÉm kh√¥ng h·ª£p l·ªá')

            query_filter.append(db.extract('year', Attendance.date) == year)

            # Th√™m filter th√°ng n·∫øu c√≥
            if month:
                month = int(month)
                if not (1 <= month <= 12):
                    return abort(400, 'Tham s·ªë th√°ng kh√¥ng h·ª£p l·ªá')
                query_filter.append(db.extract('month', Attendance.date) == month)

        # L·∫•y t·∫•t c·∫£ b·∫£n ghi Attendance ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát
        # T·ªëi ∆∞u: ch·ªâ l·∫•y c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
        attendances = Attendance.query.filter(*query_filter).options(
            joinedload(Attendance.user).load_only(User.name, User.employee_id, User.department)
        ).all()

        if not attendances:
            return jsonify({'error': 'Kh√¥ng c√≥ d·ªØ li·ªáu trong kho·∫£ng ƒë√£ ch·ªçn ƒë·ªÉ t·∫°o ZIP.', 'detail': 'Kh√¥ng c√≥ b·∫£n ghi n√†o trong kho·∫£ng ƒë√£ ch·ªçn'}), 404
        
        print(f'Creating ZIP for {len(attendances)} records...')
        
        # T·∫°o file ZIP trong b·ªô nh·ªõ v·ªõi compression level cao h∆°n
        zip_buffer = io.BytesIO()
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED, compresslevel=9) as zipf:
            for i, att in enumerate(attendances, 1):
                try:
                    # T·∫°o PDF cho t·ª´ng b·∫£n ghi
                    pdf_buffer = io.BytesIO()
                    
                    # G·ªçi h√†m t·∫°o PDF (t√°i s·ª≠ d·ª•ng logic t·ª´ export_overtime_pdf)
                    create_overtime_pdf(att, pdf_buffer)
                    
                    # ƒê·∫∑t t√™n file cho t·ª´ng PDF (lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát)
                    
                    safe_name = remove_vietnamese_accents(att.user.name) if att.user and att.user.name else str(att.id)
                    safe_empid = str(att.user.employee_id) if att.user and att.user.employee_id else str(att.id)
                    safe_date = att.date.strftime('%d%m%Y')
                    filename = f"tangca_{safe_name}_{safe_empid}_{safe_date}.pdf"
                    
                    # ƒê·∫£m b·∫£o buffer ·ªü ƒë·∫ßu file
                    pdf_buffer.seek(0)
                    zipf.writestr(filename, pdf_buffer.read())
                    
                    # Log progress m·ªói 10 records
                    if i % 10 == 0:
                        print(f'Processed {i}/{len(attendances)} records...')
                    
                except Exception as e:
                    print(f'Error creating PDF for attendance {att.id}: {e}')
                    continue
        
        zip_buffer.seek(0)
        
        # T·∫°o t√™n file ZIP theo ng√†y xu·∫•t (√°p d·ª•ng cho m·ªçi lo·∫°i kho·∫£ng)
        from datetime import datetime as _dt
        zip_filename = f"tangca_bulk_{_dt.now().strftime('%Y%m%d')}.zip"
            
        print(f'ZIP creation completed: {zip_filename}')
        return send_file(zip_buffer, as_attachment=True, download_name=zip_filename, mimetype='application/zip')
        
    except Exception as e:
        print('Bulk export error:', e)
        return jsonify({'error': 'L·ªói khi xu·∫•t file ZIP', 'detail': str(e)})

# Cache fonts ƒë·ªÉ tr√°nh ƒëƒÉng k√Ω l·∫°i m·ªói l·∫ßn
_fonts_registered = False

def register_pdf_fonts():
    """ƒêƒÉng k√Ω fonts cho PDF m·ªôt l·∫ßn duy nh·∫•t"""
    global _fonts_registered
    if _fonts_registered:
        return
    
    try:
        # Th·ª≠ ƒëƒÉng k√Ω DejaVuSans cho ti·∫øng Vi·ªát
        registerFont(TTFont('DejaVuSans', 'static/fonts/DejaVuSans.ttf'))
        registerFont(TTFont('DejaVuSans-Bold', 'static/fonts/DejaVuSans.ttf'))  # S·ª≠ d·ª•ng c√πng font cho bold
        
        # ƒêƒÉng k√Ω NotoSansJP cho ti·∫øng Nh·∫≠t
        registerFont(TTFont('NotoSansJP', 'static/fonts/NotoSansJP-Regular.ttf'))
        registerFont(TTFont('NotoSansJP-Bold', 'static/fonts/NotoSansJP-Bold.ttf'))
        registerFont(TTFont('NotoSansJP-Medium', 'static/fonts/NotoSansJP-Medium.ttf'))
        registerFont(TTFont('NotoSansJP-Light', 'static/fonts/NotoSansJP-Light.ttf'))
        registerFont(TTFont('NotoSansJP-Black', 'static/fonts/NotoSansJP-Black.ttf'))
        registerFont(TTFont('NotoSansJP-ExtraBold', 'static/fonts/NotoSansJP-ExtraBold.ttf'))
        registerFont(TTFont('NotoSansJP-ExtraLight', 'static/fonts/NotoSansJP-ExtraLight.ttf'))
        registerFont(TTFont('NotoSansJP-SemiBold', 'static/fonts/NotoSansJP-SemiBold.ttf'))
        registerFont(TTFont('NotoSansJP-Thin', 'static/fonts/NotoSansJP-Thin.ttf'))
        
        _fonts_registered = True
        print('PDF fonts registered successfully')
    except Exception as e:
        print('PDF font register error:', e)
        # Fallback: s·ª≠ d·ª•ng font m·∫∑c ƒë·ªãnh
        _fonts_registered = True

def fix_base64_padding(base64_string):
    """
    S·ª≠a l·ªói base64 padding ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªô d√†i l√† b·ªôi s·ªë c·ªßa 4
    """
    if not base64_string:
        return base64_string
    
    # Lo·∫°i b·ªè kho·∫£ng tr·∫Øng v√† k√Ω t·ª± xu·ªëng d√≤ng
    base64_string = base64_string.strip()
    
    # T√≠nh s·ªë k√Ω t·ª± c·∫ßn th√™m ƒë·ªÉ ƒë·∫°t b·ªôi s·ªë c·ªßa 4
    padding_length = len(base64_string) % 4
    if padding_length > 0:
        # Th√™m d·∫•u = ƒë·ªÉ ƒë·∫°t b·ªôi s·ªë c·ªßa 4
        base64_string += '=' * (4 - padding_length)
        # print(f"DEBUG: Fixed base64 padding, added {4 - padding_length} padding characters")
    
    return base64_string

def looks_like_fernet_token(token):
    """
    Nh·∫≠n di·ªán nhanh chu·ªói c√≥ kh·∫£ nƒÉng l√† Fernet token ƒë·ªÉ tr√°nh th·ª≠ gi·∫£i m√£ sai d·ªØ li·ªáu
    """
    try:
        if not isinstance(token, str) or len(token) < 50:
            return False
        normalized = token.strip().replace(' ', '+')
        padding_length = len(normalized) % 4
        if padding_length > 0:
            normalized += '=' * (4 - padding_length)
        raw = base64.urlsafe_b64decode(normalized.encode('utf-8'))
        return len(raw) > 9 and raw[0] == 0x80
    except Exception:
        return False

def process_signature_for_pdf(signature_data):
    """
    X·ª≠ l√Ω ch·ªØ k√Ω ƒë·ªÉ hi·ªÉn th·ªã trong PDF - IMPROVED VERSION v·ªõi x·ª≠ l√Ω l·ªói base64 an to√†n
    """
    if not signature_data:
        # print("DEBUG: No signature data provided")
        return None
    
    try:
        if isinstance(signature_data, str):
            # print(f"DEBUG: Processing signature string, length: {len(signature_data)}")
            
            # N·∫øu l√† base64 t·ª´ frontend (data:image/png;base64,...)
            if signature_data.startswith('data:image'):
                # print("DEBUG: Found data:image format, extracting base64")
                try:
                    # Ki·ªÉm tra ƒë·ªãnh d·∫°ng data:image
                    if not signature_data.startswith('data:image/png;base64,'):
                        # print("DEBUG: Not PNG format, trying to convert")
                        # Th·ª≠ chuy·ªÉn ƒë·ªïi t·ª´ c√°c ƒë·ªãnh d·∫°ng kh√°c
                        if signature_data.startswith('data:image/jpeg;base64,'):
                            signature_data = signature_data.replace('data:image/jpeg;base64,', 'data:image/png;base64,')
                    
                    base64_data = signature_data.split(',')[1]
                    
                    # S·ª≠a l·ªói base64 padding
                    base64_data = fix_base64_padding(base64_data)
                    
                    # Ki·ªÉm tra base64 c√≥ h·ª£p l·ªá kh√¥ng
                    try:
                        decoded = base64.b64decode(base64_data)
                        # print(f"DEBUG: Base64 decode successful, decoded length: {len(decoded)}")
                        
                        # Ki·ªÉm tra c√≥ ph·∫£i l√† ·∫£nh PNG kh√¥ng
                        if len(decoded) >= 8 and decoded.startswith(b'\x89PNG\r\n\x1a\n'):
                            # print("DEBUG: Valid PNG image confirmed")
                            return base64_data
                        else:
                            # print("DEBUG: Not a valid PNG image")
                            return None
                    except Exception as decode_error:
                        # print(f"DEBUG: Base64 decode failed after padding fix: {decode_error}")
                        return None
                        
                except Exception as e:
                    # print(f"DEBUG: Base64 decode failed: {e}")
                    return None
                    
            # N·∫øu l√† base64 thu·∫ßn t√∫y
            elif len(signature_data) > 100:
                try:
                    # S·ª≠a l·ªói base64 padding tr∆∞·ªõc khi decode
                    fixed_signature = fix_base64_padding(signature_data)
                    
                    # Th·ª≠ decode ƒë·ªÉ ki·ªÉm tra
                    decoded = base64.b64decode(fixed_signature)
                    # print(f"DEBUG: Valid base64 signature found, decoded length: {len(decoded)}")
                    
                    # Ki·ªÉm tra c√≥ ph·∫£i l√† ·∫£nh PNG kh√¥ng
                    if len(decoded) >= 8 and decoded.startswith(b'\x89PNG\r\n\x1a\n'):
                        # print("DEBUG: Valid PNG image confirmed")
                        return fixed_signature
                    else:
                        # print("DEBUG: Not a valid PNG image")
                        return None
                        
                except Exception as base64_error:
                    print(f"DEBUG: Base64 decode failed: {base64_error}")
                    # Ch·ªâ th·ª≠ gi·∫£i m√£ n·∫øu th·∫≠t s·ª± tr√¥ng gi·ªëng Fernet token
                    if looks_like_fernet_token(signature_data):
                        try:
                            decrypted = signature_manager.decrypt_signature(signature_data)
                            # print(f"DEBUG: Decrypted signature, length: {len(decrypted) if decrypted else 0}")
                            
                            if decrypted:
                                # N·∫øu gi·∫£i m√£ th√†nh c√¥ng v√† c√≥ data:image
                                if decrypted.startswith('data:image'):
                                    base64_data = decrypted.split(',')[1]
                                    try:
                                        # S·ª≠a l·ªói base64 padding sau khi gi·∫£i m√£
                                        base64_data = fix_base64_padding(base64_data)
                                        
                                        # Ki·ªÉm tra base64 sau khi gi·∫£i m√£
                                        decoded = base64.b64decode(base64_data)
                                        # print(f"DEBUG: Decrypted base64 decode successful, decoded length: {len(decoded)}")
                                        
                                        # Ki·ªÉm tra c√≥ ph·∫£i l√† ·∫£nh PNG kh√¥ng
                                        if len(decoded) >= 8 and decoded.startswith(b'\x89PNG\r\n\x1a\n'):
                                            # print("DEBUG: Valid PNG image confirmed after decryption")
                                            return base64_data
                                        else:
                                            # print("DEBUG: Not a valid PNG image after decryption")
                                            return None
                                            
                                    except Exception as e:
                                        # print(f"DEBUG: Decrypted base64 decode failed: {e}")
                                        return None
                                # N·∫øu gi·∫£i m√£ th√†nh c√¥ng v√† l√† base64 thu·∫ßn t√∫y
                                elif len(decrypted) > 100:
                                    try:
                                        # S·ª≠a l·ªói base64 padding sau khi gi·∫£i m√£
                                        fixed_decrypted = fix_base64_padding(decrypted)
                                        
                                        decoded = base64.b64decode(fixed_decrypted)
                                        # print(f"DEBUG: Decrypted base64 decode successful, decoded length: {len(decoded)}")
                                        
                                        # Ki·ªÉm tra c√≥ ph·∫£i l√† ·∫£nh PNG kh√¥ng
                                        if len(decoded) >= 8 and decoded.startswith(b'\x89PNG\r\n\x1a\n'):
                                            # print("DEBUG: Valid PNG image confirmed after decryption")
                                            return fixed_decrypted
                                        else:
                                            # print("DEBUG: Not a valid PNG image after decryption")
                                            return None
                                            
                                    except Exception as e:
                                        # print(f"DEBUG: Decrypted base64 decode failed: {e}")
                                        return None
                        except Exception:
                            # Silent on decryption failure to avoid noisy logs; logic unchanged
                            return None
                    else:
                        print("DEBUG: Not valid base64 and not a Fernet token, skip decryption")
                        return None
            else:
                print(f"DEBUG: Short signature string: {signature_data}")
                return signature_data
        else:
            print(f"DEBUG: Non-string signature data type: {type(signature_data)}")
            return None
    except Exception as e:
        print(f"Error processing signature: {e}")
        import traceback
        traceback.print_exc()
        return None

def draw_signature_with_proper_scaling(canvas, signature_data, x, y, box_width, box_height):
    """
    V·∫Ω ch·ªØ k√Ω v·ªõi t·ª∑ l·ªá ƒë√∫ng v√† m√†u xanh nh∆∞ b√∫t bi - S·ª¨ D·ª§NG SIGNATURE FIT ADAPTER
    """
    if not signature_data:
        print("DEBUG: No signature data provided to draw")
        return False
    
    try:
        # S·ª≠ d·ª•ng signature fit adapter ƒë·ªÉ ƒëi·ªÅu ch·ªânh ch·ªØ k√Ω v·ª´a kh√≠t v·ªõi √¥
        from utils.signature_manager import signature_manager
        
        # X√°c ƒë·ªãnh lo·∫°i √¥ d·ª±a tr√™n k√≠ch th∆∞·ªõc
        box_type = 'default'
        if box_width >= 140 and box_height >= 70:
            box_type = 'manager'  # √î qu·∫£n l√Ω
        elif box_width >= 120 and box_height >= 60:
            box_type = 'supervisor'  # √î c·∫•p tr√™n
        elif box_width >= 100 and box_height >= 50:
            box_type = 'applicant'  # √î ng∆∞·ªùi xin ph√©p
        
        print(f"DEBUG: Using signature fit adapter for box type: {box_type}")
        
        # ƒêi·ªÅu ch·ªânh ch·ªØ k√Ω v·ª´a kh√≠t v·ªõi √¥
        fitted_signature = signature_manager.fit_signature_to_form_box(
            signature_data, 
            box_type=box_type
        )
        
        if not fitted_signature:
            print("DEBUG: Failed to fit signature to box")
            return False
                
        print(f"DEBUG: Fitted signature length: {len(fitted_signature)}")
        
        # Decode base64
        try:
            if fitted_signature.startswith('data:image'):
                fitted_signature = fitted_signature.split(',')[1]
            
            decoded_data = base64.b64decode(fitted_signature)
            print(f"DEBUG: Successfully decoded fitted signature, length: {len(decoded_data)}")
            
        except Exception as decode_error:
            print(f"DEBUG: Failed to decode fitted signature: {decode_error}")
            return False
        
        # M·ªü v√† chu·∫©n h√≥a ·∫£nh, ƒë·ªìng th·ªùi chu·∫©n b·ªã ƒë·ªÉ n·ªôi suy theo k√≠ch th∆∞·ªõc v·∫Ω th·ª±c t·∫ø
        try:
            from PIL import Image
            import io
            
            pil_image = Image.open(io.BytesIO(decoded_data))
            if pil_image.mode != 'RGBA':
                pil_image = pil_image.convert('RGBA')
        except Exception as img_open_err:
            print(f"DEBUG: Failed to open image for processing: {img_open_err}")
            return False
        
        # T√≠nh t·ª∑ l·ªá ƒë·ªÉ gi·ªØ nguy√™n t·ª∑ l·ªá khung h√¨nh v√† v·ª´a kh√≠t v·ªõi √¥
        img_width, img_height = pil_image.size
        print(f"DEBUG: Fitted image size (PIL): {img_width}x{img_height}")
        aspect_ratio = img_width / img_height
        box_aspect_ratio = box_width / box_height
        
        # T√≠nh k√≠ch th∆∞·ªõc th·ª±c t·∫ø ƒë·ªÉ v·∫Ω - TƒÇNG FILL RATIO ƒê·ªÇ CH·ªÆ K√ù L·ªöN H∆†N KHI IN
        # ƒêi·ªÅu ch·ªânh ƒë·ªông d·ª±a tr√™n k√≠ch th∆∞·ªõc ch·ªØ k√Ω g·ªëc
        fill_ratio = 0.96  # TƒÉng t·ª´ 92% l√™n 96% ƒë·ªÉ ch·ªØ k√Ω l·ªõn h∆°n khi in
        
        # Ki·ªÉm tra k√≠ch th∆∞·ªõc ch·ªØ k√Ω ƒë√£ ƒë∆∞·ª£c fit
        # N·∫øu ch·ªØ k√Ω ƒë√£ ƒë∆∞·ª£c fit ƒë√∫ng k√≠ch th∆∞·ªõc √¥, s·ª≠ d·ª•ng tr·ª±c ti·∫øp
        if abs(img_width - box_width) < box_width * 0.1 and abs(img_height - box_height) < box_height * 0.1:
            # Ch·ªØ k√Ω ƒë√£ ƒë∆∞·ª£c fit g·∫ßn ƒë√∫ng k√≠ch th∆∞·ªõc √¥, s·ª≠ d·ª•ng fill_ratio
            draw_width = box_width * fill_ratio
            draw_height = box_height * fill_ratio
        else:
            # Ch·ªØ k√Ω ch∆∞a ƒë∆∞·ª£c fit, t√≠nh to√°n l·∫°i ƒë·ªÉ fill t·ªët
            if aspect_ratio > box_aspect_ratio:
                # ·∫¢nh r·ªông h∆°n, cƒÉn theo chi·ªÅu r·ªông
                draw_width = box_width * fill_ratio
                draw_height = draw_width / aspect_ratio
            else:
                # ·∫¢nh cao h∆°n, cƒÉn theo chi·ªÅu cao
                draw_height = box_height * fill_ratio
                draw_width = draw_height * aspect_ratio
            
            # ƒê·∫£m b·∫£o kh√¥ng v∆∞·ª£t qu√° k√≠ch th∆∞·ªõc √¥
            if draw_width > box_width:
                draw_width = box_width * fill_ratio
                draw_height = draw_width / aspect_ratio
            if draw_height > box_height:
                draw_height = box_height * fill_ratio
                draw_width = draw_height * aspect_ratio
            
            # ƒê·∫£m b·∫£o fill t·ªëi thi·ªÉu 80% n·∫øu ch·ªØ k√Ω qu√° nh·ªè
            min_fill = 0.80
            if draw_width < box_width * min_fill or draw_height < box_height * min_fill:
                # Scale l√™n ƒë·ªÉ ƒë·∫°t min_fill
                width_scale = (box_width * min_fill) / draw_width if draw_width < box_width * min_fill else 1.0
                height_scale = (box_height * min_fill) / draw_height if draw_height < box_height * min_fill else 1.0
                scale_factor = min(width_scale, height_scale)
                draw_width = draw_width * scale_factor
                draw_height = draw_height * scale_factor
                
                # ƒê·∫£m b·∫£o kh√¥ng v∆∞·ª£t qu√° fill_ratio sau khi scale
                if draw_width > box_width * fill_ratio:
                    draw_width = box_width * fill_ratio
                    draw_height = draw_width / aspect_ratio
                if draw_height > box_height * fill_ratio:
                    draw_height = box_height * fill_ratio
                    draw_width = draw_height * aspect_ratio
        
        # Ki·ªÉm tra k√≠ch th∆∞·ªõc v·∫Ω h·ª£p l·ªá
        if draw_width <= 0 or draw_height <= 0:
            print(f"DEBUG: Invalid draw dimensions: {draw_width}x{draw_height}")
            return False
        
        # N·ªôi suy ·∫£nh t·ªõi ƒë·ªô ph√¢n gi·∫£i m·ª•c ti√™u d·ª±a tr√™n k√≠ch th∆∞·ªõc v·∫Ω ƒë·ªÉ lu√¥n s·∫Øc n√©t
        try:
            target_dpi = 300  # TƒÉng t·ª´ 220 l√™n 300 DPI ƒë·ªÉ ch·ªØ k√Ω s·∫Øc n√©t h∆°n khi in
            target_px_w = max(1, int(draw_width * target_dpi / 72.0))
            target_px_h = max(1, int(draw_height * target_dpi / 72.0))
            
            if pil_image.size != (target_px_w, target_px_h):
                pil_image = pil_image.resize((target_px_w, target_px_h), Image.Resampling.LANCZOS)
            
            # Chuy·ªÉn m√†u ch·ªØ k√Ω sang xanh b√∫t bi sau khi ƒë√£ resize ƒë·ªÉ gi·ªØ c·∫°nh m·ªãn
            data = pil_image.getdata()
            blue_pen_color = (0, 0, 255, 255)
            new_data = []
            for item in data:
                if item[0] < 50 and item[1] < 50 and item[2] < 50 and item[3] > 100:
                    new_data.append(blue_pen_color)
                else:
                    new_data.append(item)
            new_image = Image.new('RGBA', pil_image.size)
            new_image.putdata(new_data)
            
            new_image_buffer = io.BytesIO()
            new_image.save(new_image_buffer, format='PNG')
            new_image_buffer.seek(0)
            img = ImageReader(new_image_buffer)
            print("DEBUG: Image prepared and ImageReader created at target DPI")
        except Exception as prep_err:
            print(f"DEBUG: Failed to prepare high-DPI image: {prep_err}")
            try:
                img = ImageReader(io.BytesIO(decoded_data))
            except Exception:
                return False
        
        # T√≠nh v·ªã tr√≠ cƒÉn gi·ªØa
        x_offset = (box_width - draw_width) / 2
        y_offset = (box_height - draw_height) / 2
        
        # V·∫Ω n·ªÅn tr·∫Øng cho √¥ ch·ªØ k√Ω ƒë·ªÉ tr√°nh b·ªã ƒëen
        canvas.setFillColor(colors.white)
        canvas.rect(x, y, box_width, box_height, fill=1, stroke=0)
        canvas.setFillColor(colors.black)  # Reset v·ªÅ m√†u ƒëen cho text
        
        # V·∫Ω ch·ªØ k√Ω v·ªõi k√≠ch th∆∞·ªõc ƒë√£ t√≠nh to√°n
        try:
            final_x = x + x_offset
            final_y = y + y_offset
            
            # Ki·ªÉm tra v·ªã tr√≠ h·ª£p l·ªá
            if final_x < 0 or final_y < 0:
                print(f"DEBUG: Invalid position: ({final_x}, {final_y})")
                return False
                
            # Ki·ªÉm tra v·ªã tr√≠ c√≥ v∆∞·ª£t qu√° trang kh√¥ng
            if final_x + draw_width > canvas._pagesize[0] or final_y + draw_height > canvas._pagesize[1]:
                print(f"DEBUG: Position out of page bounds")
                return False
            
            canvas.drawImage(img, final_x, final_y, width=draw_width, height=draw_height)
            print(f"DEBUG: Blue signature drawn successfully with signature fit adapter")
            print(f"DEBUG: Fitted size: {img_width}x{img_height}, Draw size: {draw_width:.1f}x{draw_height:.1f}")
            print(f"DEBUG: Position: ({final_x:.1f}, {final_y:.1f})")
            return True
        except Exception as draw_error:
            print(f"DEBUG: Failed to draw image: {draw_error}")
            import traceback
            traceback.print_exc()
            return False
        
    except Exception as e:
        print(f"DEBUG: Error drawing signature with signature fit adapter: {e}")
        import traceback
        traceback.print_exc()
        return False

def create_signature_placeholder(canvas, x, y, box_width, box_height, text="Ch·ªØ k√Ω"):
    """T·∫°o placeholder cho ch·ªØ k√Ω khi kh√¥ng th·ªÉ hi·ªÉn th·ªã"""
    try:
        # V·∫Ω n·ªÅn tr·∫Øng
        canvas.setFillColor(colors.white)
        canvas.rect(x, y, box_width, box_height, fill=1, stroke=0)
        
        # V·∫Ω border
        canvas.setStrokeColor(colors.grey)
        canvas.setLineWidth(0.5)
        canvas.rect(x, y, box_width, box_height, stroke=1, fill=0)
        
        # V·∫Ω text placeholder
        canvas.setFillColor(colors.grey)
        canvas.setFont("DejaVuSans", 8)
        
        # CƒÉn gi·ªØa text
        text_width = canvas.stringWidth(text, "DejaVuSans", 8)
        text_x = x + (box_width - text_width) / 2
        text_y = y + box_height / 2 + 3  # +3 ƒë·ªÉ cƒÉn gi·ªØa theo chi·ªÅu d·ªçc
        
        canvas.drawString(text_x, text_y, text)
        
        # Reset m√†u
        canvas.setFillColor(colors.black)
        canvas.setStrokeColor(colors.black)
        
        return True
    except Exception as e:
        print(f"DEBUG: Error creating signature placeholder: {e}")
        return False

def create_overtime_pdf(attendance, buffer):
    """T·∫°o PDF gi·∫•y tƒÉng ca cho m·ªôt b·∫£n ghi attendance"""
    # ƒêƒÉng k√Ω fonts m·ªôt l·∫ßn duy nh·∫•t
    register_pdf_fonts()
    
    user = attendance.user
    employee_signature = attendance.signature if attendance.signature else None
    team_leader_signature = attendance.team_leader_signature if attendance.team_leader_signature else None
    manager_signature = attendance.manager_signature if attendance.manager_signature else None
    
    # L·∫•y th√¥ng tin ng∆∞·ªùi k√Ω t·ª´ database
    from database.models import User
    
    # Th√¥ng tin ng∆∞·ªùi k√Ω employee (ng∆∞·ªùi t·∫°o ƒë∆°n)
    employee_signer_name = user.name if user else "Kh√¥ng x√°c ƒë·ªãnh"
    
    # Th√¥ng tin ng∆∞·ªùi k√Ω team leader v√† manager - load relationship v√† x·ª≠ l√Ω an to√†n
    team_leader_signer_name = "Ch∆∞a k√Ω"
    manager_signer_name = "Ch∆∞a k√Ω"
    
    # Ki·ªÉm tra v√† l·∫•y t√™n ng∆∞·ªùi k√Ω team leader
    if hasattr(attendance, 'team_leader_signer') and attendance.team_leader_signer:
        team_leader_signer_name = attendance.team_leader_signer.name
    elif hasattr(attendance, 'team_leader_signer_id') and attendance.team_leader_signer_id:
        # N·∫øu c√≥ ID nh∆∞ng relationship ch∆∞a load, query tr·ª±c ti·∫øp
        team_leader = db.session.get(User, attendance.team_leader_signer_id)
        if team_leader:
            team_leader_signer_name = team_leader.name
    
    # Ki·ªÉm tra v√† l·∫•y t√™n ng∆∞·ªùi k√Ω manager
    if hasattr(attendance, 'manager_signer') and attendance.manager_signer:
        manager_signer_name = attendance.manager_signer.name
    elif hasattr(attendance, 'manager_signer_id') and attendance.manager_signer_id:
        # N·∫øu c√≥ ID nh∆∞ng relationship ch∆∞a load, query tr·ª±c ti·∫øp
        manager = db.session.get(User, attendance.manager_signer_id)
        if manager:
            manager_signer_name = manager.name
    


    c = canvas.Canvas(buffer, pagesize=A4)
    width, height = A4
    margin = 30
    y = height - margin

    # Header: B·∫£ng 6 c·ªôt nh∆∞ trong h√¨nh
    header_data = [
        [
            Paragraph('<b>DMI HU·∫æ</b>', ParagraphStyle('h', fontName='DejaVuSans', fontSize=9, alignment=1)),
            Paragraph('<b>Á∑èÂãô<br/>T·ªîNG V·ª§</b>', ParagraphStyle('h', fontName='NotoSansJP', fontSize=8, alignment=1)),
            Paragraph('<b>ÂàÜÈ°ûÁï™Âè∑Ôºö<br/>S·ªë hi·ªáu ph√¢n lo·∫°iÔºö</b>', ParagraphStyle('h', fontName='NotoSansJP', fontSize=7, alignment=1)),
            Paragraph('', ParagraphStyle('h', fontName='DejaVuSans', fontSize=8, alignment=1)),  # √î tr·∫Øng sau √¥ 3
            Paragraph('<b>Ë®òÂÖ• FORM<br/>NH·∫¨P FORM</b>', ParagraphStyle('h', fontName='NotoSansJP', fontSize=8, alignment=1)),
            Paragraph('<b>Form‰ΩúÊàêÔºö<br/>T√°c th√†nhÔºö</b>', ParagraphStyle('h', fontName='NotoSansJP', fontSize=7, alignment=1)),
            Paragraph('', ParagraphStyle('h', fontName='DejaVuSans', fontSize=8, alignment=1)),  # √î tr·∫Øng sau √¥ t√°c th√†nh
            Paragraph('', ParagraphStyle('h', fontName='DejaVuSans', fontSize=8, alignment=1)),  # √î tr·∫Øng th·ª© 2 sau √¥ t√°c th√†nh
        ]
    ]
    
    col_widths = [60, 80, 100, 50, 80, 80, 50, 50]  # T·ªïng = 570, g·∫ßn b·∫±ng width A4
    header_table_width = sum(col_widths)
    x_header = (width - header_table_width) / 2
    header_table = Table(header_data, colWidths=col_widths, rowHeights=25)
    header_table.setStyle(TableStyle([
        ('ALIGN', (0,0), (-1,-1), 'CENTER'),
        ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),
        ('BOX', (0,0), (-1,-1), 0.5, colors.black),
        ('INNERGRID', (0,0), (-1,-1), 0.5, colors.black),
        ('FONTNAME', (0,0), (-1,-1), 'DejaVuSans'),
    ]))
    header_table.wrapOn(c, width-2*margin, 30)
    header_table.drawOn(c, x_header, y-25)
    y -= 40

    # Th√¥ng tin c√¥ng ty
    c.setFont("DejaVuSans", 10)
    c.drawString(margin, y, "C√¥ng ty TNHH DMI HU·∫æ")
    y -= 12
    c.setFont("DejaVuSans", 8)
    c.drawString(margin, y, "174 B√† Tri·ªáu- t√≤a nh√† 4 t·∫ßng Phong Ph√∫ Plaza, ph∆∞·ªùng Ph√∫ H·ªôi, Th√†nh ph·ªë Hu·∫ø, T·ªânh Th·ª´a Thi√™n Hu·∫ø,Vi·ªát Nam.")
    y -= 25

    # Ti√™u ƒë·ªÅ ch√≠nh
    c.setFont("DejaVuSans", 14)
    c.drawCentredString(width/2, y, "GI·∫§Y ƒê·ªÄ NGH·ªä TƒÇNG CA/ƒêI L√ÄM NG√ÄY NGH·ªà")
    y -= 16
    c.setFont("NotoSansJP", 11)
    c.drawCentredString(width/2, y, "(ÊÆãÊ•≠/‰ºëÊó•Âá∫Âã§Áî≥Ë´ãÊõ∏)")
    y -= 20
    c.setFont("DejaVuSans", 9)
    c.drawCentredString(width/2, y, "N·ªôp t·∫°i b·ªô ph·∫≠n t·ªïng v·ª•")
    c.setFont("NotoSansJP-Light", 9)
    c.drawCentredString(width/2, y-10, "(Á∑èÂãôÈÉ®ÁΩ≤„ÅßÊèêÂá∫)")
    y -= 30

    # Ph·∫ßn checkbox v√† th√¥ng tin c√° nh√¢n
    c.setFont("DejaVuSans", 10)
    
    # D√≤ng checkbox
    checkbox_y = y
    c.rect(margin, checkbox_y-3, 8, 8)  # Checkbox tƒÉng ca
    c.drawString(margin+15, checkbox_y, "TƒÉng ca /")
    c.setFont("NotoSansJP", 10)
    c.drawString(margin+70, checkbox_y, "ÊÆãÊ•≠")
    
    c.rect(margin+200, checkbox_y-3, 8, 8)  # Checkbox ƒëi l√†m ng√†y ngh·ªâ
    c.setFont("DejaVuSans", 10)
    c.drawString(margin+215, checkbox_y, "ƒêi l√†m ng√†y ngh·ªâ /")
    c.setFont("NotoSansJP", 10)
    c.drawString(margin+320, checkbox_y, "‰ºëÊó•Âá∫Âã§")
    y -= 20

    # Th√¥ng tin nh√¢n vi√™n
    c.setFont("NotoSansJP-Light", 10)
    c.drawString(margin, y, f"H·ªç t√™n (Ê∞èÂêç)Ôºö{user.name}")
    c.drawString(margin+200, y, f"Nh√≥m („ÉÅ„Éº„É†)Ôºö{user.department}")
    c.drawString(margin+350, y, f"M√£ NV (Á§æÂì°„Ç≥„Éº„Éâ): {user.employee_id}")
    y -= 15
    
    c.drawString(margin, y, f"L√Ω do tƒÉng ca (ÁêÜÁî±): {attendance.note}")
    y -= 15
    
    c.drawString(margin, y, "ƒê·ªÅ ngh·ªã c√¥ng ty ch·∫•p thu·∫≠n cho t√¥i ƒë∆∞·ª£c tƒÉng ca/ƒëi l√†m v√†o ng√†y ngh·ªâ.")
    y -= 10
    c.setFont("NotoSansJP-Light", 9)
    c.drawString(margin, y, "ÊÆãÊ•≠/‰ºëÊó•Âá∫Âã§„ÇíË®±ÂèØ„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ")
    y -= 25
    
    # Th√™m kho·∫£ng c√°ch tr∆∞·ªõc khi v·∫Ω b·∫£ng th·ªùi gian
    y -= 15

    # B·∫£ng ch·∫•m c√¥ng chi ti·∫øt
    table_y = y
    table_width = width - 2*margin
    
    # ƒê·ªãnh nghƒ©a style cho ti√™u ƒë·ªÅ
    header_style_vn = ParagraphStyle('header_vn', fontName='DejaVuSans', fontSize=8, alignment=1)
    header_style_jp = ParagraphStyle('header_jp', fontName='NotoSansJP', fontSize=8, alignment=1)
    
    # T·∫°o chu·ªói th·ªùi gian l√†m vi·ªác
    time_str = f"{attendance.check_in.strftime('%H:%M') if attendance.check_in else '-'} - {attendance.check_out.strftime('%H:%M') if attendance.check_out else '-'}"
    
    # X√°c ƒë·ªãnh h√¨nh th·ª©c (1 ho·∫∑c 2)
    holiday_type = getattr(attendance, 'holiday_type', None)
    special_day_types = {'weekend', 'vietnamese_holiday', 'japanese_holiday'}
    form_type = "2" if holiday_type in special_day_types else "1"
    
    # H√†ng 1: Ti·∫øng Vi·ªát
    header_row1 = [
        Paragraph('No.', header_style_vn),
        Paragraph('NG√ÄY TH√ÅNG NƒÇM', header_style_vn),
        Paragraph('H√åNH TH·ª®C', header_style_vn),
        Paragraph('CA L√ÄM VI·ªÜC', header_style_vn),
        Paragraph('GI·ªú V√ÄO - GI·ªú RA', header_style_vn),
        Paragraph('Th·ªùi gian ngh·ªâ ƒë·ªëi ·ª©ng c√¥ng vi·ªác', header_style_vn),
        Paragraph('X√ÅC NH·∫¨N', header_style_vn)
    ]
    # H√†ng 2: Ti·∫øng Nh·∫≠t/H√°n
    header_row2 = [
        Paragraph('', header_style_jp),
        Paragraph('Êó•‰ªò', header_style_jp),
        Paragraph('Á®ÆÈ°û', header_style_jp),
        Paragraph('„Ç∑„Éï„Éà', header_style_jp),
        Paragraph('Âá∫Âã§ÊôÇÈñì-ÈÄÄÂã§ÊôÇÈñì', header_style_jp),
        Paragraph('Ê•≠ÂãôÂØæÂøúÊôÇÈñì', header_style_jp),
        Paragraph('„É©„Éú„Éû„ÉçÊâøË™ç', header_style_jp)
    ]
    # H√†ng d·ªØ li·ªáu
    # T√°ch ri√™ng th·ªùi gian v√† ƒë·ªëi ·ª©ng ƒë·ªÉ d·ªÖ ƒë·ªçc
    time_info = f"{attendance.check_in.strftime('%H:%M') if attendance.check_in else '-'} - {attendance.check_out.strftime('%H:%M') if attendance.check_out else '-'}"
    
    # T√≠nh t·ªïng th·ªùi gian ƒë·ªëi ·ª©ng - ch·ªâ hi·ªÉn th·ªã 1 gi√° tr·ªã duy nh·∫•t
    total_comp_time = 0.0
    
    # C·ªông t·∫•t c·∫£ c√°c lo·∫°i ƒë·ªëi ·ª©ng - S·ª¨ D·ª§NG C·ªòT MINUTES M·ªöI
    total_comp_minutes = 0
    total_comp_minutes += attendance.comp_time_regular_minutes or 0
    total_comp_minutes += attendance.comp_time_overtime_minutes or 0
    total_comp_minutes += attendance.comp_time_ot_before_22_minutes or 0
    total_comp_minutes += attendance.comp_time_ot_after_22_minutes or 0
    total_comp_minutes += attendance.overtime_comp_time_minutes or 0
    
    total_comp_time = total_comp_minutes / 60.0
    
    # ƒê·ªãnh d·∫°ng t·ªïng th·ªùi gian ƒë·ªëi ·ª©ng
    if total_comp_time > 0:
        comp_time_display = attendance._format_hours_minutes(total_comp_time)
    else:
        comp_time_display = "0:00"
    
    # T·∫°o d·ªØ li·ªáu h√†ng v·ªõi th√¥ng tin r√µ r√†ng
    row_data = [
        '1',
        attendance.date.strftime('%d/%m/%Y'),
        form_type,
        attendance.shift_code or '-',
        time_info,
        comp_time_display,  # Ch·ªâ hi·ªÉn th·ªã 1 gi√° tr·ªã t·ªïng th·ªùi gian ƒë·ªëi ·ª©ng
        ''
    ]
    
    table_data = [header_row1, header_row2, row_data]
    col_widths = [30, 80, 50, 65, 80, 110, 70]  # T·ªïng nh·ªè h∆°n width, lu√¥n c√≤n margin hai b√™n
    row_heights = [40, 14, 18]  # H√†ng d·ªØ li·ªáu b√¨nh th∆∞·ªùng v√¨ ch·ªâ hi·ªÉn th·ªã 1 gi√° tr·ªã
    
    detail_table_width = sum(col_widths)
    x_detail = (width - detail_table_width) / 2
    table = Table(table_data, colWidths=col_widths, rowHeights=row_heights)
    table.setStyle(TableStyle([
        ('ALIGN', (0,0), (-1,-1), 'CENTER'),
        ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),
        ('BOX', (0,0), (-1,-1), 0.5, colors.black),
        ('INNERGRID', (0,0), (-1,-1), 0.5, colors.black),
        ('FONTNAME', (0,0), (-1,0), 'DejaVuSans'),
        ('FONTNAME', (0,1), (-1,1), 'NotoSansJP'),
        ('FONTSIZE', (0,0), (-1,1), 8),
        ('FONTSIZE', (0,2), (-1,2), 9),
        # X√≥a d√≤ng k·∫ª ngang gi·ªØa h√†ng 0 v√† 1
        ('LINEBELOW', (0,0), (-1,0), 0, colors.white),
    ]))
    table.wrapOn(c, width-2*margin, 50)
    table.drawOn(c, x_detail, table_y - 46)
    y = table_y - 46 - 36  # c·∫≠p nh·∫≠t y cho ph·∫ßn ti·∫øp theo
    
    # Ghi ch√∫ d∆∞·ªõi b·∫£ng
    note_sections = [
        ("DejaVuSans", 8, "* Ghi ch√∫: T·∫°i c·ªôt H√¨nh th·ª©c: TƒÉng ca ng√†y b√¨nh th∆∞·ªùng ghi s·ªë 1 ƒêi l√†m ng√†y ngh·ªâ, tƒÉng ca ghi s·ªë 2"),
        ("NotoSansJP-Light", 8, "ÂÇôËÄÉÔºöÂπ≥Êó•„ÅÆÊÆãÊ•≠„ÅÆÂ†¥ÂêàÔºö1Áï™„ÇíË®òÂÖ•„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ ‰ºëÊó•Âá∫Âã§„ÅÆÂ†¥ÂêàÔºö2Áï™„ÇíË®òÂÖ•„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"),
        ("DejaVuSans", 8, "*V·ªÅ vi·ªác ngh·ªâ gi·∫£i lao (60 ph√∫t) ng√†y th∆∞·ªùng trong tu·∫ßn, tr∆∞·ªùng h·ª£p n·∫øu ngh·ªâ d√†i h∆°n v√¨ ƒë·ªëi ·ª©ng c√¥ng vi·ªác ÔºöH√£y n·ªôp ƒë∆°n cho b·ªô ph·∫≠n vƒÉn ph√≤ng."),
        ("NotoSansJP-Light", 8, "ÈÄöÂ∏∏Ôºà1„ÅÆÂ†¥ÂêàÔºâ„ÅÆÊòº‰ºëÊÜ©Ôºà60ÂàÜÔºâ„Å´„ÄÅ‰ºëÊÜ©ÈÄî‰∏≠„ÅßÊ•≠ÂãôÂØæÂøú„Åô„ÇãÂ†¥Âêà„ÄÅÁî≥Ë´ã„Çí„Åó„Å¶‰∏ã„Åï„ÅÑ„ÄÇ"),
        ("DejaVuSans", 8, "*Trong tr∆∞·ªùng h·ª£p kh√¥ng xin ph√©p tr∆∞·ªõc, th√¨ tƒÉng ca v√† ƒëi l√†m ng√†y ngh·ªâ kh√¥ng ƒë∆∞·ª£c ch·∫•p nh·∫≠n."),
        ("DejaVuSans", 8, "Ph·∫£i ghi gi·∫•y tƒÉng ca sau khi tƒÉng ca (ch·∫≠m nh·∫•t l√† ng√†y mai) ,sang ng√†y m·ªët ghi tƒÉng ca th√¨ kh√¥ng ƒë∆∞·ª£c ch·∫•p nh·∫≠n."),
        ("NotoSansJP-Light", 8, "‚Äª1ÂàÜÂçò‰Ωç„ÅßÁî≥Ë´ã„Åó„Å¶‰∏ã„Åï„ÅÑ„ÄÇÁî≥Ë´ã„Çí„Åó„Å™„ÅÑÈôê„Çä„ÄÅÊÆãÊ•≠„Å®‰ºëÊó•Âá∫Âã§„ÅØÂèçÊò†„Åï„Çå„Åæ„Åõ„Çì„ÄÇ"),
        ("NotoSansJP-Light", 8, "ÂøÖ„Åö„ÄÅÊÆãÊ•≠„Çí„Åó„ÅüÊó•„Å´Áî≥Ë´ã„Åô„Çã„Åì„Å®„ÄÇÔºàÊ¨°„ÅÆÊó•„Åæ„Åß„ÅÆÁî≥Ë´ã„ÅØË™ç„ÇÅ„Åæ„Åô„Åå„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅÆÁî≥Ë´ã„ÅØË™ç„ÇÅ„Åæ„Åõ„ÇìÔºâ")
    ]
    max_note_width = width - 2*margin - 10
    for i, (font_name, font_size, text) in enumerate(note_sections):
        lines = wrap_text(text, font_name, font_size, max_note_width, c)
        for line in lines:
            c.setFont(font_name, font_size)
            c.drawString(margin, y, line)
            y -= font_size + 1
        # Th√™m d√≤ng tr·∫Øng sau m·ªói ƒëo·∫°n b·∫Øt ƒë·∫ßu b·∫±ng * (tr·ª´ ƒëo·∫°n cu·ªëi)
        if text.startswith('*') and i < len(note_sections)-1:
            y -= font_size + 1
    
    # Th√™m kho·∫£ng c√°ch gi·ªØa ph·∫ßn ghi ch√∫ v√† d√≤ng ng√†y th√°ng
    y -= 25
    # Ng√†y th√°ng - ƒê·∫∑t ·ªü v·ªã tr√≠ cao h∆°n ƒë·ªÉ kh√¥ng b·ªã ƒë√®
    date_y = y + 20  # ƒê·∫∑t d√≤ng ng√†y th√°ng cao h∆°n
    c.setFont("DejaVuSans", 10)
    c.drawRightString(width-margin, date_y, f"Hu·∫ø, ng√†y {attendance.date.day} th√°ng {attendance.date.month} nƒÉm {attendance.date.year}")
    y -= 10  # ƒê·∫©y d√≤ng ng√†y th√°ng xu·ªëng th·∫•p h∆°n
    y -= 95  # TƒÉng th√™m kho·∫£ng c√°ch ƒë·ªÉ kh√¥ng b·ªã ƒë√® l√™n ph·∫ßn ghi ch√∫ v√† d√≤ng ng√†y th√°ng
    
    # --- CƒÉn ch·ªânh l·∫°i ph·∫ßn ch·ªØ k√Ω v√† ti√™u ƒë·ªÅ ph√≠a tr√™n ---
    # S·ªë √¥ v√† k√≠ch th∆∞·ªõc - TƒÇNG K√çCH TH∆Ø·ªöC √î ƒê·ªÇ CH·ªÆ K√ù L·ªöN H∆†N KHI IN
    num_boxes = 3
    box_width = 170  # TƒÉng t·ª´ 140 l√™n 170 ƒë·ªÉ ch·ªØ k√Ω l·ªõn h∆°n khi in
    box_height = 90  # TƒÉng t·ª´ 70 l√™n 90 ƒë·ªÉ c√≥ nhi·ªÅu kh√¥ng gian cho ch·ªØ k√Ω
    box_spacing = 20  # Gi·∫£m kho·∫£ng c√°ch ƒë·ªÉ 3 √¥ v·∫´n v·ª´a trang
    total_width = num_boxes * box_width + (num_boxes - 1) * box_spacing
    start_x = (width - total_width) / 2
    box_y = y  # y l√† v·ªã tr√≠ ƒë√°y c√°c √¥
    label_font_size = 10
    sublabel_font_size = 8
    # Ti√™u ƒë·ªÅ c√°c √¥
    box_titles = [
        ("Qu·∫£n l√≠", "„É©„Éú„Éû„Éç„Ç∏„É£„Éº"),
        ("C·∫•p tr√™n tr·ª±c ti·∫øp", "‚ñ°ÂÆ§Èï∑„ÄÄ‚ñ°„É™„Éº„ÉÄ„Éº„ÄÄ‚ñ°‰ªñ"),
        ("Ng∆∞·ªùi xin ph√©p", "Áî≥Ë´ãËÄÖ")
    ]
    # V·∫Ω ti√™u ƒë·ªÅ v√† sublabel cƒÉn gi·ªØa tr√™n m·ªói √¥
    for i, (title, sublabel) in enumerate(box_titles):
        x = start_x + i * (box_width + box_spacing)
        # CƒÉn gi·ªØa ti√™u ƒë·ªÅ
        c.setFont("DejaVuSans", label_font_size)
        c.drawCentredString(x + box_width/2, box_y + box_height + 22, title)
        c.setFont("NotoSansJP-Light", sublabel_font_size)
        c.drawCentredString(x + box_width/2, box_y + box_height + 10, sublabel)
    # V·∫Ω c√°c √¥ ch·ªØ k√Ω v·ªõi border - S·∫º ƒê∆Ø·ª¢C V·∫º L·∫†I SAU KHI V·∫º CH·ªÆ K√ù
    signature_boxes = []
    for i in range(num_boxes):
        x = start_x + i * (box_width + box_spacing)
        signature_boxes.append((x, box_y, box_width, box_height))
    # Hi·ªÉn th·ªã ch·ªØ k√Ω ho·∫∑c (ch∆∞a k√Ω) cƒÉn gi·ªØa trong t·ª´ng √¥
    # Qu·∫£n l√Ω
    x0 = start_x
    signature_area_height = box_height - 20  # TƒÉng v√πng ch·ªØ k√Ω ƒë·ªÉ ch·ªØ k√Ω l·ªõn h∆°n khi in
    signature_y = box_y + 20  # Ch·ªØ k√Ω ·ªü ph·∫ßn tr√™n (c√°ch ƒë√°y 20px)
    signature_center_y = signature_y + signature_area_height/2 - 8/2  # CƒÉn gi·ªØa ch·ªØ k√Ω
    name_y = box_y + 8  # T√™n ng∆∞·ªùi k√Ω ·ªü ph·∫ßn d∆∞·ªõi (c√°ch ƒë√°y 8px)
    
    if manager_signature:
        print(f"DEBUG: Processing manager signature for PDF")
        debug_signature_data(manager_signature, "manager")
        success = draw_signature_with_proper_scaling(c, manager_signature, x0, signature_y, box_width, signature_area_height)
        if not success:
            print(f"DEBUG: Failed to draw manager signature, creating placeholder")
            create_signature_placeholder(c, x0, signature_y, box_width, signature_area_height, "L·ªói hi·ªÉn th·ªã")
    else:
        c.setFont("DejaVuSans", 8)
        c.drawCentredString(x0 + box_width/2, signature_center_y, "(ch∆∞a k√Ω)")
    
    # Th√™m t√™n ng∆∞·ªùi k√Ω qu·∫£n l√Ω b√™n trong √¥ ch·ªØ k√Ω (ph√≠a d∆∞·ªõi ch·ªØ k√Ω)
    c.setFont("DejaVuSans", 8)
    c.drawCentredString(x0 + box_width/2, name_y, manager_signer_name)
    
    # Tr∆∞·ªüng nh√≥m
    x1 = start_x + 1 * (box_width + box_spacing)
    
    if team_leader_signature:
        print(f"DEBUG: Processing team leader signature for PDF")
        debug_signature_data(team_leader_signature, "team_leader")
        success = draw_signature_with_proper_scaling(c, team_leader_signature, x1, signature_y, box_width, signature_area_height)
        if not success:
            print(f"DEBUG: Failed to draw team leader signature, creating placeholder")
            create_signature_placeholder(c, x1, signature_y, box_width, signature_area_height, "L·ªói hi·ªÉn th·ªã")
    else:
        c.setFont("DejaVuSans", 8)
        c.drawCentredString(x1 + box_width/2, signature_center_y, "(ch∆∞a k√Ω)")
    
    # Th√™m t√™n ng∆∞·ªùi k√Ω tr∆∞·ªüng nh√≥m b√™n trong √¥ ch·ªØ k√Ω (ph√≠a d∆∞·ªõi ch·ªØ k√Ω)
    c.setFont("DejaVuSans", 8)
    c.drawCentredString(x1 + box_width/2, name_y, team_leader_signer_name)
    
    # Nh√¢n vi√™n
    x2 = start_x + 2 * (box_width + box_spacing)
    
    if employee_signature:
        print(f"DEBUG: Processing employee signature for PDF")
        debug_signature_data(employee_signature, "employee")
        success = draw_signature_with_proper_scaling(c, employee_signature, x2, signature_y, box_width, signature_area_height)
        if not success:
            print(f"DEBUG: Failed to draw employee signature, creating placeholder")
            create_signature_placeholder(c, x2, signature_y, box_width, signature_area_height, "L·ªói hi·ªÉn th·ªã")
    else:
        c.setFont("DejaVuSans", 8)
        c.drawCentredString(x2 + box_width/2, signature_center_y, "(ch∆∞a k√Ω)")
    
    # Th√™m t√™n ng∆∞·ªùi k√Ω nh√¢n vi√™n b√™n trong √¥ ch·ªØ k√Ω (ph√≠a d∆∞·ªõi ch·ªØ k√Ω)
    c.setFont("DejaVuSans", 8)
    c.drawCentredString(x2 + box_width/2, name_y, employee_signer_name)
    
    # V·∫Ω l·∫°i border cho t·∫•t c·∫£ c√°c √¥ ch·ªØ k√Ω sau khi ƒë√£ v·∫Ω ch·ªØ k√Ω
    c.setStrokeColor(colors.black)
    c.setLineWidth(0.5)
    for x, y, w, h in signature_boxes:
        c.rect(x, y, w, h, stroke=1, fill=0)
    
    c.save()

@app.route('/forgot-password', methods=['GET', 'POST'])
def forgot_password():
    if request.method == 'POST':
        email = request.form.get('email')
        if not email:
            flash('Vui l√≤ng nh·∫≠p email ƒë√£ ƒëƒÉng k√Ω!', 'error')
            return render_template('forgot_password.html')
        user = User.query.filter_by(email=email).first()
        if not user:
            flash('Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n v·ªõi email n√†y!', 'error')
            return render_template('forgot_password.html')
        # T·∫°o token
        import secrets
        token = secrets.token_urlsafe(48)
        expires_at = datetime.utcnow() + timedelta(hours=1)
        reset_token = PasswordResetToken(user_id=user.id, token=token, expires_at=expires_at)
        db.session.add(reset_token)
        db.session.commit()
        # G·ª≠i email
        reset_link = url_for('reset_password', token=token, _external=True)
        email_sent = send_reset_email(user.email, user.name, reset_link)
        if email_sent:
            flash('ƒê√£ g·ª≠i email h∆∞·ªõng d·∫´n ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u. Vui l√≤ng ki·ªÉm tra h·ªôp th∆∞!', 'success')
        else:
            flash('Kh√¥ng th·ªÉ g·ª≠i email. Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.', 'error')
        return redirect(url_for('login'))
    return render_template('forgot_password.html')

@app.route('/reset-password/<token>', methods=['GET', 'POST'])
def reset_password(token):
    reset_token = PasswordResetToken.query.filter_by(token=token, used=False).first()
    if not reset_token or reset_token.is_expired():
        flash('Link ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n!', 'error')
        return redirect(url_for('login'))
    user = db.session.get(User, reset_token.user_id)
    if request.method == 'POST':
        password = request.form.get('password')
        confirm = request.form.get('confirm')
        if not password or not confirm or password != confirm:
            flash('M·∫≠t kh·∫©u kh√¥ng kh·ªõp ho·∫∑c kh√¥ng h·ª£p l·ªá!', 'error')
            return render_template('reset_password.html', token=token)
        user.set_password(password)
        db.session.commit()
        reset_token.used = True
        db.session.commit()
        flash('ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p l·∫°i.', 'success')
        return redirect(url_for('login'))
    return render_template('reset_password.html', token=token)

def send_reset_email(to_email, to_name, reset_link):
    # C·∫•u h√¨nh SMTP t·ª´ config
    smtp_server = app.config['SMTP_SERVER']
    smtp_port = app.config['SMTP_PORT']
    smtp_user = app.config['SMTP_USER']
    smtp_password = app.config['SMTP_PASSWORD']
    from_email = app.config['MAIL_FROM']
    
    # Ki·ªÉm tra v√† ƒë·∫∑t gi√° tr·ªã m·∫∑c ƒë·ªãnh cho from_email n·∫øu kh√¥ng c√≥
    if not from_email:
        from_email = smtp_user if smtp_user else 'noreply@dmi.com'
    
    subject = 'ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u h·ªá th·ªëng ch·∫•m c√¥ng DMI'
    
    # Plain text version
    text_body = f"""Xin ch√†o {to_name},

B·∫°n v·ª´a y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u cho t√†i kho·∫£n h·ªá th·ªëng ch·∫•m c√¥ng DMI.

Vui l√≤ng copy link d∆∞·ªõi ƒë√¢y v√†o tr√¨nh duy·ªát ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u (c√≥ hi·ªáu l·ª±c trong 1 gi·ªù):

{reset_link}

L∆∞u √Ω: N·∫øu b·∫°n kh√¥ng y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u, vui l√≤ng b·ªè qua email n√†y.

Tr√¢n tr·ªçng,
H·ªá th·ªëng ch·∫•m c√¥ng DMI"""
    
    # HTML version
    html_body = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u</title>
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f9f9f9; padding: 30px; border-radius: 10px; border: 1px solid #ddd;">
            <h2 style="color: #1976d2; margin-bottom: 20px;">ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u h·ªá th·ªëng ch·∫•m c√¥ng DMI</h2>
            
            <p>Xin ch√†o <strong>{to_name}</strong>,</p>
            
            <p>B·∫°n v·ª´a y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u cho t√†i kho·∫£n h·ªá th·ªëng ch·∫•m c√¥ng DMI.</p>
            
            <p>Vui l√≤ng nh·∫•n v√†o link d∆∞·ªõi ƒë√¢y ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u (c√≥ hi·ªáu l·ª±c trong 1 gi·ªù):</p>
            
            <div style="text-align: center; margin: 30px 0;">
                <a href="{reset_link}" style="background-color: #1976d2; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;">ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u</a>
            </div>
            
            <p style="font-size: 14px; color: #666;">Ho·∫∑c copy link n√†y v√†o tr√¨nh duy·ªát:</p>
            <p style="word-break: break-all; background-color: #f5f5f5; padding: 10px; border-radius: 5px; font-size: 12px;">{reset_link}</p>
            
            <p style="color: #d32f2f; font-size: 14px;"><strong>L∆∞u √Ω:</strong> N·∫øu b·∫°n kh√¥ng y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u, vui l√≤ng b·ªè qua email n√†y.</p>
            
            <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;">
            
            <p style="color: #666; font-size: 14px;">Tr√¢n tr·ªçng,<br>
            <strong>H·ªá th·ªëng ch·∫•m c√¥ng DMI</strong></p>
        </div>
    </body>
    </html>
    """
    
    # Ki·ªÉm tra c·∫•u h√¨nh SMTP tr∆∞·ªõc khi g·ª≠i email
    if not all([smtp_server, smtp_port, smtp_user, smtp_password]):
        print('SMTP configuration incomplete. Cannot send email.')
        return False
    
    # Create multipart message
    from email.mime.multipart import MIMEMultipart
    msg = MIMEMultipart('alternative')
    msg['Subject'] = Header(subject, 'utf-8')
    msg['From'] = formataddr((str(Header('DMI Attendance', 'utf-8')), from_email))
    msg['To'] = to_email
    
    # Attach both plain text and HTML versions
    text_part = MIMEText(text_body, 'plain', 'utf-8')
    html_part = MIMEText(html_body, 'html', 'utf-8')
    
    msg.attach(text_part)
    msg.attach(html_part)
    
    try:
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(smtp_user, smtp_password)
        server.sendmail(from_email, [to_email], msg.as_string())
        server.quit()
        return True
    except Exception as e:
        print('Email send error:', e)
        # Kh√¥ng raise ƒë·ªÉ kh√¥ng l·ªô th√¥ng tin cho user
        return False

# ƒê·ªïi m·∫≠t kh·∫©u khi ƒë√£ ƒëƒÉng nh·∫≠p
@app.route('/change-password-legacy', methods=['GET', 'POST'])
@login_required
def change_password_legacy():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    user = db.session.get(User, session['user_id'])
    if request.method == 'POST':
        old_password = request.form.get('old_password')
        new_password = request.form.get('new_password')
        confirm = request.form.get('confirm')
        if not user.check_password(old_password):
            flash('M·∫≠t kh·∫©u c≈© kh√¥ng ƒë√∫ng!', 'error')
            return render_template('change_password.html')
        if not new_password or new_password != confirm:
            flash('M·∫≠t kh·∫©u m·ªõi kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng kh·ªõp!', 'error')
            return render_template('change_password.html')
        user.set_password(new_password)
        db.session.commit()
        flash('ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng!', 'success')
        return redirect(url_for('dashboard'))
    return render_template('change_password.html')

@app.route('/api/signature/debug/<int:attendance_id>')
@require_admin
def debug_signature(attendance_id):
    """Debug endpoint ƒë·ªÉ ki·ªÉm tra ch·ªØ k√Ω trong database"""
    try:
        attendance = db.session.get(Attendance, attendance_id)
        if not attendance:
            return jsonify({'error': 'Attendance not found'}), 404
        
        debug_info = {
            'attendance_id': attendance_id,
            'employee_signature': {
                'exists': bool(attendance.signature),
                'length': len(attendance.signature) if attendance.signature else 0,
                'type': type(attendance.signature).__name__ if attendance.signature else None,
                'starts_with_data_image': attendance.signature.startswith('data:image') if attendance.signature else False,
                'processed': process_signature_for_pdf(attendance.signature) is not None if attendance.signature else False
            },
            'team_leader_signature': {
                'exists': bool(attendance.team_leader_signature),
                'length': len(attendance.team_leader_signature) if attendance.team_leader_signature else 0,
                'type': type(attendance.team_leader_signature).__name__ if attendance.team_leader_signature else None,
                'starts_with_data_image': attendance.team_leader_signature.startswith('data:image') if attendance.team_leader_signature else False,
                'processed': process_signature_for_pdf(attendance.team_leader_signature) is not None if attendance.team_leader_signature else False
            },
            'manager_signature': {
                'exists': bool(attendance.manager_signature),
                'length': len(attendance.manager_signature) if attendance.manager_signature else 0,
                'type': type(attendance.manager_signature).__name__ if attendance.manager_signature else None,
                'starts_with_data_image': attendance.manager_signature.startswith('data:image') if attendance.manager_signature else False,
                'processed': process_signature_for_pdf(attendance.manager_signature) is not None if attendance.manager_signature else False
            }
        }
        
        # Th√™m debug chi ti·∫øt cho t·ª´ng ch·ªØ k√Ω
        if attendance.signature:
            debug_signature_data(attendance.signature, "employee_debug")
        if attendance.team_leader_signature:
            debug_signature_data(attendance.team_leader_signature, "team_leader_debug")
        if attendance.manager_signature:
            debug_signature_data(attendance.manager_signature, "manager_debug")
        
        return jsonify(debug_info)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Th√™m h√†m debug ch·ªØ k√Ω
def debug_signature_data(signature_data, source="unknown"):
    """Debug chi ti·∫øt d·ªØ li·ªáu ch·ªØ k√Ω"""
    print(f"=== DEBUG SIGNATURE DATA ({source}) ===")
    if not signature_data:
        print("Signature data is None or empty")
        return
    
    print(f"Type: {type(signature_data)}")
    print(f"Length: {len(signature_data)}")
    
    if isinstance(signature_data, str):
        print(f"Starts with 'data:image': {signature_data.startswith('data:image')}")
        print(f"First 100 chars: {signature_data[:100]}")
        print(f"Last 100 chars: {signature_data[-100:]}")
        
        # Ki·ªÉm tra c√≥ ph·∫£i base64 kh√¥ng
        try:
            decoded = base64.b64decode(signature_data)
            print(f"Valid base64: Yes, decoded length: {len(decoded)}")
        except Exception:
            print("Valid base64: No")
            
            # Th·ª≠ gi·∫£i m√£ n·∫øu c√≥ th·ªÉ
            try:
                decrypted = signature_manager.decrypt_signature(signature_data)
                if decrypted:
                    print(f"Decrypted successfully, length: {len(decrypted)}")
                    print(f"Decrypted starts with 'data:image': {decrypted.startswith('data:image')}")
                else:
                    print("Decryption failed or returned empty")
            except Exception as e:
                print(f"Decryption error: {e}")
    
    print("=== END DEBUG ===")

@app.route('/personal-signature', methods=['GET', 'POST'])
@login_required
def personal_signature():
    """Trang qu·∫£n l√Ω ch·ªØ k√Ω c√° nh√¢n"""
    if request.method == 'POST':
        signature = request.form.get('signature')
        if signature:
            # ‰ΩøÁî®Á≠æÂêçÂ§ÑÁêÜÂô®‰ºòÂåñÁ≠æÂêçË¥®Èáè
            processed_signature = signature_manager.process_signature_for_display(signature)
            
            user = db.session.get(User, session['user_id'])
            user.personal_signature = processed_signature
            db.session.commit()
            
            # ËÆ∞ÂΩïÁ≠æÂêçÊìç‰Ωú
            signature_manager.log_signature_action(
                user_id=user.id,
                action='UPDATE_PERSONAL',
                signature_type='personal_signature'
            )
            
            flash('ƒê√£ c·∫≠p nh·∫≠t ch·ªØ k√Ω c√° nh√¢n th√†nh c√¥ng! H·ªá th·ªëng ƒë√£ t·ª± ƒë·ªông t·ªëi ∆∞u h√≥a ch·∫•t l∆∞·ª£ng ch·ªØ k√Ω.', 'success')
            return redirect(url_for('personal_signature'))
    
    user = db.session.get(User, session['user_id'])
    return render_template('personal_signature.html', user=user)

@app.route('/settings', methods=['GET', 'POST'])
def settings():
    """Trang c√†i ƒë·∫∑t th√¥ng tin c√° nh√¢n v√† ch·ªØ k√Ω"""
    print("DEBUG: Settings route accessed")
    print("DEBUG: Session user_id:", session.get('user_id'))
    print("DEBUG: Session keys:", list(session.keys()))

    if 'user_id' not in session:
        print("DEBUG: No user_id in session, redirecting to login")
        return redirect(url_for('login'))

    user = db.session.get(User, session['user_id'])
    if not user:
        print("DEBUG: User not found, redirecting to login")
        session.clear()
        flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
        return redirect(url_for('login'))

    # Ki·ªÉm tra role - MANAGER v√† TEAM_LEADER kh√¥ng ƒë∆∞·ª£c truy c·∫≠p settings
    current_role = session.get('current_role', user.roles.split(',')[0] if user.roles else 'EMPLOYEE')
    if current_role in ['MANAGER', 'TEAM_LEADER']:
        flash('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p trang c√†i ƒë·∫∑t v·ªõi vai tr√≤ hi·ªán t·∫°i!', 'error')
        return redirect(url_for('dashboard'))

    # Ki·ªÉm tra user c√≥ active kh√¥ng
    if not user.is_active:
        session.clear()
        flash('T√†i kho·∫£n ƒë√£ b·ªã kh√≥a!', 'error')
        return redirect(url_for('login'))
    
    # Ki·ªÉm tra session timeout
    if check_session_timeout():
        flash('Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n!', 'error')
        return redirect(url_for('login'))
    
    # C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông cu·ªëi
    update_session_activity()
    
    print("DEBUG: User found:", user.name)
    
    if request.method == 'POST':
        # Ph√¢n nh√°nh action: l∆∞u ch·ªØ k√Ω ho·∫∑c ƒë·ªïi m·∫≠t kh·∫©u
        action = request.form.get('action')
        if action == 'change_password':
            current_password = request.form.get('current_password')
            new_password = request.form.get('new_password')
            confirm_password = request.form.get('confirm_password')

            if not current_password or not new_password or not confirm_password:
                flash('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß m·∫≠t kh·∫©u hi·ªán t·∫°i v√† m·∫≠t kh·∫©u m·ªõi', 'error')
                return redirect(url_for('settings'))
            if new_password != confirm_password:
                flash('X√°c nh·∫≠n m·∫≠t kh·∫©u m·ªõi kh√¥ng kh·ªõp', 'error')
                return redirect(url_for('settings'))

            # Verify current password
            try:
                from werkzeug.security import check_password_hash, generate_password_hash
                if not user.password or not check_password_hash(user.password, current_password):
                    flash('M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ƒë√∫ng', 'error')
                    return redirect(url_for('settings'))
                # Update password
                user.password = generate_password_hash(new_password)
                db.session.commit()
                flash('ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng', 'success')
                return redirect(url_for('settings'))
            except Exception as e:
                db.session.rollback()
                flash('C√≥ l·ªói khi ƒë·ªïi m·∫≠t kh·∫©u', 'error')
                return redirect(url_for('settings'))
        else:
            # L∆∞u ch·ªØ k√Ω c√° nh√¢n
            signature = request.form.get('signature')
            if signature:
                user.personal_signature = signature
                try:
                    db.session.commit()
                    flash('L∆∞u ch·ªØ k√Ω th√†nh c√¥ng!', 'success')
                    return redirect(url_for('settings'))
                except Exception as e:
                    db.session.rollback()
                    flash('ƒê√£ x·∫£y ra l·ªói khi l∆∞u ch·ªØ k√Ω', 'error')
            else:
                flash('Ch∆∞a c√≥ ch·ªØ k√Ω ƒë·ªÉ l∆∞u', 'error')
    
    return render_template('settings.html', user=user)

@app.route('/settings/check-password', methods=['POST'])
def check_current_password():
    """AJAX: Ki·ªÉm tra m·∫≠t kh·∫©u hi·ªán t·∫°i c√≥ ƒë√∫ng kh√¥ng"""
    if 'user_id' not in session:
        return jsonify({'ok': False, 'error': 'Unauthorized'}), 401
    try:
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'ok': False, 'error': 'User not found'}), 404
        data = request.get_json(silent=True) or {}
        current_password = (data.get('current_password') or '').strip()
        from werkzeug.security import check_password_hash
        if user.password and check_password_hash(user.password, current_password):
            return jsonify({'ok': True})
        return jsonify({'ok': False}), 200
    except Exception as e:
        return jsonify({'ok': False, 'error': 'Internal error'}), 500

@app.route('/change-password', methods=['GET', 'POST'])
def change_password():
    """Trang ƒë·ªïi m·∫≠t kh·∫©u ri√™ng bi·ªát"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    user = db.session.get(User, session['user_id'])
    if not user:
        session.clear()
        flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
        return redirect(url_for('login'))
    if check_session_timeout():
        flash('Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n!', 'error')
        return redirect(url_for('login'))
    update_session_activity()

    if request.method == 'POST':
        current_password = request.form.get('current_password')
        new_password = request.form.get('new_password')
        confirm_password = request.form.get('confirm_password')
        if not current_password or not new_password or not confirm_password:
            flash('Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß m·∫≠t kh·∫©u', 'error')
            return redirect(url_for('change_password'))
        if new_password != confirm_password:
            flash('X√°c nh·∫≠n m·∫≠t kh·∫©u m·ªõi kh√¥ng kh·ªõp', 'error')
            return redirect(url_for('change_password'))
        from werkzeug.security import check_password_hash, generate_password_hash
        # H·ªá th·ªëng d√πng tr∆∞·ªùng password_hash v√† method check_password/set_password trong model User
        # ∆Øu ti√™n d√πng method n·∫øu c√≥, fallback d√πng tr·ª±c ti·∫øp password_hash
        try:
            valid_current = user.check_password(current_password)
        except Exception:
            valid_current = bool(getattr(user, 'password_hash', None) and check_password_hash(user.password_hash, current_password))
        if not valid_current:
            flash('M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ƒë√∫ng', 'error')
            return redirect(url_for('change_password'))
        try:
            try:
                user.set_password(new_password)
            except Exception:
                user.password_hash = generate_password_hash(new_password)
            db.session.commit()
            flash('ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng', 'success')
            return redirect(url_for('settings'))
        except Exception:
            db.session.rollback()
            flash('C√≥ l·ªói khi ƒë·ªïi m·∫≠t kh·∫©u', 'error')
            return redirect(url_for('change_password'))

    # L·∫•y role c·ªßa user ƒë·ªÉ hi·ªÉn th·ªã sidebar ph√π h·ª£p
    user_role = user.roles.split(',')[0] if user.roles else 'EMPLOYEE'

    return render_template('change_password.html', user=user, role=user_role)

@app.route('/signature-test', methods=['GET', 'POST'])
def signature_test():
    """Trang test hi·ªÉn th·ªã ch·ªØ k√Ω cho c·∫£ 3 vai tr√≤"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    user = db.session.get(User, session['user_id'])
    if not user:
        session.clear()
        flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
        return redirect(url_for('login'))
    
    # Ki·ªÉm tra user c√≥ active kh√¥ng
    if not user.is_active:
        session.clear()
        flash('T√†i kho·∫£n ƒë√£ b·ªã kh√≥a!', 'error')
        return redirect(url_for('login'))
    
    # Ki·ªÉm tra session timeout
    if check_session_timeout():
        flash('Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n!', 'error')
        return redirect(url_for('login'))
    
    # C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông cu·ªëi
    update_session_activity()
    
    if request.method == 'POST':
        # X·ª≠ l√Ω l∆∞u test ch·ªØ k√Ω
        employee_signature = request.form.get('employee_signature')
        team_leader_signature = request.form.get('team_leader_signature')
        manager_signature = request.form.get('manager_signature')
        test_date = request.form.get('test_date')
        test_note = request.form.get('test_note', 'Test hi·ªÉn th·ªã ch·ªØ k√Ω')
        
        # L∆∞u v√†o session ƒë·ªÉ s·ª≠ d·ª•ng cho PDF
        session['test_signatures'] = {
            'employee': employee_signature,
            'team_leader': team_leader_signature,
            'manager': manager_signature,
            'date': test_date,
            'note': test_note
        }
        
        flash('ƒê√£ l∆∞u test ch·ªØ k√Ω th√†nh c√¥ng!', 'success')
        return redirect(url_for('signature_test'))
    
    return render_template('signature_test.html', user=user, today=datetime.now().strftime('%Y-%m-%d'))

@app.route('/signature-test/download-pdf', methods=['POST'])
def download_signature_test_pdf():
    """T·∫£i PDF test ch·ªØ k√Ω"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    # L·∫•y d·ªØ li·ªáu ch·ªØ k√Ω t·ª´ form
    employee_signature = request.form.get('employee_signature')
    team_leader_signature = request.form.get('team_leader_signature')
    manager_signature = request.form.get('manager_signature')
    test_date = request.form.get('test_date')
    test_note = request.form.get('test_note', 'Test hi·ªÉn th·ªã ch·ªØ k√Ω')
    
    # T·∫°o buffer cho PDF
    buffer = io.BytesIO()
    
    # ƒêƒÉng k√Ω font
    register_pdf_fonts()
    
    # T·∫°o PDF
    canvas_obj = canvas.Canvas(buffer, pagesize=A4)
    canvas_obj.setTitle('Test Ch·ªØ k√Ω - DMI Attendance')
    
    # Header
    canvas_obj.setFont('NotoSansJP-Bold', 18)
    canvas_obj.drawString(50, 800, 'TEST HI·ªÇN TH·ªä CH·ªÆ K√ù')
    canvas_obj.setFont('NotoSansJP-Regular', 12)
    canvas_obj.drawString(50, 780, f'Ng√†y test: {test_date}')
    canvas_obj.drawString(50, 760, f'Ghi ch√∫: {test_note}')
    canvas_obj.drawString(50, 740, f'Ng∆∞·ªùi t·∫°o: {user.name}')
    
    # V·∫Ω ƒë∆∞·ªùng k·∫ª
    canvas_obj.line(50, 720, 550, 720)
    
    # Ch·ªØ k√Ω Nh√¢n vi√™n
    y_position = 680
    canvas_obj.setFont('NotoSansJP-Bold', 14)
    canvas_obj.drawString(50, y_position, '1. Ch·ªØ k√Ω Nh√¢n vi√™n:')
    
    if employee_signature:
        try:
            draw_signature_with_proper_scaling(canvas_obj, employee_signature, 50, y_position - 80, 200, 60)
        except Exception as e:
            print(f"Error drawing employee signature: {e}")
            create_signature_placeholder(canvas_obj, 50, y_position - 80, 200, 60, "L·ªói hi·ªÉn th·ªã")
    else:
        create_signature_placeholder(canvas_obj, 50, y_position - 80, 200, 60, "Ch∆∞a c√≥ ch·ªØ k√Ω")
    
    # Ch·ªØ k√Ω Tr∆∞·ªüng nh√≥m
    y_position = 540
    canvas_obj.setFont('NotoSansJP-Bold', 14)
    canvas_obj.drawString(50, y_position, '2. Ch·ªØ k√Ω Tr∆∞·ªüng nh√≥m:')
    
    if team_leader_signature:
        try:
            draw_signature_with_proper_scaling(canvas_obj, team_leader_signature, 50, y_position - 80, 200, 60)
        except Exception as e:
            print(f"Error drawing team leader signature: {e}")
            create_signature_placeholder(canvas_obj, 50, y_position - 80, 200, 60, "L·ªói hi·ªÉn th·ªã")
    else:
        create_signature_placeholder(canvas_obj, 50, y_position - 80, 200, 60, "Ch∆∞a c√≥ ch·ªØ k√Ω")
    
    # Ch·ªØ k√Ω Qu·∫£n l√Ω
    y_position = 400
    canvas_obj.setFont('NotoSansJP-Bold', 14)
    canvas_obj.drawString(50, y_position, '3. Ch·ªØ k√Ω Qu·∫£n l√Ω:')
    
    if manager_signature:
        try:
            draw_signature_with_proper_scaling(canvas_obj, manager_signature, 50, y_position - 80, 200, 60)
        except Exception as e:
            print(f"Error drawing manager signature: {e}")
            create_signature_placeholder(canvas_obj, 50, y_position - 80, 200, 60, "L·ªói hi·ªÉn th·ªã")
    else:
        create_signature_placeholder(canvas_obj, 50, y_position - 80, 200, 60, "Ch∆∞a c√≥ ch·ªØ k√Ω")
    
    # Footer
    y_position = 200
    canvas_obj.line(50, y_position, 550, y_position)
    canvas_obj.setFont('NotoSansJP-Regular', 10)
    canvas_obj.drawString(50, y_position - 20, f'ƒê∆∞·ª£c t·∫°o b·ªüi: {user.name} - {user.employee_id}')
    canvas_obj.drawString(50, y_position - 40, f'Th·ªùi gian: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")}')
    
    canvas_obj.save()
    buffer.seek(0)
    
    # T·∫°o response
    response = make_response(buffer.getvalue())
    response.headers['Content-Type'] = 'application/pdf'
    response.headers['Content-Disposition'] = f'attachment; filename=test_chu_ky_{datetime.now().strftime("%Y%m%d_%H%M%S")}.pdf'
    
    return response

@app.route('/settings/test-signature-pdf', methods=['POST'])
def test_signature_pdf():
    """T·∫°o PDF test ch·ªØ k√Ω c√° nh√¢n tr√™n m·∫´u phi·∫øu tƒÉng ca th·ª±c t·∫ø"""
    print("DEBUG: test_signature_pdf route accessed")
    print("DEBUG: Session user_id:", session.get('user_id'))
    print("DEBUG: Form data:", request.form)
    
    if 'user_id' not in session:
        # print("DEBUG: No user_id in session")
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    user = db.session.get(User, session['user_id'])
    if not user:
        print("DEBUG: User not found")
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    signature = request.form.get('signature')
    if not signature:
        print("DEBUG: No signature provided")
        return jsonify({'error': 'Ch∆∞a c√≥ ch·ªØ k√Ω'}), 400
    
    print("DEBUG: Signature length:", len(signature) if signature else 0)
    try:
        # T·∫°o buffer cho PDF
        buffer = io.BytesIO()
        register_pdf_fonts()
        canvas_obj = canvas.Canvas(buffer, pagesize=A4)
        canvas_obj.setTitle('Test Ch·ªØ k√Ω tr√™n Phi·∫øu TƒÉng Ca - DMI Attendance')
        print("DEBUG: PDF canvas created successfully")
        
        # T·∫°o m·∫´u phi·∫øu tƒÉng ca v·ªõi ch·ªØ k√Ω test
        create_overtime_test_pdf(canvas_obj, user, signature)
        
        canvas_obj.save()
        buffer.seek(0)
        print("DEBUG: PDF created successfully, size:", len(buffer.getvalue()))
        response = make_response(buffer.getvalue())
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'attachment; filename=test_phieu_tang_ca_{datetime.now().strftime("%Y%m%d_%H%M%S")}.pdf'
        return response
    except Exception as e:
        print(f"DEBUG: Error creating PDF: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói t·∫°o PDF: {str(e)}'}), 500

def create_overtime_test_pdf(canvas_obj, user, signature):
    """T·∫°o PDF test v·ªõi m·∫´u phi·∫øu tƒÉng ca th·ª±c t·∫ø"""
    width, height = A4
    margin = 30
    y = height - margin

    # Header: B·∫£ng 6 c·ªôt nh∆∞ trong m·∫´u th·ª±c t·∫ø - s·ª≠ d·ª•ng font an to√†n
    header_data = [
        [
            Paragraph('<b>DMI HU·∫æ</b>', ParagraphStyle('h', fontName='DejaVuSans', fontSize=9, alignment=1)),
            Paragraph('<b>Á∑èÂãô<br/>TONG VU</b>', ParagraphStyle('h', fontName='NotoSansJP', fontSize=8, alignment=1)),
            Paragraph('<b>ÂàÜÈ°ûÁï™Âè∑Ôºö<br/>So hieu phan loaiÔºö</b>', ParagraphStyle('h', fontName='NotoSansJP', fontSize=7, alignment=1)),
            Paragraph('', ParagraphStyle('h', fontName='DejaVuSans', fontSize=8, alignment=1)),
            Paragraph('<b>Ë®òÂÖ• FORM<br/>NHAP FORM</b>', ParagraphStyle('h', fontName='NotoSansJP', fontSize=8, alignment=1)),
            Paragraph('<b>Form‰ΩúÊàêÔºö<br/>Tac thanhÔºö</b>', ParagraphStyle('h', fontName='NotoSansJP', fontSize=7, alignment=1)),
            Paragraph('', ParagraphStyle('h', fontName='DejaVuSans', fontSize=8, alignment=1)),
            Paragraph('', ParagraphStyle('h', fontName='DejaVuSans', fontSize=8, alignment=1)),
        ]
    ]
    
    col_widths = [60, 80, 100, 50, 80, 80, 50, 50]
    header_table_width = sum(col_widths)
    x_header = (width - header_table_width) / 2
    header_table = Table(header_data, colWidths=col_widths, rowHeights=25)
    header_table.setStyle(TableStyle([
        ('ALIGN', (0,0), (-1,-1), 'CENTER'),
        ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),
        ('BOX', (0,0), (-1,-1), 0.5, colors.black),
        ('INNERGRID', (0,0), (-1,-1), 0.5, colors.black),
        ('FONTNAME', (0,0), (-1,-1), 'DejaVuSans'),
    ]))
    header_table.wrapOn(canvas_obj, width-2*margin, 30)
    header_table.drawOn(canvas_obj, x_header, y-25)
    y -= 40

    # Th√¥ng tin c√¥ng ty
    canvas_obj.setFont("DejaVuSans", 10)
    canvas_obj.drawString(margin, y, "C√¥ng ty TNHH DMI HU·∫æ")
    y -= 12
    canvas_obj.setFont("DejaVuSans", 8)
    canvas_obj.drawString(margin, y, "174 B√† Tri·ªáu- t√≤a nh√† 4 t·∫ßng Phong Ph√∫ Plaza, ph∆∞·ªùng Ph√∫ H·ªôi, Th√†nh ph·ªë Hu·∫ø, T·ªânh Th·ª´a Thi√™n Hu·∫ø,Vi·ªát Nam.")
    y -= 25

    # Ti√™u ƒë·ªÅ ch√≠nh
    canvas_obj.setFont("DejaVuSans", 14)
    canvas_obj.drawCentredString(width/2, y, "GI·∫§Y ƒê·ªÄ NGH·ªä TƒÇNG CA/ƒêI L√ÄM NG√ÄY NGH·ªà")
    y -= 16
    canvas_obj.setFont("NotoSansJP", 11)
    canvas_obj.drawCentredString(width/2, y, "(ÊÆãÊ•≠/‰ºëÊó•Âá∫Âã§Áî≥Ë´ãÊõ∏)")
    y -= 20
    canvas_obj.setFont("DejaVuSans", 9)
    canvas_obj.drawCentredString(width/2, y, "N·ªôp t·∫°i b·ªô ph·∫≠n t·ªïng v·ª•")
    canvas_obj.setFont("NotoSansJP-Light", 9)
    canvas_obj.drawCentredString(width/2, y-10, "(Á∑èÂãôÈÉ®ÁΩ≤„ÅßÊèêÂá∫)")
    y -= 30

    # Ph·∫ßn checkbox v√† th√¥ng tin c√° nh√¢n
    canvas_obj.setFont("DejaVuSans", 10)
    
    # D√≤ng checkbox
    checkbox_y = y
    canvas_obj.rect(margin, checkbox_y-3, 8, 8)  # Checkbox tƒÉng ca
    canvas_obj.drawString(margin+15, checkbox_y, "TƒÉng ca /")
    canvas_obj.setFont("NotoSansJP", 10)
    canvas_obj.drawString(margin+70, checkbox_y, "ÊÆãÊ•≠")
    
    canvas_obj.rect(margin+200, checkbox_y-3, 8, 8)  # Checkbox ƒëi l√†m ng√†y ngh·ªâ
    canvas_obj.setFont("DejaVuSans", 10)
    canvas_obj.drawString(margin+215, checkbox_y, "ƒêi l√†m ng√†y ngh·ªâ /")
    canvas_obj.setFont("NotoSansJP", 10)
    canvas_obj.drawString(margin+320, checkbox_y, "‰ºëÊó•Âá∫Âã§")
    y -= 20

    # Th√¥ng tin nh√¢n vi√™n
    canvas_obj.setFont("DejaVuSans", 10)
    canvas_obj.drawString(margin, y, f"H·ªç t√™n: {user.name}")
    canvas_obj.drawString(margin+200, y, f"Nh√≥m: {user.department}")
    canvas_obj.drawString(margin+350, y, f"M√£ NV: {user.employee_id}")
    y -= 15
    canvas_obj.drawString(margin, y, f"L√Ω do tƒÉng ca: Test hi·ªÉn th·ªã ch·ªØ k√Ω tr√™n phi·∫øu tƒÉng ca")
    y -= 15
    canvas_obj.drawString(margin, y, "ƒê·ªÅ ngh·ªã c√¥ng ty ch·∫•p thu·∫≠n cho t√¥i ƒë∆∞·ª£c tƒÉng ca/ƒëi l√†m v√†o ng√†y ngh·ªâ.")
    y -= 10
    canvas_obj.setFont("NotoSansJP-Light", 9)
    canvas_obj.drawString(margin, y, "ÊÆãÊ•≠/‰ºëÊó•Âá∫Âã§„ÇíË®±ÂèØ„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ")
    y -= 25
    
    # Th√™m kho·∫£ng c√°ch tr∆∞·ªõc khi v·∫Ω b·∫£ng th·ªùi gian
    y -= 15

    # B·∫£ng ch·∫•m c√¥ng chi ti·∫øt
    table_y = y
    table_width = width - 2*margin
    
    # ƒê·ªãnh nghƒ©a style cho ti√™u ƒë·ªÅ
    header_style_vn = ParagraphStyle('header_vn', fontName='DejaVuSans', fontSize=8, alignment=1)
    header_style_jp = ParagraphStyle('header_jp', fontName='NotoSansJP', fontSize=8, alignment=1)
    
    # T·∫°o chu·ªói th·ªùi gian l√†m vi·ªác m·∫´u
    time_str = "18:00 - 22:00"
    
    # H√†ng 1: Ti·∫øng Vi·ªát
    header_row1 = [
        Paragraph('No.', header_style_vn),
        Paragraph('NG√ÄY TH√ÅNG NƒÇM', header_style_vn),
        Paragraph('H√åNH TH·ª®C', header_style_vn),
        Paragraph('CA L√ÄM VI·ªÜC', header_style_vn),
        Paragraph('GI·ªú V√ÄO - GI·ªú RA', header_style_vn),
        Paragraph('Th·ªùi gian ngh·ªâ ƒë·ªëi ·ª©ng c√¥ng vi·ªác', header_style_vn),
        Paragraph('X√ÅC NH·∫¨N', header_style_vn)
    ]
    # H√†ng 2: Ti·∫øng Nh·∫≠t/H√°n
    header_row2 = [
        Paragraph('', header_style_jp),
        Paragraph('Êó•‰ªò', header_style_jp),
        Paragraph('Á®ÆÈ°û', header_style_jp),
        Paragraph('„Ç∑„Éï„Éà', header_style_jp),
        Paragraph('Âá∫Âã§ÊôÇÈñì-ÈÄÄÂã§ÊôÇÈñì', header_style_jp),
        Paragraph('Ê•≠ÂãôÂØæÂøúÊôÇÈñì', header_style_jp),
        Paragraph('„É©„Éú„Éû„ÉçÊâøË™ç', header_style_jp)
    ]
    # H√†ng d·ªØ li·ªáu m·∫´u - ch·ªâ hi·ªÉn th·ªã gi√° tr·ªã th·ªùi gian
    row_data = [
        '1',
        '15/07/2025',
        '1',
        'TƒÉng ca',
        time_str,
        '3:30',  # Ch·ªâ hi·ªÉn th·ªã 1 gi√° tr·ªã t·ªïng th·ªùi gian ƒë·ªëi ·ª©ng (0:30 + 2:00 + 1:00 = 3:30)
        ''
    ]
    
    table_data = [header_row1, header_row2, row_data]
    col_widths = [30, 80, 50, 65, 80, 110, 70]
    row_heights = [40, 14, 18]  # H√†ng d·ªØ li·ªáu b√¨nh th∆∞·ªùng v√¨ ch·ªâ hi·ªÉn th·ªã 1 gi√° tr·ªã
    
    detail_table_width = sum(col_widths)
    x_detail = (width - detail_table_width) / 2
    table = Table(table_data, colWidths=col_widths, rowHeights=row_heights)
    table.setStyle(TableStyle([
        ('ALIGN', (0,0), (-1,-1), 'CENTER'),
        ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),
        ('BOX', (0,0), (-1,-1), 0.5, colors.black),
        ('INNERGRID', (0,0), (-1,-1), 0.5, colors.black),
        ('FONTNAME', (0,0), (-1,0), 'DejaVuSans'),
        ('FONTNAME', (0,1), (-1,1), 'NotoSansJP'),
        ('FONTSIZE', (0,0), (-1,1), 8),
        ('FONTSIZE', (0,2), (-1,2), 9),
        ('LINEBELOW', (0,0), (-1,0), 0, colors.white),
    ]))
    table.wrapOn(canvas_obj, width-2*margin, 50)
    table.drawOn(canvas_obj, x_detail, table_y - 46)
    y = table_y - 46 - 36
    
    # Ghi ch√∫ d∆∞·ªõi b·∫£ng
    note_sections = [
        ("DejaVuSans", 8, "* Ghi ch√∫: T·∫°i c·ªôt H√¨nh th·ª©c: TƒÉng ca ng√†y b√¨nh th∆∞·ªùng ghi s·ªë 1 ƒêi l√†m ng√†y ngh·ªâ, tƒÉng ca ghi s·ªë 2"),
        ("NotoSansJP-Light", 8, "ÂÇôËÄÉÔºöÂπ≥Êó•„ÅÆÊÆãÊ•≠„ÅÆÂ†¥ÂêàÔºö1Áï™„ÇíË®òÂÖ•„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ ‰ºëÊó•Âá∫Âã§„ÅÆÂ†¥ÂêàÔºö2Áï™„ÇíË®òÂÖ•„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"),
        ("DejaVuSans", 8, "*V·ªÅ vi·ªác ngh·ªâ gi·∫£i lao (60 ph√∫t) ng√†y th∆∞·ªùng trong tu·∫ßn, tr∆∞·ªùng h·ª£p n·∫øu ngh·ªâ d√†i h∆°n v√¨ ƒë·ªëi ·ª©ng c√¥ng vi·ªác ÔºöH√£y n·ªôp ƒë∆°n cho b·ªô ph·∫≠n vƒÉn ph√≤ng."),
        ("NotoSansJP-Light", 8, "ÈÄöÂ∏∏Ôºà1„ÅÆÂ†¥ÂêàÔºâ„ÅÆÊòº‰ºëÊÜ©Ôºà60ÂàÜÔºâ„Å´„ÄÅ‰ºëÊÜ©ÈÄî‰∏≠„ÅßÊ•≠ÂãôÂØæÂøú„Åô„ÇãÂ†¥Âêà„ÄÅÁî≥Ë´ã„Çí„Åó„Å¶‰∏ã„Åï„ÅÑ„ÄÇ"),
        ("DejaVuSans", 8, "*Trong tr∆∞·ªùng h·ª£p kh√¥ng xin ph√©p tr∆∞·ªõc, th√¨ tƒÉng ca v√† ƒëi l√†m ng√†y ngh·ªâ kh√¥ng ƒë∆∞·ª£c ch·∫•p nh·∫≠n."),
        ("DejaVuSans", 8, "Ph·∫£i ghi gi·∫•y tƒÉng ca sau khi tƒÉng ca (ch·∫≠m nh·∫•t l√† ng√†y mai) ,sang ng√†y m·ªët ghi tƒÉng ca th√¨ kh√¥ng ƒë∆∞·ª£c ch·∫•p nh·∫≠n."),
        ("NotoSansJP-Light", 8, "‚Äª1ÂàÜÂçò‰Ωç„ÅßÁî≥Ë´ã„Åó„Å¶‰∏ã„Åï„ÅÑ„ÄÇÁî≥Ë´ã„Çí„Åó„Å™„ÅÑÈôê„Çä„ÄÅÊÆãÊ•≠„Å®‰ºëÊó•Âá∫Âã§„ÅØÂèçÊò†„Åï„Çå„Åæ„Åõ„Çì„ÄÇ"),
        ("NotoSansJP-Light", 8, "ÂøÖ„Åö„ÄÅÊÆãÊ•≠„Çí„Åó„ÅüÊó•„Å´Áî≥Ë´ã„Åô„Çã„Åì„Å®„ÄÇÔºàÊ¨°„ÅÆÊó•„Åæ„Åß„ÅÆÁî≥Ë´ã„ÅØË™ç„ÇÅ„Åæ„Åô„Åå„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅÆÁî≥Ë´ã„ÅØË™ç„ÇÅ„Åæ„Åõ„ÇìÔºâ")
    ]
    max_note_width = width - 2*margin - 10
    for i, (font_name, font_size, text) in enumerate(note_sections):
        lines = wrap_text(text, font_name, font_size, max_note_width, canvas_obj)
        for line in lines:
            canvas_obj.setFont(font_name, font_size)
            canvas_obj.drawString(margin, y, line)
            y -= font_size + 1
        if text.startswith('*') and i < len(note_sections)-1:
            y -= font_size + 1
    
    # Th√™m kho·∫£ng c√°ch gi·ªØa ph·∫ßn ghi ch√∫ v√† d√≤ng ng√†y th√°ng
    y -= 25
    # Ng√†y th√°ng - ƒê·∫∑t ·ªü v·ªã tr√≠ cao h∆°n ƒë·ªÉ kh√¥ng b·ªã ƒë√®
    date_y = y + 20  # ƒê·∫∑t d√≤ng ng√†y th√°ng cao h∆°n
    canvas_obj.setFont("DejaVuSans", 10)
    canvas_obj.drawRightString(width-margin, date_y, f"Hu·∫ø, ng√†y 15 th√°ng 07 nƒÉm 2025")
    y -= 10
    y -= 95  # TƒÉng th√™m kho·∫£ng c√°ch ƒë·ªÉ kh√¥ng b·ªã ƒë√® l√™n ph·∫ßn ghi ch√∫ v√† d√≤ng ng√†y th√°ng
    
    # S·ªë √¥ v√† k√≠ch th∆∞·ªõc ch·ªØ k√Ω
    # TƒÇNG K√çCH TH∆Ø·ªöC √î ƒê·ªÇ CH·ªÆ K√ù L·ªöN H∆†N KHI IN
    num_boxes = 3
    box_width = 180  # TƒÉng t·ª´ 155 l√™n 180 ƒë·ªÉ ch·ªØ k√Ω l·ªõn h∆°n khi in
    box_height = 95  # TƒÉng t·ª´ 80 l√™n 95 ƒë·ªÉ c√≥ nhi·ªÅu kh√¥ng gian cho n√©t ch·ªØ
    box_spacing = 20  # Gi·∫£m kho·∫£ng c√°ch ƒë·ªÉ 3 √¥ v·∫´n v·ª´a trang
    total_width = num_boxes * box_width + (num_boxes - 1) * box_spacing
    start_x = (width - total_width) / 2
    box_y = y
    label_font_size = 10
    sublabel_font_size = 8
    
    # Ti√™u ƒë·ªÅ c√°c √¥
    box_titles = [
        ("Qu·∫£n l√≠", "„É©„Éú„Éû„Éç„Ç∏„É£„Éº"),
        ("C·∫•p tr√™n tr·ª±c ti·∫øp", "‚ñ°ÂÆ§Èï∑„ÄÄ‚ñ°„É™„Éº„ÉÄ„Éº„ÄÄ‚ñ°‰ªñ"),
        ("Ng∆∞·ªùi xin ph√©p", "Áî≥Ë´ãËÄÖ")
    ]
    
    # V·∫Ω ti√™u ƒë·ªÅ v√† sublabel cƒÉn gi·ªØa tr√™n m·ªói √¥
    for i, (title, sublabel) in enumerate(box_titles):
        x = start_x + i * (box_width + box_spacing)
        canvas_obj.setFont("DejaVuSans", label_font_size)
        canvas_obj.drawCentredString(x + box_width/2, box_y + box_height + 22, title)
        canvas_obj.setFont("NotoSansJP-Light", sublabel_font_size)
        canvas_obj.drawCentredString(x + box_width/2, box_y + box_height + 10, sublabel)
    
    # V·∫Ω c√°c √¥ ch·ªØ k√Ω v·ªõi border
    signature_boxes = []
    for i in range(num_boxes):
        x = start_x + i * (box_width + box_spacing)
        signature_boxes.append((x, box_y, box_width, box_height))
    
    # Hi·ªÉn th·ªã ch·ªØ k√Ω trong t·ª´ng √¥
    # D√†nh nhi·ªÅu kh√¥ng gian h∆°n cho ph·∫ßn ch·ªØ k√Ω, v·∫´n ch·ª´a m·ªôt d·∫£i nh·ªè ph√≠a d∆∞·ªõi cho t√™n
    signature_area_height = box_height - 18  # V√πng ch·ªØ k√Ω l·ªõn h∆°n ƒë·ªÉ ch·ªØ k√Ω to h∆°n khi in
    signature_y = box_y + 18  # Ch·ªØ k√Ω b·∫Øt ƒë·∫ßu c√°ch ƒë√°y 18px
    signature_center_y = signature_y + signature_area_height/2 - 8/2  # CƒÉn gi·ªØa ch·ªØ k√Ω
    name_y = box_y + 8  # T√™n ng∆∞·ªùi k√Ω s√°t h∆°n ƒë√°y ƒë·ªÉ nh∆∞·ªùng ch·ªó cho ch·ªØ k√Ω
    
    # Qu·∫£n l√Ω
    x0 = start_x
    
    print("DEBUG: Processing manager signature for PDF")
    try:
        success = draw_signature_with_proper_scaling(canvas_obj, signature, x0, signature_y, box_width, signature_area_height)
        if not success:
            print("DEBUG: Failed to draw manager signature, creating placeholder")
            create_signature_placeholder(canvas_obj, x0, signature_y, box_width, signature_area_height, "L·ªói hi·ªÉn th·ªã")
    except Exception as e:
        print(f"Error drawing manager signature: {e}")
        create_signature_placeholder(canvas_obj, x0, signature_y, box_width, signature_area_height, "L·ªói")
    
    # Th√™m t√™n ng∆∞·ªùi k√Ω qu·∫£n l√Ω b√™n trong √¥ ch·ªØ k√Ω (ph√≠a d∆∞·ªõi ch·ªØ k√Ω)
    canvas_obj.setFont("DejaVuSans", 8)
    canvas_obj.drawCentredString(x0 + box_width/2, name_y, "Test Qu·∫£n l√Ω")
    
    # Tr∆∞·ªüng nh√≥m
    x1 = start_x + 1 * (box_width + box_spacing)
    
    print("DEBUG: Processing team leader signature for PDF")
    try:
        success = draw_signature_with_proper_scaling(canvas_obj, signature, x1, signature_y, box_width, signature_area_height)
        if not success:
            print("DEBUG: Failed to draw team leader signature, creating placeholder")
            create_signature_placeholder(canvas_obj, x1, signature_y, box_width, signature_area_height, "L·ªói hi·ªÉn th·ªã")
    except Exception as e:
        print(f"Error drawing team leader signature: {e}")
        create_signature_placeholder(canvas_obj, x1, signature_y, box_width, signature_area_height, "L·ªói")
    
    # Th√™m t√™n ng∆∞·ªùi k√Ω tr∆∞·ªüng nh√≥m b√™n trong √¥ ch·ªØ k√Ω (ph√≠a d∆∞·ªõi ch·ªØ k√Ω)
    canvas_obj.setFont("DejaVuSans", 8)
    canvas_obj.drawCentredString(x1 + box_width/2, name_y, "Test Tr∆∞·ªüng nh√≥m")
    
    # Nh√¢n vi√™n
    x2 = start_x + 2 * (box_width + box_spacing)
    
    print("DEBUG: Processing employee signature for PDF")
    try:
        success = draw_signature_with_proper_scaling(canvas_obj, signature, x2, signature_y, box_width, signature_area_height)
        if not success:
            print("DEBUG: Failed to draw employee signature, creating placeholder")
            create_signature_placeholder(canvas_obj, x2, signature_y, box_width, signature_area_height, "L·ªói hi·ªÉn th·ªã")
    except Exception as e:
        print(f"Error drawing employee signature: {e}")
        create_signature_placeholder(canvas_obj, x2, signature_y, box_width, signature_area_height, "L·ªói")
    
    # Th√™m t√™n ng∆∞·ªùi k√Ω nh√¢n vi√™n b√™n trong √¥ ch·ªØ k√Ω (ph√≠a d∆∞·ªõi ch·ªØ k√Ω)
    canvas_obj.setFont("DejaVuSans", 8)
    canvas_obj.drawCentredString(x2 + box_width/2, name_y, user.name)
    
    # V·∫Ω l·∫°i border cho t·∫•t c·∫£ c√°c √¥ ch·ªØ k√Ω sau khi ƒë√£ v·∫Ω ch·ªØ k√Ω
    canvas_obj.setStrokeColor(colors.black)
    canvas_obj.setLineWidth(0.5)
    for x, y, w, h in signature_boxes:
        canvas_obj.rect(x, y, w, h, stroke=1, fill=0)
    
    # Th√™m ghi ch√∫ test ·ªü cu·ªëi
    canvas_obj.setFont("DejaVuSans", 8)
    canvas_obj.drawString(margin, 50, "*** ƒê√¢y l√† PDF test ƒë·ªÉ ki·ªÉm tra hi·ªÉn th·ªã ch·ªØ k√Ω c√° nh√¢n tr√™n m·∫´u phi·∫øu tƒÉng ca th·ª±c t·∫ø ***")
    canvas_obj.drawString(margin, 35, f"ƒê∆∞·ª£c t·∫°o b·ªüi: {user.name} - {user.employee_id} - {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
    canvas_obj.drawString(margin, 20, "Phi·∫øu n√†y ch·ªâ d√πng ƒë·ªÉ test hi·ªÉn th·ªã ch·ªØ k√Ω, kh√¥ng c√≥ gi√° tr·ªã ph√°p l√Ω.")

def remove_vietnamese_accents(text):
    """Lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát v√† chuy·ªÉn th√†nh ch·ªØ th∆∞·ªùng, lo·∫°i b·ªè kho·∫£ng tr·∫Øng"""
    if not text:
        return ""
    
    # Mapping d·∫•u ti·∫øng Vi·ªát
    vietnamese_map = {
        '√†': 'a', '√°': 'a', '·∫£': 'a', '√£': 'a', '·∫°': 'a',
        'ƒÉ': 'a', '·∫±': 'a', '·∫Ø': 'a', '·∫≥': 'a', '·∫µ': 'a', '·∫∑': 'a',
        '√¢': 'a', '·∫ß': 'a', '·∫•': 'a', '·∫©': 'a', '·∫´': 'a', '·∫≠': 'a',
        '√®': 'e', '√©': 'e', '·∫ª': 'e', '·∫Ω': 'e', '·∫π': 'e',
        '√™': 'e', '·ªÅ': 'e', '·∫ø': 'e', '·ªÉ': 'e', '·ªÖ': 'e', '·ªá': 'e',
        '√¨': 'i', '√≠': 'i', '·ªâ': 'i', 'ƒ©': 'i', '·ªã': 'i',
        '√≤': 'o', '√≥': 'o', '·ªè': 'o', '√µ': 'o', '·ªç': 'o',
        '√¥': 'o', '·ªì': 'o', '·ªë': 'o', '·ªï': 'o', '·ªó': 'o', '·ªô': 'o',
        '∆°': 'o', '·ªù': 'o', '·ªõ': 'o', '·ªü': 'o', '·ª°': 'o', '·ª£': 'o',
        '√π': 'u', '√∫': 'u', '·ªß': 'u', '≈©': 'u', '·ª•': 'u',
        '∆∞': 'u', '·ª´': 'u', '·ª©': 'u', '·ª≠': 'u', '·ªØ': 'u', '·ª±': 'u',
        '·ª≥': 'y', '√Ω': 'y', '·ª∑': 'y', '·ªπ': 'y', '·ªµ': 'y',
        'ƒë': 'd',
        '√Ä': 'A', '√Å': 'A', '·∫¢': 'A', '√É': 'A', '·∫†': 'A',
        'ƒÇ': 'A', '·∫∞': 'A', '·∫Æ': 'A', '·∫≤': 'A', '·∫¥': 'A', '·∫∂': 'A',
        '√Ç': 'A', '·∫¶': 'A', '·∫§': 'A', '·∫®': 'A', '·∫™': 'A', '·∫¨': 'A',
        '√à': 'E', '√â': 'E', '·∫∫': 'E', '·∫º': 'E', '·∫∏': 'E',
        '√ä': 'E', '·ªÄ': 'E', '·∫æ': 'E', '·ªÇ': 'E', '·ªÑ': 'E', '·ªÜ': 'E',
        '√å': 'I', '√ç': 'I', '·ªà': 'I', 'ƒ®': 'I', '·ªä': 'I',
        '√í': 'O', '√ì': 'O', '·ªé': 'O', '√ï': 'O', '·ªå': 'O',
        '√î': 'O', '·ªí': 'O', '·ªê': 'O', '·ªî': 'O', '·ªñ': 'O', '·ªò': 'O',
        '∆†': 'O', '·ªú': 'O', '·ªö': 'O', '·ªû': 'O', '·ª†': 'O', '·ª¢': 'O',
        '√ô': 'U', '√ö': 'U', '·ª¶': 'U', '≈®': 'U', '·ª§': 'U',
        '∆Ø': 'U', '·ª™': 'U', '·ª®': 'U', '·ª¨': 'U', '·ªÆ': 'U', '·ª∞': 'U',
        '·ª≤': 'Y', '√ù': 'Y', '·ª∂': 'Y', '·ª∏': 'Y', '·ª¥': 'Y',
        'ƒê': 'D'
    }
    
    result = ""
    for char in text:
        result += vietnamese_map.get(char, char)
    
    # Chuy·ªÉn th√†nh ch·ªØ th∆∞·ªùng v√† lo·∫°i b·ªè kho·∫£ng tr·∫Øng
    result = result.lower().replace(' ', '')
    
    # Lo·∫°i b·ªè c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát kh√°c, ch·ªâ gi·ªØ l·∫°i ch·ªØ c√°i v√† s·ªë
    import re
    result = re.sub(r'[^a-z0-9]', '', result)
    
    return result

# API endpoint ƒë·ªÉ ph√™ duy·ªát t·∫•t c·∫£ attendance records
@app.route('/api/attendance/approve-all', methods=['POST'])
@rate_limit(max_requests=10, window_seconds=60)  # Gi·ªõi h·∫°n 10 l·∫ßn g·ªçi API trong 1 ph√∫t
def approve_all_attendances():
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    
    update_session_activity()
    
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    current_role = session.get('current_role', user.roles.split(',')[0])
    if current_role not in ['TEAM_LEADER', 'MANAGER', 'ADMIN']:
        return jsonify({'error': 'B·∫°n kh√¥ng c√≥ quy·ªÅn ph√™ duy·ªát h√†ng lo·∫°t'}), 403
    
    data = request.get_json()
    action = data.get('action')  # 'approve' ho·∫∑c 'reject'
    reason = validate_reason(data.get('reason', '')) if data.get('action') == 'reject' else ''
    
    if action not in ['approve', 'reject']:
        return jsonify({'error': 'H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá'}), 400
    
    if action == 'reject' and not reason:
        return jsonify({'error': 'L√Ω do t·ª´ ch·ªëi kh√¥ng h·ª£p l·ªá'}), 400
    
    # Import datetime at function level to avoid scope issues
    import sys
    from datetime import datetime as dt
    
    try:
        # X√°c ƒë·ªãnh ph·∫°m vi attendance records c·∫ßn ph√™ duy·ªát
        if current_role == 'ADMIN':
            # Admin c√≥ th·ªÉ ph√™ duy·ªát t·∫•t c·∫£
            attendances_query = Attendance.query.filter(
                Attendance.approved == False
            )
        elif current_role == 'MANAGER':
            # Manager c√≥ th·ªÉ ph√™ duy·ªát t·∫•t c·∫£ nh√¢n vi√™n (kh√¥ng ph√¢n bi·ªát ph√≤ng ban)
            # Bao g·ªìm c·∫£ nh√¢n vi√™n t·ª´ c√°c ph√≤ng ban kh√°c
            attendances_query = Attendance.query.filter(
                Attendance.approved == False
            )
        else:  # TEAM_LEADER
            # Team leader ch·ªâ c√≥ th·ªÉ ph√™ duy·ªát nh√¢n vi√™n c√πng ph√≤ng ban
            attendances_query = Attendance.query.join(User, Attendance.user_id == User.id).filter(
                Attendance.approved == False,
                User.department == user.department
            )
        
        # L·ªçc theo tr·∫°ng th√°i hi·ªán t·∫°i
        if current_role == 'TEAM_LEADER':
            attendances_query = attendances_query.filter(Attendance.status == 'pending')
        elif current_role == 'MANAGER':
            # Manager ch·ªâ c√≥ th·ªÉ ph√™ duy·ªát pending v√† pending_manager
            attendances_query = attendances_query.filter(
                Attendance.status.in_(['pending', 'pending_manager'])
            )
        elif current_role == 'ADMIN':
            # Admin c√≥ th·ªÉ ph√™ duy·ªát t·∫•t c·∫£ tr·∫°ng th√°i ch·ªù duy·ªát
            attendances_query = attendances_query.filter(
                Attendance.status.in_(['pending', 'pending_manager', 'pending_admin'])
            )
        
        attendances = attendances_query.all()
        
        if not attendances:
            return jsonify({'message': 'Kh√¥ng c√≥ b·∫£n ghi n√†o c·∫ßn ph√™ duy·ªát', 'count': 0}), 200
        
        approved_count = 0
        rejected_count = 0
        approved_attendance_ids = []  # L∆∞u ID c√°c b·∫£n ghi ƒë√£ ƒë∆∞·ª£c ADMIN ph√™ duy·ªát ƒë·ªÉ c·∫≠p nh·∫≠t Google Sheet
        google_sheet_errors = []  # L∆∞u c√°c l·ªói khi c·∫≠p nh·∫≠t Google Sheet (ch·ªâ cho ADMIN)

        # ===== BATCH UPDATE OPTIMIZATION FOR ADMIN =====
        # Gom t·∫•t c·∫£ ADMIN records ƒë·ªÉ batch update thay v√¨ update t·ª´ng record
        admin_records_for_batch = []  # List of (attendance, employee_team, employee_id, attendance_data, original_status)

        for attendance in attendances:
            # Ki·ªÉm tra quy·ªÅn ph√™ duy·ªát t·ª´ng record
            has_permission, error_message = check_approval_permission(user.id, attendance.id, current_role)
            if not has_permission:
                continue
            
            if action == 'approve':
                # X·ª≠ l√Ω ph√™ duy·ªát
                if current_role == 'TEAM_LEADER':
                    attendance.status = 'pending_manager'
                    attendance.approved_by = user.id
                    attendance.approved_at = datetime.now()
                    # L∆∞u ch·ªØ k√Ω v√† ID ng∆∞·ªùi k√Ω n·∫øu c√≥
                    if user.has_personal_signature():
                        attendance.team_leader_signature = user.personal_signature
                    attendance.team_leader_signer_id = user.id  # C·∫≠p nh·∫≠t ID ng∆∞·ªùi k√Ω tr∆∞·ªüng nh√≥m
                elif current_role == 'MANAGER':
                    # Manager chuy·ªÉn l√™n QU·∫¢N TR·ªä VI√äN ƒë·ªÉ ki·ªÉm tra cu·ªëi c√πng
                    # N·∫øu tr·∫°ng th√°i l√† pending, c·∫ßn l∆∞u ch·ªØ k√Ω tr∆∞·ªüng nh√≥m (n·∫øu c√≥)
                    if attendance.status == 'pending' and user.has_personal_signature():
                        attendance.team_leader_signature = user.personal_signature
                        # C·∫≠p nh·∫≠t ID ng∆∞·ªùi k√Ω tr∆∞·ªüng nh√≥m n·∫øu ch∆∞a c√≥
                        if not attendance.team_leader_signer_id:
                            attendance.team_leader_signer_id = user.id
                    
                    attendance.status = 'pending_admin'
                    attendance.approved_by = user.id
                    attendance.approved_at = datetime.now()
                    # L∆∞u ch·ªØ k√Ω qu·∫£n l√Ω n·∫øu c√≥
                    if user.has_personal_signature():
                        attendance.manager_signature = user.personal_signature
                    attendance.manager_signer_id = user.id  # C·∫≠p nh·∫≠t ID ng∆∞·ªùi k√Ω qu·∫£n l√Ω
                elif current_role == 'ADMIN':
                    # ===== ADMIN BULK APPROVAL WITH BATCH GOOGLE SHEET UPDATE =====
                    # Thay v√¨ sync t·ª´ng record, gom l·∫°i ƒë·ªÉ batch update sau

                    # Check Google API token m·ªôt l·∫ßn ƒë·∫ßu ti√™n
                    if len(admin_records_for_batch) == 0:
                        token_status = check_google_token_status()
                        if not token_status.get('can_approve', False):
                            publish_token_status('expired', token_status.get('message', 'Token h·∫øt h·∫°n'), needs_reauth=True)
                            return jsonify({
                                'error': f"‚ö†Ô∏è Token Google API h·∫øt h·∫°n. {token_status.get('message', 'Vui l√≤ng refresh token tr∆∞·ªõc khi ph√™ duy·ªát.')}",
                                'error_code': 'token_expired',
                                'needs_reauth': True
                            }), 503

                    # Store original status for rollback
                    original_status = attendance.status

                    # Save signatures first
                    if attendance.status == 'pending' and user.has_personal_signature():
                        attendance.team_leader_signature = user.personal_signature
                        attendance.team_leader_signer_id = user.id

                    if attendance.status == 'pending_manager' and user.has_personal_signature():
                        attendance.manager_signature = user.personal_signature
                        attendance.manager_signer_id = user.id

                    if attendance.status == 'pending_admin' and user.has_personal_signature():
                        attendance.manager_signature = user.personal_signature
                        attendance.manager_signer_id = user.id

                    # Prepare attendance data like single approval
                    if not attendance.user:
                        continue  # Skip records without user info

                    employee_team = attendance.user.department if attendance.user.department else None
                    employee_id = attendance.user.employee_id if attendance.user.employee_id else None

                    # Fallbacks
                    if not employee_id:
                        employee_id = str(attendance.user.id) if attendance.user.id else attendance.user.name

                    if not employee_team or employee_team == "Unknown":
                        employee_team = getattr(attendance.user, 'team', None) or "Unknown"

                    # Prepare attendance data (same as single approval)
                    break_time_value = attendance._format_hours_minutes(attendance.break_time) if attendance.break_time else '0:00'
                    note_value = attendance.note if attendance.note else ''

                    comp_time_regular_value = attendance._format_minutes_to_hhmm(attendance.comp_time_regular_minutes)
                    comp_time_overtime_value = attendance._format_minutes_to_hhmm(attendance.comp_time_overtime_minutes)
                    comp_time_ot_before_22_value = attendance._format_minutes_to_hhmm(attendance.comp_time_ot_before_22_minutes)
                    comp_time_ot_after_22_value = attendance._format_minutes_to_hhmm(attendance.comp_time_ot_after_22_minutes)
                    overtime_comp_time_value = attendance._format_minutes_to_hhmm(attendance.overtime_comp_time_minutes)

                    overtime_before_22_val = attendance.overtime_before_22 or '0:00'
                    overtime_after_22_val = attendance.overtime_after_22 or '0:00'

                    # Calculate total comp time
                    def hhmm_to_minutes_safe(v):
                        try:
                            if not v or v in ['0', '0:00']:
                                return 0
                            if isinstance(v, str) and ':' in v:
                                h, m = v.split(':', 1)
                                return int(h or '0') * 60 + int(m or '0')
                        except Exception:
                            pass
                        return 0

                    total_comp_minutes = (
                        hhmm_to_minutes_safe(comp_time_regular_value) +
                        hhmm_to_minutes_safe(comp_time_ot_before_22_value) +
                        hhmm_to_minutes_safe(comp_time_ot_after_22_value) +
                        hhmm_to_minutes_safe(comp_time_overtime_value) +
                        hhmm_to_minutes_safe(overtime_comp_time_value)
                    )
                    total_comp_display = f"{total_comp_minutes // 60}:{total_comp_minutes % 60:02d}"

                    doi_ung_parts = []
                    if comp_time_regular_value not in [None, '', 0, '0', '0:00']:
                        doi_ung_parts.append(f"B√π gi·ªù th∆∞·ªùng: {comp_time_regular_value}")
                    if comp_time_overtime_value not in [None, '', 0, '0', '0:00']:
                        doi_ung_parts.append(f"B√π gi·ªù tƒÉng ca: {comp_time_overtime_value}")
                    if comp_time_ot_before_22_value not in [None, '', 0, '0', '0:00']:
                        doi_ung_parts.append(f"B√π OT <22h: {comp_time_ot_before_22_value}")
                    if comp_time_ot_after_22_value not in [None, '', 0, '0', '0:00']:
                        doi_ung_parts.append(f"B√π OT >22h: {comp_time_ot_after_22_value}")
                    if overtime_comp_time_value not in [None, '', 0, '0', '0:00']:
                        doi_ung_parts.append(f"ƒê·ªëi ·ª©ng OT: {overtime_comp_time_value}")

                    doi_ung_summary = f"{total_comp_display} [ " + ' | '.join(doi_ung_parts) + " ]" if doi_ung_parts else total_comp_display

                    regular_work_display = attendance._format_hours_minutes(attendance.calculate_regular_work_hours())
                    total_hours_value = getattr(attendance, 'total_hours', None) or getattr(attendance, 'total_work_hours', '')

                    def to_hhmm_from_decimal(hours_val):
                        try:
                            if hours_val is None or hours_val == '':
                                return ''
                            if isinstance(hours_val, str):
                                if ':' in hours_val:
                                    return hours_val
                                hours_float = float(hours_val)
                            else:
                                hours_float = float(hours_val)
                            total_minutes = int(round(hours_float * 60))
                            return f"{total_minutes // 60}:{total_minutes % 60:02d}"
                        except Exception:
                            return str(hours_val)

                    total_hours_display = to_hhmm_from_decimal(total_hours_value)

                    attendance_data = {
                        'id': attendance.id,
                        'user_name': attendance.user.name if attendance.user else 'Unknown',
                        'date': attendance.date.strftime('%Y-%m-%d') if attendance.date else '',
                        'check_in': attendance.check_in.strftime('%H:%M') if attendance.check_in else '',
                        'check_out': attendance.check_out.strftime('%H:%M') if attendance.check_out else '',
                        'total_hours': total_hours_display,
                        'regular_work_hours': regular_work_display,
                        'break_time': break_time_value,
                        'overtime_before_22': overtime_before_22_val,
                        'overtime_after_22': overtime_after_22_val,
                        'comp_time_regular': comp_time_regular_value,
                        'comp_time_overtime': comp_time_overtime_value,
                        'comp_time_ot_before_22': comp_time_ot_before_22_value,
                        'comp_time_ot_after_22': comp_time_ot_after_22_value,
                        'overtime_comp_time': overtime_comp_time_value,
                        'note': note_value,
                        'doi_ung': doi_ung_summary,
                        'doi_ung_total': total_comp_display,
                        'status': 'approved',
                        'approved_by': user.name,
                        'approved_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        'holiday_type': attendance.holiday_type if hasattr(attendance, 'holiday_type') else None,
                        'is_holiday': attendance.is_holiday if hasattr(attendance, 'is_holiday') else False
                    }

                    # ===== GOM RECORD V√ÄO LIST ƒê·ªÇ BATCH UPDATE SAU =====
                    admin_records_for_batch.append({
                        'attendance': attendance,
                        'employee_team': employee_team,
                        'employee_id': employee_id,
                        'attendance_data': attendance_data,
                        'original_status': original_status
                    })

                    # Kh√¥ng tƒÉng approved_count ·ªü ƒë√¢y - s·∫Ω x·ª≠ l√Ω sau khi batch update
                    continue  # Skip to next record, batch update s·∫Ω x·ª≠ l√Ω sau

                approved_count += 1

                # Log audit action (cho TEAM_LEADER v√† MANAGER)
                log_audit_action(
                    user_id=user.id,
                    action='BULK_APPROVE_ATTENDANCE',
                    table_name='attendances',
                    record_id=attendance.id,
                    old_values={'status': attendance.status},
                    new_values={
                        'status': attendance.status,
                        'approved_by': user.id,
                        'team_leader_signer_id': getattr(attendance, 'team_leader_signer_id', None),
                        'manager_signer_id': getattr(attendance, 'manager_signer_id', None)
                    }
                )

            else:  # reject
                attendance.status = 'rejected'
                attendance.reject_reason = reason
                attendance.approved_by = user.id
                attendance.approved_at = datetime.now()
                rejected_count += 1
                
                # Log audit action
                log_audit_action(
                    user_id=user.id,
                    action='BULK_REJECT_ATTENDANCE',
                    table_name='attendances',
                    record_id=attendance.id,
                    old_values={'status': attendance.status},
                    new_values={'status': 'rejected', 'reject_reason': reason, 'approved_by': user.id}
                )

        # ===== BATCH UPDATE GOOGLE SHEETS FOR ADMIN RECORDS =====
        if current_role == 'ADMIN' and action == 'approve' and admin_records_for_batch:
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            try:
                print(f"\n{'='*80}", flush=True, file=sys.stderr)
                print(f"üöÄ [BATCH_UPDATE_START] {timestamp} - B·∫Øt ƒë·∫ßu BATCH UPDATE cho {len(admin_records_for_batch)} records", flush=True, file=sys.stderr)
                print(f"{'='*80}", flush=True, file=sys.stderr)
            except Exception:
                pass

            # Chu·∫©n b·ªã d·ªØ li·ªáu cho batch update
            batch_data = []
            for record in admin_records_for_batch:
                batch_data.append((
                    record['attendance'],
                    record['employee_team'],
                    record['employee_id'],
                    record['attendance_data']
                ))

            # G·ªçi batch update
            batch_result = batch_update_multi_attendances_sync(batch_data)

            # X·ª≠ l√Ω k·∫øt qu·∫£ batch update
            for record in admin_records_for_batch:
                attendance = record['attendance']
                original_status = record['original_status']

                if attendance.id in batch_result['success_ids']:
                    # Google Sheet th√†nh c√¥ng - mark as approved
                    attendance.status = 'approved'
                    attendance.approved = True
                    attendance.approved_by = user.id
                    attendance.approved_at = datetime.now()
                    # B3: Increment version on batch approval
                    attendance.version = (getattr(attendance, 'version', 1) or 1) + 1
                    approved_attendance_ids.append(attendance.id)
                    approved_count += 1

                    # Log audit action
                    log_audit_action(
                        user_id=user.id,
                        action='BULK_APPROVE_ATTENDANCE',
                        table_name='attendances',
                        record_id=attendance.id,
                        old_values={'status': original_status},
                        new_values={
                            'status': 'approved',
                            'approved_by': user.id,
                            'team_leader_signer_id': getattr(attendance, 'team_leader_signer_id', None),
                            'manager_signer_id': getattr(attendance, 'manager_signer_id', None)
                        }
                    )
                else:
                    # Google Sheet th·∫•t b·∫°i - rollback
                    attendance.approved = False
                    attendance.approved_by = None
                    attendance.approved_at = None

                    # T√¨m error message
                    error_msg = 'Unknown error'
                    for failed in batch_result['failed']:
                        if failed['id'] == attendance.id:
                            error_msg = failed['error']
                            break

                    google_sheet_errors.append({
                        'id': attendance.id,
                        'user_name': attendance.user.name if attendance.user else 'Unknown',
                        'error': error_msg,
                        'original_status': original_status
                    })

            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            try:
                print(f"\n{'='*80}", flush=True, file=sys.stderr)
                print(f"üìä [BATCH_UPDATE_COMPLETE] {timestamp}", flush=True, file=sys.stderr)
                print(f"   ‚úÖ Th√†nh c√¥ng: {len(batch_result['success_ids'])} records", flush=True, file=sys.stderr)
                print(f"   ‚ùå Th·∫•t b·∫°i: {len(batch_result['failed'])} records", flush=True, file=sys.stderr)
                print(f"   üì° T·ªïng API calls: {batch_result['total_api_calls']} (thay v√¨ {len(admin_records_for_batch)} calls)", flush=True, file=sys.stderr)
                print(f"{'='*80}", flush=True, file=sys.stderr)
            except Exception:
                pass

        # ===== COMMIT ALL CHANGES =====
        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        try:
            print(f"\n{'='*80}", flush=True, file=sys.stderr)
            print(f"üíæ [BULK_COMMIT] {timestamp} - ƒêang commit t·∫•t c·∫£ thay ƒë·ªïi...", flush=True, file=sys.stderr)
            print(f"{'='*80}", flush=True, file=sys.stderr)
        except Exception:
            pass
        
        try:
            db.session.commit()
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            try:
                print(f"‚úÖ [BULK_COMMIT_SUCCESS] {timestamp} - Database ƒë√£ ƒë∆∞·ª£c commit", flush=True, file=sys.stderr)
            except Exception:
                pass
        except Exception as commit_error:
            db.session.rollback()
            try:
                print(f"‚ùå [BULK_COMMIT_ERROR] L·ªói commit: {str(commit_error)}", flush=True, file=sys.stderr)
            except Exception:
                pass
            return jsonify({'error': 'L·ªói l∆∞u database'}), 500
        
        # ===== PREPARE RESPONSE WITH DETAILED SUMMARY =====
        total_processed = approved_count + rejected_count
        successful_approvals = len(approved_attendance_ids) if current_role == 'ADMIN' else approved_count
        failed_approvals = len(google_sheet_errors) if current_role == 'ADMIN' else 0
        
        # Build message
        message = f'ƒê√£ x·ª≠ l√Ω {total_processed} b·∫£n ghi'
        
        if current_role == 'ADMIN' and action == 'approve':
            message += f': {successful_approvals} ph√™ duy·ªát th√†nh c√¥ng'
            if failed_approvals > 0:
                message += f', {failed_approvals} b·∫£n ghi th·∫•t b·∫°i (gi·ªØ nguy√™n status ƒë·ªÉ th·ª≠ l·∫°i)'
            if rejected_count > 0:
                message += f', {rejected_count} t·ª´ ch·ªëi'
        else:
            message += f': {approved_count} ph√™ duy·ªát, {rejected_count} t·ª´ ch·ªëi'
        
        # Log summary
        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        try:
            print(f"\n{'='*80}", flush=True, file=sys.stderr)
            print(f"üìä [BULK_APPROVE_SUMMARY] {timestamp}", flush=True, file=sys.stderr)
            print(f"   T·ªïng s·ªë x·ª≠ l√Ω: {total_processed}", flush=True, file=sys.stderr)
            if current_role == 'ADMIN' and action == 'approve':
                print(f"   ‚úÖ Th√†nh c√¥ng: {successful_approvals} b·∫£n ghi", flush=True, file=sys.stderr)
                if successful_approvals > 0:
                    print(f"      IDs: {', '.join(map(str, approved_attendance_ids))}", flush=True, file=sys.stderr)
                print(f"   ‚ùå Th·∫•t b·∫°i: {failed_approvals} b·∫£n ghi", flush=True, file=sys.stderr)
                if failed_approvals > 0:
                    for error_detail in google_sheet_errors:
                        print(f"      - ID {error_detail['id']} ({error_detail['user_name']}): {error_detail['error']}", flush=True, file=sys.stderr)
            else:
                print(f"   ‚úÖ Ph√™ duy·ªát: {approved_count}", flush=True, file=sys.stderr)
            print(f"   ‚ùå T·ª´ ch·ªëi: {rejected_count}", flush=True, file=sys.stderr)
            print(f"{'='*80}\n", flush=True, file=sys.stderr)
        except Exception:
            pass
        
        # Prepare detailed error list for response
        error_list = []
        if google_sheet_errors:
            for error_detail in google_sheet_errors:
                error_list.append({
                    'attendance_id': error_detail['id'],
                    'user_name': error_detail['user_name'],
                    'error': error_detail['error'],
                    'status': error_detail['original_status']
                })
        
        return jsonify({
            'success': True,
            'message': message,
            'total_processed': total_processed,
            'approved_count': approved_count,
            'successful_approvals': successful_approvals if current_role == 'ADMIN' else approved_count,
            'failed_approvals': failed_approvals,
            'rejected_count': rejected_count,
            'approved_ids': approved_attendance_ids if current_role == 'ADMIN' else [],
            'failed_records': error_list[:20] if error_list else []  # Limit to 20 for response size
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"Error in bulk approval: {e}")
        return jsonify({'error': f'L·ªói khi x·ª≠ l√Ω h√†ng lo·∫°t: {str(e)}'}), 500

# ============================================================================
# LEAVE REQUEST ROUTES
# ============================================================================

# API endpoint ƒë·ªÉ l·∫•y s·ªë l∆∞·ª£ng ƒë∆°n ngh·ªâ ph√©p ƒëang ch·ªù ph√™ duy·ªát
@app.route('/api/leave/pending-count', methods=['GET'])
def get_leave_pending_count():
    """Get count of pending leave requests that current user can approve"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p', 'count': 0}), 401

    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n', 'count': 0}), 401

    update_session_activity()

    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng', 'count': 0}), 404

    current_role = session.get('current_role', user.roles.split(',')[0])
    if current_role not in ['TEAM_LEADER', 'MANAGER', 'ADMIN']:
        return jsonify({'count': 0}), 200

    try:
        # X√°c ƒë·ªãnh ph·∫°m vi leave requests c√≥ th·ªÉ ph√™ duy·ªát theo role
        if current_role == 'ADMIN':
            # Admin c√≥ th·ªÉ ph√™ duy·ªát pending_admin
            count = LeaveRequest.query.filter(
                LeaveRequest.status == 'pending_admin'
            ).count()
            target_status = 'pending_admin'
        elif current_role == 'MANAGER':
            # Manager c√≥ th·ªÉ ph√™ duy·ªát pending_manager
            count = LeaveRequest.query.filter(
                LeaveRequest.status == 'pending_manager'
            ).count()
            target_status = 'pending_manager'
        else:  # TEAM_LEADER
            # Team leader ch·ªâ c√≥ th·ªÉ ph√™ duy·ªát pending c√πng ph√≤ng ban
            count = LeaveRequest.query.join(User, LeaveRequest.user_id == User.id).filter(
                LeaveRequest.status == 'pending',
                User.department == user.department
            ).count()
            target_status = 'pending'

        print(f"[INFO] get_leave_pending_count: role={current_role}, target_status={target_status}, count={count}")
        return jsonify({'count': count, 'role': current_role, 'target_status': target_status}), 200

    except Exception as e:
        print(f"[ERROR] get_leave_pending_count: {str(e)}")
        return jsonify({'error': str(e), 'count': 0}), 500

# API endpoint ƒë·ªÉ ph√™ duy·ªát t·∫•t c·∫£ leave request records
@app.route('/api/leave/approve-all', methods=['POST'])
@rate_limit(max_requests=10, window_seconds=60)  # Gi·ªõi h·∫°n 10 l·∫ßn g·ªçi API trong 1 ph√∫t
def approve_all_leave_requests():
    """Bulk approve/reject leave requests - similar to attendance bulk approve"""
    if 'user_id' not in session:
        return jsonify({'error': 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p'}), 401
    
    if check_session_timeout():
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n'}), 401
    
    update_session_activity()
    
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'}), 404
    
    current_role = session.get('current_role', user.roles.split(',')[0])
    if current_role not in ['TEAM_LEADER', 'MANAGER', 'ADMIN']:
        return jsonify({'error': 'B·∫°n kh√¥ng c√≥ quy·ªÅn ph√™ duy·ªát h√†ng lo·∫°t'}), 403
    
    data = request.get_json()
    action = data.get('action')  # 'approve' ho·∫∑c 'reject'
    reason = validate_reason(data.get('reason', '')) if data.get('action') == 'reject' else ''
    
    if action not in ['approve', 'reject']:
        return jsonify({'error': 'H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá'}), 400
    
    if action == 'reject' and not reason:
        return jsonify({'error': 'L√Ω do t·ª´ ch·ªëi kh√¥ng h·ª£p l·ªá'}), 400
    
    # Import datetime at function level to avoid scope issues
    import sys
    from datetime import datetime as dt

    try:
        # X√°c ƒë·ªãnh ph·∫°m vi leave requests c·∫ßn ph√™ duy·ªát theo ƒë√∫ng role
        # M·ªói role ch·ªâ ph√™ duy·ªát ƒë√∫ng tr·∫°ng th√°i m√† h·ªç c√≥ th·ªÉ ph√™ duy·ªát
        if current_role == 'ADMIN':
            # Admin ch·ªâ ph√™ duy·ªát pending_admin (b∆∞·ªõc cu·ªëi c√πng)
            leave_requests_query = LeaveRequest.query.filter(
                LeaveRequest.status == 'pending_admin'
            )
        elif current_role == 'MANAGER':
            # Manager ch·ªâ ph√™ duy·ªát pending_manager
            leave_requests_query = LeaveRequest.query.filter(
                LeaveRequest.status == 'pending_manager'
            )
        else:  # TEAM_LEADER
            # Team leader ch·ªâ c√≥ th·ªÉ ph√™ duy·ªát pending c√πng ph√≤ng ban
            leave_requests_query = LeaveRequest.query.join(User, LeaveRequest.user_id == User.id).filter(
                LeaveRequest.status == 'pending',
                User.department == user.department
            )
        
        leave_requests = leave_requests_query.all()
        
        if not leave_requests:
            return jsonify({'message': 'Kh√¥ng c√≥ ƒë∆°n n√†o c·∫ßn ph√™ duy·ªát', 'count': 0}), 200
        
        approved_count = 0
        rejected_count = 0
        google_sheet_errors = []  # L∆∞u c√°c l·ªói khi c·∫≠p nh·∫≠t Google Sheet (ch·ªâ cho ADMIN)
        approved_leave_ids = []  # L∆∞u ID c√°c ƒë∆°n ƒë√£ ƒë∆∞·ª£c ADMIN ph√™ duy·ªát

        # ===== BATCH UPDATE OPTIMIZATION FOR ADMIN =====
        # Gom t·∫•t c·∫£ ADMIN records ƒë·ªÉ batch update thay v√¨ update t·ª´ng record
        admin_records_for_batch = []  # List of dicts for batch processing

        # X·ª≠ l√Ω t·ª´ng leave request
        for leave_request in leave_requests:
            if action == 'approve':
                # X·ª≠ l√Ω ph√™ duy·ªát theo t·ª´ng role
                if current_role == 'TEAM_LEADER':
                    # Team leader approve: pending -> pending_manager
                    if leave_request.status == 'pending' and user.has_personal_signature():
                        leave_request.team_leader_signature = user.personal_signature
                        leave_request.team_leader_signer_id = user.id
                        leave_request.team_leader_approved_at = datetime.now()

                    leave_request.status = 'pending_manager'
                    leave_request.step = 'manager'
                    leave_request.current_approver_id = None
                    approved_count += 1

                elif current_role == 'MANAGER':
                    # Manager approve: pending/pending_manager -> pending_admin
                    # N·∫øu ch∆∞a c√≥ ch·ªØ k√Ω team leader, th√™m ch·ªØ k√Ω manager v√†o v·ªã tr√≠ team leader
                    if leave_request.status == 'pending' and user.has_personal_signature():
                        leave_request.team_leader_signature = user.personal_signature
                        leave_request.team_leader_signer_id = user.id

                    # Th√™m ch·ªØ k√Ω manager
                    if user.has_personal_signature():
                        leave_request.manager_signature = user.personal_signature
                        leave_request.manager_signer_id = user.id
                        leave_request.manager_approved_at = datetime.now()

                    leave_request.status = 'pending_admin'
                    leave_request.step = 'admin'
                    leave_request.current_approver_id = None
                    approved_count += 1

                elif current_role == 'ADMIN':
                    # ===== ADMIN BULK APPROVAL WITH BATCH GOOGLE SHEET UPDATE =====
                    # Thay v√¨ sync t·ª´ng record, gom l·∫°i ƒë·ªÉ batch update sau

                    # Check Google API token m·ªôt l·∫ßn ƒë·∫ßu ti√™n
                    if len(admin_records_for_batch) == 0:
                        token_status = check_google_token_status()
                        if not token_status.get('can_approve', False):
                            publish_token_status('expired', token_status.get('message', 'Token h·∫øt h·∫°n'), needs_reauth=True)
                            return jsonify({
                                'error': f"‚ö†Ô∏è Token Google API h·∫øt h·∫°n. {token_status.get('message', 'Vui l√≤ng refresh token tr∆∞·ªõc khi ph√™ duy·ªát.')}",
                                'error_code': 'token_expired',
                                'needs_reauth': True
                            }), 503

                    # Store original status for rollback
                    original_status = leave_request.status

                    # Save signatures first
                    if leave_request.status == 'pending' and user.has_personal_signature():
                        leave_request.team_leader_signature = user.personal_signature
                        leave_request.team_leader_signer_id = user.id

                    if leave_request.status == 'pending_manager' and user.has_personal_signature():
                        leave_request.manager_signature = user.personal_signature
                        leave_request.manager_signer_id = user.id

                    # Add admin signature
                    if user.has_personal_signature():
                        leave_request.admin_signature = user.personal_signature
                        leave_request.admin_signer_id = user.id
                        leave_request.admin_approved_at = datetime.now()

                    # L·∫•y th√¥ng tin employee
                    employee = leave_request.user
                    if not employee:
                        employee = db.session.get(User, leave_request.user_id)

                    if not employee:
                        google_sheet_errors.append({
                            'id': leave_request.id,
                            'employee_name': leave_request.employee_name,
                            'error': 'Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√¢n vi√™n'
                        })
                        continue

                    employee_team = employee.department
                    employee_id = employee.employee_id

                    if not employee_id:
                        google_sheet_errors.append({
                            'id': leave_request.id,
                            'employee_name': leave_request.employee_name,
                            'error': 'Nh√¢n vi√™n ch∆∞a c√≥ m√£ nh√¢n vi√™n (employee_id)'
                        })
                        continue

                    if not employee_team or employee_team == "Unknown":
                        google_sheet_errors.append({
                            'id': leave_request.id,
                            'employee_name': leave_request.employee_name,
                            'error': 'Nh√¢n vi√™n ch∆∞a c·∫≠p nh·∫≠t ph√≤ng ban (Department)'
                        })
                        continue

                    # ===== GOM RECORD V√ÄO LIST ƒê·ªÇ BATCH UPDATE SAU =====
                    admin_records_for_batch.append({
                        'leave_request': leave_request,
                        'employee_team': employee_team,
                        'employee_id': employee_id,
                        'leave_data': {},  # S·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω trong batch_update function
                        'original_status': original_status
                    })

                    # Kh√¥ng tƒÉng approved_count ·ªü ƒë√¢y - s·∫Ω x·ª≠ l√Ω sau khi batch update
                    continue  # Skip to next record, batch update s·∫Ω x·ª≠ l√Ω sau


            elif action == 'reject':
                # T·ª´ ch·ªëi ƒë∆°n ngh·ªâ ph√©p
                leave_request.status = 'rejected'
                leave_request.reject_reason = reason
                leave_request.step = 'done'
                leave_request.current_approver_id = None
                rejected_count += 1

        # ===== BATCH UPDATE GOOGLE SHEETS FOR ADMIN RECORDS =====
        if current_role == 'ADMIN' and action == 'approve' and admin_records_for_batch:
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            try:
                print(f"\n{'='*80}", flush=True, file=sys.stderr)
                print(f"üöÄ [BATCH_LEAVE_UPDATE_START] {timestamp} - B·∫Øt ƒë·∫ßu BATCH UPDATE cho {len(admin_records_for_batch)} leave requests", flush=True, file=sys.stderr)
                print(f"{'='*80}", flush=True, file=sys.stderr)
            except Exception:
                pass

            # G·ªçi batch update
            batch_result = batch_update_multi_leave_requests_sync(admin_records_for_batch)

            # X·ª≠ l√Ω k·∫øt qu·∫£ batch update
            for record in admin_records_for_batch:
                leave_request = record['leave_request']
                original_status = record['original_status']

                if leave_request.id in batch_result['success_ids']:
                    # Google Sheet th√†nh c√¥ng - mark as approved
                    leave_request.status = 'approved'
                    leave_request.step = 'done'
                    leave_request.current_approver_id = None
                    leave_request.google_sheet_synced = True
                    leave_request.google_sheet_sync_at = datetime.now()
                    leave_request.google_sheet_sync_error = None
                    approved_leave_ids.append(leave_request.id)
                    approved_count += 1
                else:
                    # Google Sheet th·∫•t b·∫°i - rollback status
                    leave_request.status = original_status
                    leave_request.google_sheet_synced = False

                    # T√¨m error message
                    error_msg = 'Unknown error'
                    for failed in batch_result['failed']:
                        if failed['id'] == leave_request.id:
                            error_msg = failed['error']
                            break

                    leave_request.google_sheet_sync_error = error_msg
                    google_sheet_errors.append({
                        'id': leave_request.id,
                        'employee_name': leave_request.employee_name,
                        'error': error_msg,
                        'original_status': original_status
                    })

            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            try:
                print(f"\n{'='*80}", flush=True, file=sys.stderr)
                print(f"üìä [BATCH_LEAVE_UPDATE_COMPLETE] {timestamp}", flush=True, file=sys.stderr)
                print(f"   ‚úÖ Th√†nh c√¥ng: {len(batch_result['success_ids'])} leave requests", flush=True, file=sys.stderr)
                print(f"   ‚ùå Th·∫•t b·∫°i: {len(batch_result['failed'])} leave requests", flush=True, file=sys.stderr)
                print(f"   üì° T·ªïng API calls: {batch_result['total_api_calls']} (thay v√¨ {len(admin_records_for_batch)} async threads)", flush=True, file=sys.stderr)
                print(f"{'='*80}", flush=True, file=sys.stderr)
            except Exception:
                pass

        # ===== COMMIT DATABASE =====
        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        try:
            print(f"\n{'='*80}", flush=True, file=sys.stderr)
            print(f"üíæ [BULK_LEAVE_COMMIT] {timestamp} - ƒêang commit t·∫•t c·∫£ thay ƒë·ªïi...", flush=True, file=sys.stderr)
            print(f"{'='*80}", flush=True, file=sys.stderr)
        except Exception:
            pass

        try:
            db.session.commit()
            timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            try:
                print(f"‚úÖ [BULK_LEAVE_COMMIT_SUCCESS] {timestamp} - Database ƒë√£ ƒë∆∞·ª£c commit", flush=True, file=sys.stderr)
            except Exception:
                pass
        except Exception as commit_error:
            db.session.rollback()
            try:
                print(f"‚ùå [BULK_LEAVE_COMMIT_ERROR] L·ªói commit: {str(commit_error)}", flush=True, file=sys.stderr)
            except Exception:
                pass
            return jsonify({'error': 'L·ªói l∆∞u database'}), 500

        # ===== PREPARE RESPONSE WITH DETAILED SUMMARY =====
        successful_approvals = len(approved_leave_ids) if current_role == 'ADMIN' else approved_count
        failed_approvals = len(google_sheet_errors)
        total_processed = approved_count + rejected_count + failed_approvals # Include failed attempts in processed count? 
        # Logic ƒë·∫øm: total_processed l√† t·ªïng s·ªë record ƒë√£ DUY·ªÜT QUA. 
        # N·∫øu fail, n√≥ v·∫´n ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω (nh∆∞ng k·∫øt qu·∫£ l√† fail/revert).
        # Tuy nhi√™n bi·∫øn approved_count ch·ªâ tƒÉng khi th√†nh c√¥ng.
        
        total_processed = len(leave_requests) # T·ªïng s·ªë request g·ª≠i l√™n/query ƒë∆∞·ª£c

        
        # Build message
        message = f'ƒê√£ x·ª≠ l√Ω {total_processed} ƒë∆°n ngh·ªâ ph√©p'

        if action == 'approve':
            message += f': {approved_count} ph√™ duy·ªát th√†nh c√¥ng'
            if failed_approvals > 0:
                message += f', {failed_approvals} th·∫•t b·∫°i (gi·ªØ nguy√™n status ƒë·ªÉ th·ª≠ l·∫°i)'
            if rejected_count > 0:
                message += f', {rejected_count} t·ª´ ch·ªëi'
        else:
            message += f': {approved_count} ph√™ duy·ªát, {rejected_count} t·ª´ ch·ªëi'

        # Log summary
        timestamp = dt.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        try:
            print(f"\n{'='*80}", flush=True, file=sys.stderr)
            print(f"üìä [BULK_LEAVE_SUMMARY] {timestamp}", flush=True, file=sys.stderr)
            print(f"   T·ªïng s·ªë x·ª≠ l√Ω: {total_processed}", flush=True, file=sys.stderr)
            print(f"   ‚úÖ Ph√™ duy·ªát th√†nh c√¥ng: {approved_count}", flush=True, file=sys.stderr)
            if approved_leave_ids:
                print(f"      IDs: {', '.join(map(str, approved_leave_ids))}", flush=True, file=sys.stderr)
            if failed_approvals > 0:
                print(f"   ‚ö†Ô∏è Th·∫•t b·∫°i (Google Sheet): {failed_approvals}", flush=True, file=sys.stderr)
            print(f"   ‚ùå T·ª´ ch·ªëi: {rejected_count}", flush=True, file=sys.stderr)
            print(f"{'='*80}\n", flush=True, file=sys.stderr)
        except Exception:
            pass
        
        return jsonify({
            'success': True,
            'message': message,
            'total_processed': total_processed,
            'approved_count': approved_count,
            'rejected_count': rejected_count,
            'failed_approvals': failed_approvals,
            'approved_ids': approved_leave_ids,
            'failed_records': google_sheet_errors
        }), 200
        
    except Exception as e:
        db.session.rollback()
        print(f"Error in bulk leave approval: {e}", flush=True, file=sys.stderr)
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói khi x·ª≠ l√Ω h√†ng lo·∫°t: {str(e)}'}), 500


@app.route('/test-auth')
def test_auth():
    """Test route ƒë·ªÉ ki·ªÉm tra authentication"""
    if 'user_id' not in session:
        return jsonify({'authenticated': False, 'error': 'Not logged in'}), 401
    
    user = db.session.get(User, session['user_id'])
    if not user:
        return jsonify({'authenticated': False, 'error': 'Invalid user'}), 401
    
    return jsonify({
        'authenticated': True,
        'user_id': user.id,
        'user_name': user.name,
        'roles': user.roles
    })

@app.route('/leave-request', methods=['GET'])
def leave_request_form():
    """Hi·ªÉn th·ªã form xin ngh·ªâ ph√©p"""
    try:
        # Ki·ªÉm tra user ƒë√£ ƒëƒÉng nh·∫≠p
        if 'user_id' not in session:
            flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
            return redirect(url_for('login'))
        
        user = db.session.get(User, session['user_id'])
        if not user:
            session.clear()
            flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
            return redirect(url_for('login'))
        
        # L·∫•y vai tr√≤ hi·ªán t·∫°i t·ª´ session
        current_role = session.get('current_role', user.roles.split(',')[0])
        # Current role setup for leave request form
        work_shift = '08:00 - 17:00'
        return render_template('leave_request_form.html', user=user, current_role=current_role, work_shift=work_shift)
    except Exception as e:
        print(f"Error in leave_request_form: {e}")
        flash('C√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i', 'error')
        return redirect(url_for('dashboard'))


@app.route('/activate', methods=['GET', 'POST'])
def activate():
    """
    Trang nh·∫≠p key k√≠ch ho·∫°t ·ª©ng d·ª•ng (cho web).
    ƒê·∫£m b·∫£o logic nh·∫•t qu√°n v·ªõi API /api/activate cho mobile.
    """
    activation = get_activation_record()
    
    # Log ƒë·ªÉ debug
    print(f"[ACTIVATE WEB] Request t·ª´: {request.remote_addr}, User-Agent: {request.headers.get('User-Agent', 'Unknown')}")
    print(f"[ACTIVATE WEB] Tr·∫°ng th√°i hi·ªán t·∫°i - is_activated: {activation.is_activated}, license_key trong DB: {activation.license_key}")

    # N·∫øu ƒë√£ k√≠ch ho·∫°t r·ªìi th√¨ chuy·ªÉn v·ªÅ trang ƒëƒÉng nh·∫≠p / dashboard
    if activation.is_activated:
        current_key = get_license_key()
        print(f"[ACTIVATE WEB] ƒê√£ k√≠ch ho·∫°t, key hi·ªán t·∫°i: {current_key}")
        if 'user_id' in session:
            return redirect(url_for('dashboard'))
        return redirect(url_for('login'))

    if request.method == 'POST':
        input_key = (request.form.get('license_key') or '').strip()
        print(f"[ACTIVATE WEB] Key nh·∫≠n ƒë∆∞·ª£c t·ª´ form: {input_key[:10]}... (ƒë·ªô d√†i: {len(input_key)})")
        print(f"[ACTIVATE WEB] Key chu·∫©n tr√™n server (APP_LICENSE_KEY): {APP_LICENSE_KEY[:10]}... (ƒë·ªô d√†i: {len(APP_LICENSE_KEY)})")
        
        if not input_key:
            flash('Vui l√≤ng nh·∫≠p key k√≠ch ho·∫°t!', 'error')
            return render_template('activate.html')

        # So s√°nh v·ªõi key chu·∫©n tr√™n server (gi·ªëng nh∆∞ API /api/activate)
        if input_key == APP_LICENSE_KEY:
            activation.is_activated = True
            activation.license_key = input_key
            activation.activated_at = datetime.utcnow()
            try:
                db.session.commit()
                print(f"[ACTIVATE WEB] ‚úÖ K√≠ch ho·∫°t th√†nh c√¥ng! Key ƒë√£ l∆∞u v√†o DB: {input_key[:10]}...")
                flash('K√≠ch ho·∫°t th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p v√† s·ª≠ d·ª•ng h·ªá th·ªëng.', 'success')
                return redirect(url_for('login'))
            except Exception as e:
                db.session.rollback()
                print(f"[ACTIVATE WEB] ‚ùå L·ªói l∆∞u k√≠ch ho·∫°t: {e}")
                flash('C√≥ l·ªói khi l∆∞u th√¥ng tin k√≠ch ho·∫°t. Vui l√≤ng th·ª≠ l·∫°i.', 'error')
        else:
            print(f"[ACTIVATE WEB] ‚ùå Key kh√¥ng h·ª£p l·ªá! Input: {input_key[:10]}..., Expected: {APP_LICENSE_KEY[:10]}...")
            flash('Key k√≠ch ho·∫°t kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.', 'error')

    return render_template('activate.html')

@app.route('/api/activate', methods=['POST'])
def api_activate():
    """
    API endpoint ƒë·ªÉ k√≠ch ho·∫°t license key (d√πng cho mobile app).
    Tr·∫£ v·ªÅ JSON thay v√¨ HTML nh∆∞ route /activate.
    ƒê·∫£m b·∫£o logic nh·∫•t qu√°n v·ªõi route /activate cho web.
    """
    try:
        activation = get_activation_record()
        
        # Log ƒë·ªÉ debug
        print(f"[ACTIVATE API] Request t·ª´: {request.remote_addr}, User-Agent: {request.headers.get('User-Agent', 'Unknown')}")
        print(f"[ACTIVATE API] Tr·∫°ng th√°i hi·ªán t·∫°i - is_activated: {activation.is_activated}, license_key trong DB: {activation.license_key}")

        # N·∫øu ƒë√£ k√≠ch ho·∫°t r·ªìi th√¨ tr·∫£ v·ªÅ th√¥ng b√°o
        if activation.is_activated:
            current_key = get_license_key()
            print(f"[ACTIVATE API] ƒê√£ k√≠ch ho·∫°t, key hi·ªán t·∫°i: {current_key}")
            return jsonify({
                'success': True,
                'message': '·ª®ng d·ª•ng ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t',
                'activated': True,
                'license_key': activation.license_key,
                'current_license_key': current_key  # Key ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng
            })

        # L·∫•y key t·ª´ request (c√≥ th·ªÉ l√† form data ho·∫∑c JSON)
        if request.is_json:
            data = request.get_json()
            input_key = (data.get('license_key') or '').strip()
        else:
            input_key = (request.form.get('license_key') or '').strip()

        print(f"[ACTIVATE API] Key nh·∫≠n ƒë∆∞·ª£c t·ª´ request: {input_key[:10]}... (ƒë·ªô d√†i: {len(input_key)})")
        print(f"[ACTIVATE API] Key chu·∫©n tr√™n server (APP_LICENSE_KEY): {APP_LICENSE_KEY[:10]}... (ƒë·ªô d√†i: {len(APP_LICENSE_KEY)})")

        if not input_key:
            return jsonify({
                'success': False,
                'error': 'Vui l√≤ng nh·∫≠p key k√≠ch ho·∫°t!'
            }), 400

        # So s√°nh v·ªõi key chu·∫©n tr√™n server (gi·ªëng nh∆∞ route /activate)
        if input_key == APP_LICENSE_KEY:
            activation.is_activated = True
            activation.license_key = input_key
            activation.activated_at = datetime.utcnow()
            try:
                db.session.commit()
                print(f"[ACTIVATE API] ‚úÖ K√≠ch ho·∫°t th√†nh c√¥ng! Key ƒë√£ l∆∞u v√†o DB: {input_key[:10]}...")
                return jsonify({
                    'success': True,
                    'message': 'K√≠ch ho·∫°t th√†nh c√¥ng! B·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p v√† s·ª≠ d·ª•ng h·ªá th·ªëng.',
                    'activated': True,
                    'license_key': input_key
                })
            except Exception as e:
                db.session.rollback()
                print(f"[ACTIVATE API] ‚ùå L·ªói l∆∞u k√≠ch ho·∫°t: {e}")
                return jsonify({
                    'success': False,
                    'error': 'C√≥ l·ªói khi l∆∞u th√¥ng tin k√≠ch ho·∫°t. Vui l√≤ng th·ª≠ l·∫°i.'
                }), 500
        else:
            print(f"[ACTIVATE API] ‚ùå Key kh√¥ng h·ª£p l·ªá! Input: {input_key[:10]}..., Expected: {APP_LICENSE_KEY[:10]}...")
            return jsonify({
                'success': False,
                'error': 'Key k√≠ch ho·∫°t kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.'
            }), 400

    except Exception as e:
        print(f"[ACTIVATE API] ‚ùå L·ªói trong api_activate: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': f'L·ªói server: {str(e)}'
        }), 500

@app.route('/api/activation/status', methods=['GET'])
def api_activation_status():
    """
    API endpoint ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i k√≠ch ho·∫°t (d√πng cho mobile app).
    Tr·∫£ v·ªÅ key ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng (t·ª´ DB ho·∫∑c env variable) ƒë·ªÉ ƒë·∫£m b·∫£o nh·∫•t qu√°n.
    """
    try:
        activation = get_activation_record()
        current_key = get_license_key()  # Key ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng th·ª±c t·∫ø
        
        return jsonify({
            'activated': activation.is_activated,
            'license_key': activation.license_key if activation.is_activated else None,  # Key trong DB
            'current_license_key': current_key,  # Key ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng (t·ª´ DB ho·∫∑c env)
            'activated_at': activation.activated_at.isoformat() if activation.activated_at else None,
            'app_license_key': APP_LICENSE_KEY  # Key chu·∫©n tr√™n server (ƒë·ªÉ debug)
        })
    except Exception as e:
        print(f"[ERROR] L·ªói trong api_activation_status: {e}")
        return jsonify({
            'error': f'L·ªói server: {str(e)}'
        }), 500

@app.route('/leave-request', methods=['POST'])
def submit_leave_request():
    """X·ª≠ l√Ω ƒë∆°n xin ngh·ªâ ph√©p"""
    try:
        print("[Leave][Create] submit_leave_request called")
        # Ki·ªÉm tra user ƒë√£ ƒëƒÉng nh·∫≠p
        if 'user_id' not in session:
            flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
            return redirect(url_for('login'))
        
        user = db.session.get(User, session['user_id'])
        if not user:
            session.clear()
            flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
            return redirect(url_for('login'))
        
        # L·∫•y d·ªØ li·ªáu t·ª´ form
        data = request.form
        
        # X·ª≠ l√Ω file upload
        attachments_info = []
        if 'attachments' in request.files:
            files = request.files.getlist('attachments')
            for file in files:
                if file and file.filename:
                    # T·∫°o t√™n file unique
                    filename = f"{uuid.uuid4()}_{file.filename}"
                    
                    # T·∫°o th∆∞ m·ª•c uploads n·∫øu ch∆∞a c√≥
                    upload_dir = os.path.join(app.root_path, 'uploads', 'leave_requests')
                    os.makedirs(upload_dir, exist_ok=True)
                    
                    # L∆∞u file
                    file_path = os.path.join(upload_dir, filename)
                    file.save(file_path)
                    
                    attachments_info.append({
                        'original_name': file.filename,
                        'saved_name': filename,
                        'size': file.content_length or 0
                    })
        
        # Parse tr∆∞·ªõc m·ªôt s·ªë tr∆∞·ªùng ng√†y ƒë·ªÉ r√†ng bu·ªôc h·ª£p l·ªá
        from_date_str = data.get('leave_from_date', '2024-01-01')
        to_date_str = data.get('leave_to_date', '2024-01-01')
        try:
            from_date_dt = datetime.strptime(from_date_str, '%Y-%m-%d')
            to_date_dt = datetime.strptime(to_date_str, '%Y-%m-%d')
        except Exception:
            flash('ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá', 'error')
            return redirect(url_for('leave_request_form'))

        requested_annual = float(data.get('annual_leave_days', 0) or 0)
        requested_unpaid = float(data.get('unpaid_leave_days', 0) or 0)
        requested_special = float(data.get('special_leave_days', 0) or 0)
        total_requested_days = requested_annual + requested_unpaid + requested_special
        # S·ª≠ d·ª•ng k·∫øt qu·∫£ t√≠nh to√°n t·ª´ frontend (ƒë√£ t√≠nh ƒë√∫ng theo ca l√†m vi·ªác)
        # Frontend ƒë√£ t√≠nh to√°n ch√≠nh x√°c theo ca l√†m vi·ªác v√† gi·ªù ngh·ªâ tr∆∞a
        from_time_str = data.get('leave_from_time') or '00:00'
        to_time_str = data.get('leave_to_time') or '00:00'

        # Validate: Th·ªùi gian b·∫Øt ƒë·∫ßu ph·∫£i nh·ªè h∆°n th·ªùi gian k·∫øt th√∫c
        try:
            clean_from_time = clean_time_format(from_time_str)
            clean_to_time = clean_time_format(to_time_str)
            
            start_dt = datetime.combine(from_date_dt.date(), datetime.strptime(clean_from_time, '%H:%M').time())
            end_dt = datetime.combine(to_date_dt.date(), datetime.strptime(clean_to_time, '%H:%M').time())
        except Exception:
            flash('ƒê·ªãnh d·∫°ng gi·ªù kh√¥ng h·ª£p l·ªá', 'error')
            return redirect(url_for('leave_request_form'))
        if start_dt >= end_dt:
            flash('Th·ªùi gian t·ª´ ng√†y gi·ªù ph·∫£i nh·ªè h∆°n ƒë·∫øn ng√†y gi·ªù', 'error')
            return redirect(url_for('leave_request_form'))
        
        # Validate: Gi·ªù k·∫øt th√∫c kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° gi·ªù ra kh·ªèi ca
        shift_code = data.get('leave_shift_code', '1')
        shift_ranges = {
            '1': {'start': '07:30', 'end': '16:30'},
            '2': {'start': '09:00', 'end': '18:00'},
            '3': {'start': '11:00', 'end': '20:00'},
            '4': {'start': '08:00', 'end': '17:00'}
        }
        
        if shift_code in shift_ranges:
            shift_end_time = shift_ranges[shift_code]['end']
            shift_end_dt = datetime.combine(to_date_dt.date(), datetime.strptime(shift_end_time, '%H:%M').time())
            
            # Ch·ªâ ki·ªÉm tra n·∫øu c√πng ng√†y (kh√¥ng ki·ªÉm tra khi ngh·ªâ qua nhi·ªÅu ng√†y)
            if from_date_dt.date() == to_date_dt.date() and end_dt > shift_end_dt:
                flash(f'Gi·ªù k·∫øt th√∫c ngh·ªâ ({clean_to_time}) kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° gi·ªù ra kh·ªèi ca ({shift_end_time})', 'error')
                return redirect(url_for('leave_request_form'))
        
        # L·∫•y k·∫øt qu·∫£ t√≠nh to√°n t·ª´ frontend n·∫øu c√≥
        frontend_calculated_days = data.get('calculated_leave_days')
        if frontend_calculated_days is not None:
            available_units = float(frontend_calculated_days)
        else:
            # Fallback: t√≠nh theo logic c≈© (kh√¥ng ch√≠nh x√°c cho t·∫•t c·∫£ ca)
            available_units = _compute_leave_units_generic(from_date_dt, from_time_str, to_date_dt, to_time_str)
        
        if total_requested_days > available_units + 1e-9:
            flash('T·ªïng s·ªë ng√†y xin ngh·ªâ v∆∞·ª£t qu√° s·ªë ng√†y c√≥ th·ªÉ xin trong kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn (theo ca l√†m vi·ªác).', 'error')
            return redirect(url_for('leave_request_form'))

        # T·∫°o ƒë∆°n xin ngh·ªâ ph√©p m·ªõi
        leave_request = LeaveRequest(
            user_id=user.id,
            employee_name=data.get('employee_name'),
            team=data.get('team'),
            employee_code=data.get('employee_code'),
            request_type=data.get('request_type', 'leave'),
            late_early_type=data.get('late_early_type'),
            leave_reason=data.get('leave_reason'),
            attachments=json.dumps(attachments_info) if attachments_info else None,
            reason_sick_child=bool(data.get('reason_sick_child')),
            reason_sick=bool(data.get('reason_sick')),
            reason_death_anniversary=bool(data.get('reason_death_anniversary')),
            reason_other=bool(data.get('reason_other')),
            reason_other_detail=data.get('reason_other_detail'),
            hospital_confirmation=bool(data.get('hospital_confirmation')),
            wedding_invitation=bool(data.get('wedding_invitation')),
            death_birth_certificate=bool(data.get('death_birth_certificate')),
            leave_from_hour=int(clean_from_time.split(':')[0]),
            leave_from_minute=int(clean_from_time.split(':')[1]),
            leave_from_day=int(data.get('leave_from_date', '2024-01-01').split('-')[2]),
            leave_from_month=int(data.get('leave_from_date', '2024-01-01').split('-')[1]),
            leave_from_year=int(data.get('leave_from_date', '2024-01-01').split('-')[0]),
            leave_to_hour=int(clean_to_time.split(':')[0]),
            leave_to_minute=int(clean_to_time.split(':')[1]),
            leave_to_day=int(data.get('leave_to_date', '2024-01-01').split('-')[2]),
            leave_to_month=int(data.get('leave_to_date', '2024-01-01').split('-')[1]),
            leave_to_year=int(data.get('leave_to_date', '2024-01-01').split('-')[0]),
            annual_leave_days=float(data.get('annual_leave_days', 0) or 0),
            unpaid_leave_days=float(data.get('unpaid_leave_days', 0) or 0),
            special_leave_days=float(data.get('special_leave_days', 0) or 0),
            japan_holiday_days=float(data.get('japan_holiday_days', 0) or 0),
            scope_leave_days=float(data.get('scope_leave_days', 0) or 0),
            special_leave_type=data.get('special_leave_type'),
            substitute_name=data.get('substitute_name'),
            substitute_employee_id=data.get('substitute_employee_id'),
            notes=data.get('notes'),
            # L∆∞u ca √°p d·ª•ng khi xin ngh·ªâ (t√πy ch·ªçn)
            # T∆∞∆°ng th√≠ch: n·∫øu kh√¥ng c√≥, gi·ªØ None
            shift_code=data.get('leave_shift_code') if data.get('leave_shift_code') in ['1','2','3','4'] else None,
            status='pending',
            # Th√¥ng tin ng√†y lo·∫°i tr·ª´ (cu·ªëi tu·∫ßn, l·ªÖ Vi·ªát, l·ªÖ Nh·∫≠t)
            excluded_days_json=data.get('excluded_days_json') if data.get('excluded_days_json') else None,
            total_calendar_days=int(data.get('total_calendar_days', 0) or 0),
            total_excluded_days=int(data.get('total_excluded_days', 0) or 0),
            total_working_days=float(data.get('total_working_days', 0) or 0),
            weekend_count=int(data.get('weekend_count', 0) or 0),
            vietnamese_holiday_count=int(data.get('vietnamese_holiday_count', 0) or 0),
            japanese_holiday_count=int(data.get('japanese_holiday_count', 0) or 0)
        )
        
        # L∆∞u use_lunch_break v√†o notes d∆∞·ªõi d·∫°ng JSON
        use_lunch_break_value = data.get('use_lunch_break')
        if use_lunch_break_value in ['true', 'false']:
            import json
            notes_data = {}
            original_notes_text = None
            
            if leave_request.notes:
                try:
                    # Th·ª≠ parse JSON
                    notes_data = json.loads(leave_request.notes)
                    if not isinstance(notes_data, dict):
                        # N·∫øu kh√¥ng ph·∫£i dict, gi·ªØ l·∫°i text g·ªëc
                        original_notes_text = leave_request.notes
                        notes_data = {}
                except:
                    # N·∫øu kh√¥ng ph·∫£i JSON, gi·ªØ l·∫°i text g·ªëc
                    original_notes_text = leave_request.notes
                    notes_data = {}
            
            # L∆∞u use_lunch_break
            notes_data['use_lunch_break'] = use_lunch_break_value == 'true'
            
            # N·∫øu c√≥ notes text g·ªëc, th√™m v√†o notes_data
            if original_notes_text:
                notes_data['_original_notes'] = original_notes_text
            
            leave_request.notes = json.dumps(notes_data, ensure_ascii=False)
            
            try:
                _safe_print(f"[Leave][Create] ƒê√£ l∆∞u use_lunch_break={use_lunch_break_value == 'true'} v√†o notes cho ƒë∆°n #{leave_request.id}")
            except Exception:
                pass
        
        # R√†ng bu·ªôc: c√°c s·ªë ng√†y ph·∫£i l√† b·ªôi s·ªë 0.5
        def ensure_half_step(x):
            return (int(round(x * 2)) / 2.0)

        # Auto-calculate japan_holiday_days v√† scope_leave_days n·∫øu ng∆∞·ªùi d√πng kh√¥ng nh·∫≠p
        # nh∆∞ng l√Ω do ngh·ªâ ho·∫∑c ph√≤ng ban li√™n quan ƒë·∫øn York/Scope
        try:
            leave_reason_lower = (leave_request.leave_reason or '').lower()
            user_department_lower = (user.department or '').lower()

            # T√≠nh s·ªë gi·ªù ngh·ªâ t·ª´ th·ªùi gian ƒëƒÉng k√Ω
            from datetime import datetime as dt_calc
            leave_from_dt = dt_calc(
                leave_request.leave_from_year, leave_request.leave_from_month, leave_request.leave_from_day,
                leave_request.leave_from_hour, leave_request.leave_from_minute
            )
            leave_to_dt = dt_calc(
                leave_request.leave_to_year, leave_request.leave_to_month, leave_request.leave_to_day,
                leave_request.leave_to_hour, leave_request.leave_to_minute
            )
            duration_hours = (leave_to_dt - leave_from_dt).total_seconds() / 3600

            # T√≠nh s·ªë ng√†y t·ª± ƒë·ªông (1 ng√†y = 8 gi·ªù, l√†m tr√≤n 0.5)
            auto_days = ensure_half_step(duration_hours / 8.0)

            # Ki·ªÉm tra ƒëi·ªÅu ki·ªán cho ngh·ªâ l·ªÖ Nh·∫≠t (York)
            is_york_related = (
                'york' in user_department_lower or
                'l·ªÖ nh·∫≠t' in leave_reason_lower or
                'le nhat' in leave_reason_lower or
                'ngh·ªâ b√π' in leave_reason_lower and 'nh·∫≠t' in leave_reason_lower
            )

            # Ki·ªÉm tra ƒëi·ªÅu ki·ªán cho ngh·ªâ Scope
            is_scope_related = 'scope' in user_department_lower

            # T·ª± ƒë·ªông ƒëi·ªÅn japan_holiday_days n·∫øu li√™n quan ƒë·∫øn York v√† ch∆∞a nh·∫≠p
            if is_york_related and (leave_request.japan_holiday_days or 0) == 0:
                # Ch·ªâ auto-fill n·∫øu t·∫•t c·∫£ c√°c lo·∫°i ng√†y kh√°c ƒë·ªÅu = 0
                total_other_days = (
                    (leave_request.annual_leave_days or 0) +
                    (leave_request.unpaid_leave_days or 0) +
                    (leave_request.special_leave_days or 0) +
                    (leave_request.scope_leave_days or 0)
                )
                if total_other_days == 0 and auto_days > 0:
                    leave_request.japan_holiday_days = auto_days
                    _safe_print(f"[Leave][Auto] Auto-filled japan_holiday_days={auto_days} for request (York/L·ªÖ Nh·∫≠t)")

            # T·ª± ƒë·ªông ƒëi·ªÅn scope_leave_days n·∫øu li√™n quan ƒë·∫øn Scope v√† ch∆∞a nh·∫≠p
            if is_scope_related and not is_york_related and (leave_request.scope_leave_days or 0) == 0:
                # Ch·ªâ auto-fill n·∫øu t·∫•t c·∫£ c√°c lo·∫°i ng√†y kh√°c ƒë·ªÅu = 0
                total_other_days = (
                    (leave_request.annual_leave_days or 0) +
                    (leave_request.unpaid_leave_days or 0) +
                    (leave_request.special_leave_days or 0) +
                    (leave_request.japan_holiday_days or 0)
                )
                if total_other_days == 0 and auto_days > 0:
                    leave_request.scope_leave_days = auto_days
                    _safe_print(f"[Leave][Auto] Auto-filled scope_leave_days={auto_days} for request (Scope)")
        except Exception as auto_calc_err:
            _safe_print(f"[Leave][Auto] Error in auto-calculation: {auto_calc_err}")

        leave_request.annual_leave_days = ensure_half_step(leave_request.annual_leave_days or 0.0)
        leave_request.unpaid_leave_days = ensure_half_step(leave_request.unpaid_leave_days or 0.0)
        leave_request.special_leave_days = ensure_half_step(leave_request.special_leave_days or 0.0)
        leave_request.japan_holiday_days = ensure_half_step(leave_request.japan_holiday_days or 0.0)
        leave_request.scope_leave_days = ensure_half_step(leave_request.scope_leave_days or 0.0)

        # Ki·ªÉm tra l·∫ßn n·ªØa sau chu·∫©n h√≥a: t·ªïng kh√¥ng v∆∞·ª£t qu√° ƒë∆°n v·ªã ngh·ªâ t√≠nh ƒë∆∞·ª£c
        total_leave = (leave_request.annual_leave_days + leave_request.unpaid_leave_days +
                       leave_request.special_leave_days + leave_request.japan_holiday_days +
                       leave_request.scope_leave_days)
        if total_leave > available_units + 1e-9:
            flash('T·ªïng s·ªë ng√†y xin ngh·ªâ v∆∞·ª£t qu√° s·ªë ng√†y c√≥ th·ªÉ xin trong kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn (theo ca l√†m vi·ªác).', 'error')
            return redirect(url_for('leave_request_form'))

        # L∆∞u v√†o c∆° s·ªü d·ªØ li·ªáu
        db.session.add(leave_request)
        db.session.commit()
        
        # Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ mu·ªën g·ª≠i email hay kh√¥ng
        email_consent = data.get('email_consent', 'no').lower()
        send_email = email_consent == 'yes'

        if send_email:
            # G·ª≠i email th√¥ng b√°o ƒë·∫øn HR (b·∫•t ƒë·ªìng b·ªô)
            try:
                print(f"[Mail] Attempting to send create email for leave_request #{leave_request.id} by user #{user.id} ({user.name})")
                send_leave_request_email_async(leave_request, user, action='create')
                # Process any pending DB updates from async threads
                from utils.email_utils import process_db_updates
                process_db_updates()
                # Persist 'sending' immediately
                upsert_email_status(leave_request.id, 'sending', 'ƒêang g·ª≠i email th√¥ng b√°o...')
                # L∆∞u tr·∫°ng th√°i email v√†o session cho t·∫•t c·∫£ vai tr√≤
                session['email_status'] = {
                    'request_id': leave_request.id,
                    'status': 'sending',
                    'message': 'ƒêang g·ª≠i email th√¥ng b√°o...'
                }
                # Ch·ªâ th√¥ng b√°o v·ªÅ ƒë∆°n; ti·∫øn tr√¨nh email s·∫Ω do toast hi·ªÉn th·ªã
                # flash('ƒê∆°n xin ngh·ªâ ph√©p ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng! Email th√¥ng b√°o ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn ph√≤ng nh√¢n s·ª±.', 'success')
            except Exception as e:
                print(f"[Mail] Error scheduling leave create email: {e}")
                # L∆∞u tr·∫°ng th√°i email v√†o session cho t·∫•t c·∫£ vai tr√≤
                session['email_status'] = {
                    'request_id': leave_request.id,
                    'status': 'error',
                    'message': f'L·ªói khi g·ª≠i email: {str(e)}'
                }
                flash('ƒê∆°n ƒë√£ g·ª≠i th√†nh c√¥ng, nh∆∞ng c√≥ l·ªói khi g·ª≠i email th√¥ng b√°o.', 'warning')
        else:
            # Kh√¥ng g·ª≠i email
            print(f"[Mail] User chose not to send email for leave_request #{leave_request.id}")
            session['email_status'] = {
                'request_id': leave_request.id,
                'status': 'skipped',
                'message': 'Ng∆∞·ªùi d√πng ƒë√£ ch·ªçn kh√¥ng g·ª≠i email th√¥ng b√°o'
            }
            # flash('ƒê∆°n xin ngh·ªâ ph√©p ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng! (Kh√¥ng g·ª≠i email th√¥ng b√°o)', 'success')
        return redirect(url_for('leave_requests_list', request_id=leave_request.id))
        
    except Exception as e:
        db.session.rollback()
        print(f"Error in submit_leave_request: {e}")
        flash(f'L·ªói khi g·ª≠i ƒë∆°n xin ngh·ªâ ph√©p: {str(e)}', 'error')
        return redirect(url_for('leave_request_form'))

@app.route('/leave-request/<int:request_id>/attachment/<filename>')
def download_leave_attachment(request_id, filename):
    """Download attachment file for leave request"""
    try:
        # Ki·ªÉm tra user ƒë√£ ƒëƒÉng nh·∫≠p
        if 'user_id' not in session:
            flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
            return redirect(url_for('login'))
        
        user = db.session.get(User, session['user_id'])
        if not user:
            session.clear()
            flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
            return redirect(url_for('login'))
        
        # L·∫•y leave request
        leave_request = LeaveRequest.query.get_or_404(request_id)
        
        # Ki·ªÉm tra quy·ªÅn truy c·∫≠p (ch·ªâ user t·∫°o ƒë∆°n ho·∫∑c admin/manager m·ªõi xem ƒë∆∞·ª£c)
        current_role = session.get('current_role', user.roles.split(',')[0])
        if not (user.id == leave_request.user_id or 
                current_role in ['ADMIN', 'MANAGER', 'TEAM_LEADER']):
            flash('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p file n√†y', 'error')
            return redirect(url_for('leave_requests_list'))
        
        # Ki·ªÉm tra file c√≥ trong attachments kh√¥ng
        if not leave_request.attachments:
            flash('Kh√¥ng t√¨m th·∫•y file ƒë√≠nh k√®m', 'error')
            return redirect(url_for('view_leave_request', request_id=request_id))
        
        attachments = json.loads(leave_request.attachments)
        file_info = None
        for att in attachments:
            if att['saved_name'] == filename:
                file_info = att
                break
        
        if not file_info:
            flash('File kh√¥ng t·ªìn t·∫°i', 'error')
            return redirect(url_for('view_leave_request', request_id=request_id))
        
        # ƒê∆∞·ªùng d·∫´n file
        file_path = os.path.join(app.root_path, 'uploads', 'leave_requests', filename)
        
        if not os.path.exists(file_path):
            flash('File kh√¥ng t·ªìn t·∫°i tr√™n server', 'error')
            return redirect(url_for('view_leave_request', request_id=request_id))
        
        return send_file(file_path, as_attachment=True, download_name=file_info['original_name'])
        
    except Exception as e:
        print(f"Error in download_leave_attachment: {e}")
        flash('C√≥ l·ªói x·∫£y ra khi t·∫£i file', 'error')
        return redirect(url_for('leave_requests_list'))

@app.route('/leave-request/<int:request_id>/download-all')
def download_all_leave_attachments(request_id):
    """Download all attachments as ZIP file for leave request"""
    try:
        # Ki·ªÉm tra user ƒë√£ ƒëƒÉng nh·∫≠p
        if 'user_id' not in session:
            flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
            return redirect(url_for('login'))
        
        user = db.session.get(User, session['user_id'])
        if not user:
            session.clear()
            flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
            return redirect(url_for('login'))
        
        # L·∫•y leave request
        leave_request = LeaveRequest.query.get_or_404(request_id)
        
        # Ki·ªÉm tra quy·ªÅn truy c·∫≠p
        current_role = session.get('current_role', user.roles.split(',')[0])
        if not (user.id == leave_request.user_id or 
                current_role in ['ADMIN', 'MANAGER', 'TEAM_LEADER']):
            flash('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p file n√†y', 'error')
            return redirect(url_for('leave_requests_list'))
        
        # Ki·ªÉm tra c√≥ attachments kh√¥ng
        if not leave_request.attachments:
            flash('Kh√¥ng c√≥ ch·ª©ng t·ª´ ƒë·ªÉ t·∫£i xu·ªëng', 'error')
            return redirect(url_for('view_leave_request', request_id=request_id))
        
        attachments = json.loads(leave_request.attachments)
        if not attachments:
            flash('Kh√¥ng c√≥ ch·ª©ng t·ª´ ƒë·ªÉ t·∫£i xu·ªëng', 'error')
            return redirect(url_for('view_leave_request', request_id=request_id))
        
        # T·∫°o ZIP file
        import zipfile
        import io
        
        zip_buffer = io.BytesIO()
        upload_dir = os.path.join(app.root_path, 'uploads', 'leave_requests')
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for attachment in attachments:
                file_path = os.path.join(upload_dir, attachment['saved_name'])
                if os.path.exists(file_path):
                    # S·ª≠ d·ª•ng t√™n file g·ªëc trong ZIP
                    zip_file.write(file_path, attachment['original_name'])
                else:
                    print(f"Warning: File not found: {file_path}")
        
        zip_buffer.seek(0)
        
        # T√™n file ZIP
        zip_filename = f"Ch·ª©ng_t·ª´_ngh·ªâ_ph√©p_{request_id}_{leave_request.employee_name.replace(' ', '_')}.zip"
        
        return send_file(zip_buffer, as_attachment=True, download_name=zip_filename, mimetype='application/zip')
        
    except Exception as e:
        print(f"Error in download_all_leave_attachments: {e}")
        flash('C√≥ l·ªói x·∫£y ra khi t·∫°o file ZIP', 'error')
        return redirect(url_for('view_leave_request', request_id=request_id))

@app.template_global()
def url_for_page(page):
    """
    Helper function ƒë·ªÉ t·∫°o URL ph√¢n trang an to√†n.
    Lo·∫°i b·ªè tham s·ªë 'page' c≈© kh·ªèi request.args tr∆∞·ªõc khi t·∫°o URL m·ªõi.
    """
    args = request.args.copy()
    args['page'] = page
    return url_for(request.endpoint, **args)

@app.route('/leave-requests')
def leave_requests_list():
    """Hi·ªÉn th·ªã danh s√°ch ƒë∆°n xin ngh·ªâ ph√©p"""
    try:
        # Ki·ªÉm tra user ƒë√£ ƒëƒÉng nh·∫≠p
        if 'user_id' not in session:
            flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
            return redirect(url_for('login'))
        
        user = db.session.get(User, session['user_id'])
        if not user:
            session.clear()
            flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
            return redirect(url_for('login'))
        
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        request_id = request.args.get('request_id', type=int)
        
        # L·∫•y vai tr√≤ hi·ªán t·∫°i t·ª´ session (di chuy·ªÉn l√™n ƒë·∫ßu ƒë·ªÉ tr√°nh NameError)
        user_roles = user.get_roles_list()
        current_role = session.get('current_role', user_roles[0] if user_roles else 'EMPLOYEE')
        
        # X√¢y d·ª±ng query c∆° b·∫£n
        query = LeaveRequest.query
        
        # L·ªçc theo tr·∫°ng th√°i
        status = request.args.get('status')
        if status:
            query = query.filter(LeaveRequest.status == status)
        
        # L·ªçc theo nh√¢n vi√™n
        employee = request.args.get('employee')
        if employee:
            query = query.filter(
                db.or_(
                    LeaveRequest.employee_name.contains(employee),
                    LeaveRequest.employee_code.contains(employee)
                )
            )
        
        # L·ªçc theo ph√≤ng ban (ch·ªâ cho ADMIN v√† MANAGER)
        department = request.args.get('department')
        if department and current_role in ['ADMIN', 'MANAGER']:
            query = query.join(User, User.id == LeaveRequest.user_id).filter(User.department == department)
        
        # L·ªçc theo lo·∫°i ƒë∆°n
        request_type = request.args.get('request_type')
        if request_type:
            query = query.filter(LeaveRequest.request_type == request_type)
        
        # L·ªçc theo ng√†y xin ngh·ªâ
        date_from = request.args.get('date_from')
        if date_from:
            try:
                from_date = datetime.strptime(date_from, '%Y-%m-%d')
                # L·ªçc c√°c ƒë∆°n c√≥ ng√†y k·∫øt th√∫c ngh·ªâ >= ng√†y b·∫Øt ƒë·∫ßu l·ªçc
                query = query.filter(
                    db.or_(
                        # Ng√†y k·∫øt th√∫c ngh·ªâ >= ng√†y l·ªçc
                        db.and_(
                            LeaveRequest.leave_to_year > from_date.year
                        ),
                        db.and_(
                            LeaveRequest.leave_to_year == from_date.year,
                            LeaveRequest.leave_to_month > from_date.month
                        ),
                        db.and_(
                            LeaveRequest.leave_to_year == from_date.year,
                            LeaveRequest.leave_to_month == from_date.month,
                            LeaveRequest.leave_to_day >= from_date.day
                        )
                    )
                )
            except ValueError:
                pass
        
        date_to = request.args.get('date_to')
        if date_to:
            try:
                to_date = datetime.strptime(date_to, '%Y-%m-%d')
                # L·ªçc c√°c ƒë∆°n c√≥ ng√†y b·∫Øt ƒë·∫ßu ngh·ªâ <= ng√†y k·∫øt th√∫c l·ªçc
                query = query.filter(
                    db.or_(
                        # Ng√†y b·∫Øt ƒë·∫ßu ngh·ªâ <= ng√†y l·ªçc
                        db.and_(
                            LeaveRequest.leave_from_year < to_date.year
                        ),
                        db.and_(
                            LeaveRequest.leave_from_year == to_date.year,
                            LeaveRequest.leave_from_month < to_date.month
                        ),
                        db.and_(
                            LeaveRequest.leave_from_year == to_date.year,
                            LeaveRequest.leave_from_month == to_date.month,
                            LeaveRequest.leave_from_day <= to_date.day
                        )
                    )
                )
            except ValueError:
                pass
        
        # L·ªçc theo vai tr√≤ v√† tr·∫°ng th√°i
        
        if current_role == 'TEAM_LEADER':
            # TEAM_LEADER ch·ªâ th·∫•y ƒë∆°n pending (ch∆∞a ƒë∆∞·ª£c ph√™ duy·ªát) c·ªßa c√πng ph√≤ng ban
            query = query.filter(
                LeaveRequest.status == 'pending',
                LeaveRequest.user.has(User.department == user.department)
            )
        elif current_role == 'MANAGER':
            # MANAGER ch·ªâ th·∫•y ƒë∆°n pending_manager (ƒë√£ ƒë∆∞·ª£c TEAM_LEADER ph√™ duy·ªát)
            query = query.filter(LeaveRequest.status == 'pending_manager')
        elif current_role == 'ADMIN':
            # ADMIN ch·ªâ th·∫•y ƒë∆°n pending_admin (ƒë√£ ƒë∆∞·ª£c MANAGER ph√™ duy·ªát)
            query = query.filter(LeaveRequest.status == 'pending_admin')
        else:
            # EMPLOYEE ch·ªâ th·∫•y ƒë∆°n c·ªßa m√¨nh
            query = query.filter(LeaveRequest.user_id == user.id)
        
        # S·∫Øp x·∫øp
        sort_by = request.args.get('sort_by', 'created_at')
        sort_dir = request.args.get('sort_dir', 'desc')
        sort_field = LeaveRequest.created_at
        if sort_by == 'status':
            sort_field = LeaveRequest.status
        elif sort_by == 'created_at':
            sort_field = LeaveRequest.created_at
        if sort_dir == 'asc':
            query = query.order_by(sort_field.asc())
        else:
            query = query.order_by(sort_field.desc())
        
        # Ph√¢n trang
        pagination = query.paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        # Parse attachments cho m·ªói leave request
        for leave_request in pagination.items:
            leave_request.attachments_list = []
            if leave_request.attachments:
                try:
                    leave_request.attachments_list = json.loads(leave_request.attachments)
                except (json.JSONDecodeError, TypeError, AttributeError):
                    leave_request.attachments_list = []
        
        # L·∫•y danh s√°ch ph√≤ng ban cho b·ªô l·ªçc
        try:
            # Th·ª≠ l·∫•y t·ª´ b·∫£ng Department tr∆∞·ªõc
            dept_objects = Department.query.filter(Department.is_active == True).order_by(Department.name.asc()).all()
            if dept_objects:
                departments = [d.name for d in dept_objects]
            else:
                # Fallback: distinct t·ª´ User n·∫øu Department tr·ªëng
                departments = sorted({u.department for u in User.query.filter(User.department.isnot(None), User.department != '').all()})
        except Exception:
            # Fallback: distinct t·ª´ User
            departments = sorted({u.department for u in User.query.filter(User.department.isnot(None), User.department != '').all()})
        
        return render_template('leave_requests_list.html', 
                             leave_requests=pagination.items,
                             pagination=pagination,
                             user=user,
                             current_role=current_role,
                             request_id=request_id,
                             departments=departments)
    except Exception as e:
        import traceback
        print(f"[ERROR] leave_requests_list exception: {str(e)}")
        print(traceback.format_exc())
        flash(f'C√≥ l·ªói x·∫£y ra khi t·∫£i danh s√°ch ƒë∆°n ngh·ªâ ph√©p: {str(e)}', 'error')
        return redirect(url_for('dashboard'))

@app.route('/leave-request/<int:request_id>')
def view_leave_request(request_id):
    """Xem chi ti·∫øt ƒë∆°n xin ngh·ªâ ph√©p"""
    if 'user_id' not in session:
        flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
        return redirect(url_for('login'))
    
    user = db.session.get(User, session['user_id'])
    if not user:
        session.clear()
        flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
        return redirect(url_for('login'))
    
    leave_request = LeaveRequest.query.get_or_404(request_id)
    
    # Ki·ªÉm tra quy·ªÅn truy c·∫≠p
    user_roles = user.get_roles_list()
    if not (any(role in ['ADMIN', 'MANAGER', 'TEAM_LEADER'] for role in user_roles) or 
            user.id == leave_request.user_id):
        abort(403)
    
    # L·∫•y vai tr√≤ hi·ªán t·∫°i t·ª´ session
    current_role = session.get('current_role', user.roles.split(',')[0])
    
    # Parse existing attachments for template
    attachments_list = []
    if leave_request.attachments:
        try:
            attachments_list = json.loads(leave_request.attachments)
        except (json.JSONDecodeError, TypeError, AttributeError):
            attachments_list = []
    
    return render_template('view_leave_request.html', leave_request=leave_request, user=user, current_role=current_role, request_id=request_id, attachments_list=attachments_list)

@app.route('/api/email-status/<int:request_id>')
def get_email_status(request_id):
    """API ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i g·ª≠i email"""
    print(f"[API] Email status request for request_id: {request_id}")
    
    if 'user_id' not in session:
        print("[API] Unauthorized - no user_id in session")
        return jsonify({'error': 'Unauthorized'}), 401
    
    user = db.session.get(User, session['user_id'])
    if not user:
        print("[API] User not found")
        return jsonify({'error': 'User not found'}), 401
    
    print(f"[API] User: {user.name}, Role: {user.roles}")
    
    # Tr·∫£ v·ªÅ email status cho t·∫•t c·∫£ vai tr√≤
    # (ƒê√£ lo·∫°i b·ªè gi·ªõi h·∫°n ch·ªâ cho nh√¢n vi√™n)
    
    # ∆Øu ti√™n tr·∫°ng th√°i trong DB tr∆∞·ªõc
    db_rec = get_email_status_record(request_id)
    if db_rec:
        resp = {'request_id': request_id, 'status': db_rec.status, 'message': db_rec.message}
        print(f"[API] DB status: {resp}")
        # N·∫øu l√† k·∫øt qu·∫£ cu·ªëi c√πng, d·ªçn tr·∫°ng th√°i ƒë·ªÉ kh√¥ng l·∫∑p l·∫°i
        if db_rec.status in ['success', 'error']:
            try:
                db.session.delete(db_rec)
                db.session.commit()
            except Exception as _:
                db.session.rollback()
            session.pop('email_status', None)
        return jsonify(resp)
    
    # N·∫øu kh√¥ng c√≥ global status, ki·ªÉm tra session
    if 'email_status' in session and session['email_status'].get('request_id') == request_id:
        session_status = session['email_status']
        print(f"[API] Found session status: {session_status}")
        # N·∫øu l√† k·∫øt qu·∫£ cu·ªëi c√πng, d·ªçn session
        if session_status.get('status') in ['success', 'error']:
            session.pop('email_status', None)
        return jsonify(session_status)
    
    # Fallback v·ªÅ unknown
    status = {'status': 'unknown', 'message': 'Kh√¥ng c√≥ th√¥ng tin'}
    print(f"[API] No status found, returning unknown: {status}")
    return jsonify(status)

@app.route('/api/email-status/latest')
def get_latest_email_status():
    """API: l·∫•y tr·∫°ng th√°i email g·∫ßn nh·∫•t t·ª´ session, kh√¥ng c·∫ßn request_id tr√™n URL.
    N·∫øu session ƒëang l√† 'sending' v√† c√≥ request_id, s·∫Ω ƒë·ªëi chi·∫øu v·ªõi global email_status
    ƒë·ªÉ tr·∫£ v·ªÅ k·∫øt qu·∫£ cu·ªëi c√πng khi c√≥ (success/error).
    """
    # Kh√¥ng d√πng print ·ªü ƒë√¢y ƒë·ªÉ tr√°nh l·ªói I/O tr√™n stdout khi server ch·∫°y n·ªÅn
    if 'user_id' not in session:
        print("[API] Latest: Unauthorized - no user_id in session")
        return jsonify({'error': 'Unauthorized'}), 401

    # L·∫•y t·ª´ session n·∫øu c√≥
    sess = session.get('email_status')
    if not sess:
        return jsonify({'status': 'unknown', 'message': 'Kh√¥ng c√≥ th√¥ng tin'})

    request_id = sess.get('request_id')
    if request_id:
        # Ki·ªÉm tra DB tr∆∞·ªõc
        db_rec = get_email_status_record(request_id)
        print(f"[API] Latest: DB status = {db_rec.status if db_rec else None}")
        if db_rec and db_rec.status in ['success', 'error']:
            response_payload = {
                'request_id': request_id,
                'status': db_rec.status,
                'message': db_rec.message
            }
            # D·ªçn DB v√† session ƒë·ªÉ kh√¥ng l·∫∑p l·∫°i
            try:
                db.session.delete(db_rec)
                db.session.commit()
            except Exception:
                db.session.rollback()
            session.pop('email_status', None)
            return jsonify(response_payload)

    # Ng∆∞·ª£c l·∫°i tr·∫£ v·ªÅ session hi·ªán t·∫°i
    # N·∫øu sess ƒë√£ l√† k·∫øt qu·∫£ cu·ªëi c√πng th√¨ d·ªçn lu√¥n v√† tr·∫£ m·ªôt l·∫ßn
    if sess and sess.get('status') in ['success', 'error']:
        payload = sess
        session.pop('email_status', None)
        return jsonify(payload)
    return jsonify(sess)

# ===================== SSE: Email Status Push =====================
# In-memory subscribers per user_id
_email_sse_subscribers = defaultdict(list)

def _sse_subscribe(user_id: int) -> Queue:
    q = Queue()
    _email_sse_subscribers[user_id].append(q)
    return q

def _sse_unsubscribe(user_id: int, q: Queue) -> None:
    try:
        if q in _email_sse_subscribers.get(user_id, []):
            _email_sse_subscribers[user_id].remove(q)
    except Exception:
        pass

def publish_email_status(user_id: int, request_id: int, status: str, message: str) -> None:
    """Publish an email status event to all live SSE subscribers of the user."""
    payload = {
        'request_id': request_id,
        'status': status,
        'message': message,
    }
    for q in list(_email_sse_subscribers.get(user_id, [])):
        try:
            q.put_nowait(payload)
        except Exception:
            # if queue full/broken, ignore
            pass

@app.route('/sse/email-status')
def sse_email_status():
    if 'user_id' not in session:
        return jsonify({'error': 'Unauthorized'}), 401

    user_id = session['user_id']
    q = _sse_subscribe(user_id)

    def stream():
        # advise client reconnection delay
        yield 'retry: 3000\n\n'
        try:
            # send a heartbeat every 15s if idle
            last = time_module.time()
            while True:
                try:
                    item = q.get(timeout=1.0)
                    import json as _json
                    data = _json.dumps(item, ensure_ascii=False)
                    yield f"event: email_status\ndata: {data}\n\n"
                    last = time_module.time()
                except Exception:
                    now = time_module.time()
                    if now - last > 15:
                        # comment heartbeat to keep connection alive
                        yield ": keep-alive\n\n"
                        last = now
        finally:
            _sse_unsubscribe(user_id, q)

    from flask import Response
    return Response(stream(), mimetype='text/event-stream', headers={'Cache-Control': 'no-cache', 'X-Accel-Buffering': 'no'})

@app.route('/api/test-email-status')
def test_email_status():
    """Test endpoint ƒë·ªÉ ki·ªÉm tra email status"""
    return jsonify({
        'global_status': dict(email_status),
        'session_status': session.get('email_status'),
        'message': 'Test endpoint for debugging'
    })

@app.route('/api/set-test-email-status/<int:request_id>')
def set_test_email_status(request_id):
    """Test endpoint ƒë·ªÉ set email status manually"""
    # Set global status
    email_status[request_id] = {
        'status': 'success',
        'message': 'Test email sent successfully!',
        'timestamp': time_module.time()
    }
    
    # Set session status
    session['email_status'] = {
        'request_id': request_id,
        'status': 'success',
        'message': 'Test email sent successfully!'
    }
    
    return jsonify({
        'message': f'Set test email status for request {request_id}',
        'status': 'success'
    })

# ===================== SSE: Token Status Push =====================
# In-memory subscribers for token status (admin only)
_token_sse_subscribers = defaultdict(list)
# Global token status flag
_token_status = {
    'valid': True,
    'needs_reauth': False,
    'message': '',
    'last_check': None
}
_token_status_lock = threading.Lock()

# Cache tr·∫°ng th√°i c·∫£nh b√°o LICENSE ƒë·ªÉ UI c√≥ th·ªÉ hi·ªÉn th·ªã ngay khi load trang
_license_warning_state = {
    'active': False,
    'payload': None,  # payload gi·ªëng v·ªõi object g·ª≠i qua SSE (status, message, needs_reauth, timestamp)
    'updated_at': None,
}
_license_warning_lock = threading.Lock()

def _sse_token_subscribe(user_id: int) -> Queue:
    q = Queue()
    _token_sse_subscribers[user_id].append(q)
    return q

def _sse_token_unsubscribe(user_id: int, q: Queue) -> None:
    try:
        if q in _token_sse_subscribers.get(user_id, []):
            _token_sse_subscribers[user_id].remove(q)
    except Exception:
        pass

def publish_token_status(status: str, message: str, needs_reauth: bool = False) -> None:
    """Publish token status event to all admin SSE subscribers."""
    global _token_status
    with _token_status_lock:
        _token_status = {
            'valid': status == 'valid',
            'needs_reauth': needs_reauth,
            'message': message,
            'last_check': datetime.now().isoformat()
        }

    # N·∫øu ƒë√¢y l√† c·∫£nh b√°o LICENSE (s·ª≠ d·ª•ng chung c∆° ch·∫ø token_status), l∆∞u l·∫°i v√†o cache ri√™ng
    if '·ª®NG D·ª§NG CH·∫§M C√îNG' in (message or '') or 'LICENSE' in (message or ''):
        global _license_warning_state
        with _license_warning_lock:
            _license_warning_state = {
                'active': True,
                'payload': {
                    'status': status,
                    'message': message,
                    'needs_reauth': needs_reauth,
                    'timestamp': time_module.time()
                },
                'updated_at': datetime.now().isoformat(),
            }
    
    payload = {
        'status': status,
        'message': message,
        'needs_reauth': needs_reauth,
        'timestamp': time_module.time()
    }
    
    # Broadcast to all admin subscribers
    for user_id, queues in list(_token_sse_subscribers.items()):
        for q in list(queues):
            try:
                q.put_nowait(payload)
            except Exception:
                pass
    
    print(f"üîî [Token Status] Published: {status} - {message}")

# Cache token status ƒë·ªÉ tr√°nh ki·ªÉm tra qu√° nhi·ªÅu l·∫ßn
_token_status_cache = None
_token_status_cache_time = 0
_token_status_cache_ttl = 5  # Cache trong 5 gi√¢y

def check_google_token_status(use_cache=True) -> dict:
    """Check current Google API token status without auto-authenticating.
    
    Args:
        use_cache: N·∫øu True, s·ª≠ d·ª•ng cache n·∫øu c√≤n hi·ªáu l·ª±c (m·∫∑c ƒë·ªãnh True)
    """
    global _token_status_cache, _token_status_cache_time
    
    # Ki·ªÉm tra cache
    if use_cache and _token_status_cache and (time_module.time() - _token_status_cache_time) < _token_status_cache_ttl:
        return _token_status_cache
    
    try:
        # Ch·ªâ load token t·ª´ file, kh√¥ng t·∫°o instance ƒë·ªÉ tr√°nh auto-authenticate
        creds = None
        if os.path.exists('token.json'):
            try:
                with open('token.json', 'r') as token:
                    token_data = json.load(token)
                    from google.oauth2.credentials import Credentials
                    # Scope might differ but usually fine to load what is there
                    creds = Credentials.from_authorized_user_info(token_data)
            except Exception as e:
                # JSON load failed - will require re-authentication
                pass
        
        if not creds:
            result = {
                'valid': False,
                'needs_reauth': True,
                'message': 'Kh√¥ng c√≥ credentials. C·∫ßn x√°c th·ª±c l·∫°i v·ªõi Google.',
                'can_approve': False
            }
            _token_status_cache = result
            _token_status_cache_time = time_module.time()
            return result
        
        # Ki·ªÉm tra token c√≥ h·∫øt h·∫°n kh√¥ng (ch·ªâ ki·ªÉm tra expired, kh√¥ng test API ƒë·ªÉ nhanh h∆°n)
        if creds.expired:
            # Try to refresh n·∫øu c√≥ refresh_token (ch·ªâ khi th·ª±c s·ª± c·∫ßn)
            if creds.refresh_token:
                try:
                    # Th·ª≠ refresh token
                    creds.refresh(GoogleRequest())
                    # L∆∞u token m·ªõi
                    with open('token.json', 'w') as token:
                        token.write(creds.to_json())
                    result = {
                        'valid': True,
                        'needs_reauth': False,
                        'message': 'Token ƒë√£ ƒë∆∞·ª£c refresh th√†nh c√¥ng.',
                        'can_approve': True
                    }
                    _token_status_cache = result
                    _token_status_cache_time = time_module.time()
                    return result
                except Exception as e:
                    error_str = str(e).lower()
                    if 'invalid_grant' in error_str:
                        result = {
                            'valid': False,
                            'needs_reauth': True,
                            'message': 'Token kh√¥ng h·ª£p l·ªá (invalid_grant). Vui l√≤ng b·∫•m n√∫t Refresh Token ƒë·ªÉ ·ªßy quy·ªÅn l·∫°i.',
                            'can_approve': False
                        }
                    else:
                        result = {
                            'valid': False,
                            'needs_reauth': True,
                            'message': 'Token h·∫øt h·∫°n v√† kh√¥ng th·ªÉ refresh t·ª± ƒë·ªông. Vui l√≤ng b·∫•m n√∫t Refresh Token ƒë·ªÉ ·ªßy quy·ªÅn l·∫°i.',
                            'can_approve': False
                        }
                    _token_status_cache = result
                    _token_status_cache_time = time_module.time()
                    return result
            else:
                result = {
                    'valid': False,
                    'needs_reauth': True,
                    'message': 'Token h·∫øt h·∫°n v√† kh√¥ng c√≥ refresh_token. Vui l√≤ng b·∫•m n√∫t Refresh Token ƒë·ªÉ ·ªßy quy·ªÅn l·∫°i.',
                    'can_approve': False
                }
                _token_status_cache = result
                _token_status_cache_time = time_module.time()
                return result
        
        # Token c√≤n hi·ªáu l·ª±c (kh√¥ng expired), kh√¥ng c·∫ßn test API ƒë·ªÉ nhanh h∆°n
        # Ch·ªâ ki·ªÉm tra expired l√† ƒë·ªß v√¨ Google token s·∫Ω t·ª± ƒë·ªông ƒë√°nh d·∫•u expired khi h·∫øt h·∫°n
        result = {
            'valid': True,
            'needs_reauth': False,
            'message': 'Token h·ª£p l·ªá.',
            'can_approve': True
        }
        _token_status_cache = result
        _token_status_cache_time = time_module.time()
        return result
        
    except Exception as e:
        result = {
            'valid': False,
            'needs_reauth': True,
            'message': f'L·ªói ki·ªÉm tra token: {str(e)}',
            'can_approve': False
        }
        _token_status_cache = result
        _token_status_cache_time = time_module.time()
        return result

@app.route('/sse/token-status')
def sse_token_status():
    """SSE endpoint for realtime token status (admin only)."""
    if 'user_id' not in session:
        return jsonify({'error': 'Unauthorized'}), 401

    user_id = session['user_id']
    q = _sse_token_subscribe(user_id)
    
    def stream():
        yield 'retry: 5000\n\n'
        try:
            last = time_module.time()
            # Send initial status
            initial_status = check_google_token_status()
            import json as _json
            yield f"event: token_status\ndata: {_json.dumps(initial_status, ensure_ascii=False)}\n\n"
            
            while True:
                try:
                    item = q.get(timeout=1.0)
                    data = _json.dumps(item, ensure_ascii=False)
                    yield f"event: token_status\ndata: {data}\n\n"
                    last = time_module.time()
                except Exception:
                    now = time_module.time()
                    if now - last > 30:
                        yield ": keep-alive\n\n"
                        last = now
        finally:
            _sse_token_unsubscribe(user_id, q)
    
    from flask import Response
    return Response(stream(), mimetype='text/event-stream', headers={'Cache-Control': 'no-cache', 'X-Accel-Buffering': 'no'})


@app.route('/api/license/warning-status')
def api_license_warning_status():
    """
    Tr·∫£ v·ªÅ tr·∫°ng th√°i c·∫£nh b√°o LICENSE g·∫ßn nh·∫•t ƒë·ªÉ UI c√≥ th·ªÉ hi·ªÉn th·ªã ngay khi load trang,
    kh√¥ng ph·∫£i ƒë·ª£i worker ki·ªÉm tra l·∫°i ho·∫∑c SSE push l·∫ßn ti·∫øp theo.
    """
    try:
        with _license_warning_lock:
            state = dict(_license_warning_state)
        return jsonify(state)
    except Exception as e:
        return jsonify({'active': False, 'error': str(e)}), 500

@app.route('/api/license/force-refresh', methods=['POST'])
@login_required
def api_license_force_refresh():
    """
    Force refresh license check ngay l·∫≠p t·ª©c (kh√¥ng ƒë·ª£i interval).
    Ch·ªâ admin m·ªõi c√≥ quy·ªÅn g·ªçi endpoint n√†y.
    """
    if 'user_id' not in session:
        return jsonify({'error': 'Unauthorized'}), 401
    
    user = db.session.get(User, session['user_id'])
    if not user or 'ADMIN' not in user.roles:
        return jsonify({'error': 'Admin only'}), 403
    
    try:
        # Ch·∫°y check license m·ªôt l·∫ßn ngay l·∫≠p t·ª©c
        is_valid, expired, status, message = _check_license_once()
        
        # C·∫≠p nh·∫≠t tr·∫°ng th√°i global
        global _license_is_valid
        _license_is_valid = is_valid and not expired
        
        # N·∫øu license h·ª£p l·ªá, clear c·∫£nh b√°o
        if _license_is_valid:
            with _license_warning_lock:
                _license_warning_state = {
                    'active': False,
                    'payload': None,
                    'updated_at': datetime.now().isoformat(),
                }
        
        return jsonify({
            'success': True,
            'valid': _license_is_valid,
            'expired': expired,
            'status': status,
            'message': message
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/license/update-db-key', methods=['POST'])
@login_required
def api_license_update_db_key():
    """
    C·∫≠p nh·∫≠t ho·∫∑c x√≥a license key trong database (ch·ªâ admin).
    D√πng ƒë·ªÉ ƒë·ªìng b·ªô key trong database v·ªõi environment variable.
    """
    if 'user_id' not in session:
        return jsonify({'error': 'Unauthorized'}), 401
    
    user = db.session.get(User, session['user_id'])
    if not user or 'ADMIN' not in user.roles:
        return jsonify({'error': 'Admin only'}), 403
    
    try:
        activation = get_activation_record()
        
        if request.is_json:
            data = request.get_json()
            action = data.get('action', 'sync')  # 'sync', 'clear', ho·∫∑c 'set'
            new_key = data.get('key', '').strip() if data.get('key') else None
        else:
            action = request.form.get('action', 'sync')
            new_key = request.form.get('key', '').strip() if request.form.get('key') else None
        
        old_key = activation.license_key
        old_activated = activation.is_activated
        
        if action == 'clear':
            # X√≥a key trong database
            activation.license_key = None
            activation.is_activated = False
            activation.activated_at = None
            db.session.commit()
            
            print(f"[LICENSE ADMIN] Admin {user.username} ƒë√£ x√≥a key c≈©: {old_key}")
            
            return jsonify({
                'success': True,
                'message': 'ƒê√£ x√≥a license key trong database',
                'old_key': old_key,
                'new_key': None,
                'is_activated': False
            })
        
        elif action == 'set' and new_key:
            # Set key m·ªõi
            activation.license_key = new_key
            activation.is_activated = True
            activation.activated_at = datetime.utcnow()
            db.session.commit()
            
            print(f"[LICENSE ADMIN] Admin {user.username} ƒë√£ set key m·ªõi: {new_key} (key c≈©: {old_key})")
            
            return jsonify({
                'success': True,
                'message': f'ƒê√£ c·∫≠p nh·∫≠t license key th√†nh: {new_key}',
                'old_key': old_key,
                'new_key': new_key,
                'is_activated': True
            })
        
        elif action == 'sync':
            # ƒê·ªìng b·ªô v·ªõi environment variable
            env_key = (APP_LICENSE_KEY or '').strip()
            
            if env_key:
                activation.license_key = env_key
                activation.is_activated = True
                activation.activated_at = datetime.utcnow()
                db.session.commit()
                
                print(f"[LICENSE ADMIN] Admin {user.username} ƒë√£ ƒë·ªìng b·ªô key t·ª´ env: {env_key} (key c≈©: {old_key})")
                
                return jsonify({
                    'success': True,
                    'message': f'ƒê√£ ƒë·ªìng b·ªô license key t·ª´ environment variable: {env_key}',
                    'old_key': old_key,
                    'new_key': env_key,
                    'is_activated': True,
                    'source': 'environment_variable'
                })
            else:
                return jsonify({
                    'success': False,
                    'error': 'Kh√¥ng c√≥ APP_LICENSE_KEY trong environment variable'
                }), 400
        
        else:
            return jsonify({
                'success': False,
                'error': 'Action kh√¥ng h·ª£p l·ªá. D√πng: sync, clear, ho·∫∑c set (v·ªõi key)'
            }), 400
            
    except Exception as e:
        db.session.rollback()
        print(f"[LICENSE ADMIN] L·ªói: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/token/status')
def api_token_status():
    """API endpoint to check Google API token status."""
    if 'user_id' not in session:
        return jsonify({'error': 'Unauthorized'}), 401
    
    user = db.session.get(User, session['user_id'])
    if not user or 'ADMIN' not in user.roles:
        return jsonify({'error': 'Admin only'}), 403

    force = request.args.get('force', '').lower() in ['1', 'true', 'yes']
    status = check_google_token_status(use_cache=not force)
    return jsonify(status)

@app.route('/api/token/authorize', methods=['POST'])
def api_token_authorize():
    """API endpoint to open Chrome for OAuth authorization."""
    try:
        if 'user_id' not in session:
            return jsonify({'success': False, 'error': 'Unauthorized'}), 401
        
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'success': False, 'error': 'User not found'}), 401
        
        if 'ADMIN' not in user.roles:
            return jsonify({'success': False, 'error': 'Admin only'}), 403
        
        if not GOOGLE_API_AVAILABLE:
            return jsonify({
                'success': False,
                'message': 'Google API libraries kh√¥ng c√≥ s·∫µn. Vui l√≤ng c√†i ƒë·∫∑t c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt.'
            }), 500
        
        if not os.path.exists('credentials.json'):
            return jsonify({
                'success': False,
                'message': 'Kh√¥ng t√¨m th·∫•y file credentials.json. Vui l√≤ng ki·ªÉm tra c·∫•u h√¨nh.'
            }), 500
        
        # ƒê·ªçc credentials ƒë·ªÉ l·∫•y redirect_uri ƒë√£ ƒëƒÉng k√Ω
        import json as json_module
        with open('credentials.json', 'r') as f:
            creds_data = json_module.load(f)
        
        # S·ª≠ d·ª•ng InstalledAppFlow, callback v·ªÅ Flask (kh√¥ng run_local_server ƒë·ªÉ tr√°nh mismatching_state)
        from google_auth_oauthlib.flow import InstalledAppFlow
        from urllib.parse import urlparse

        # D√πng loopback fixed ƒë·ªÉ tr√°nh l·ªói device_id/device_name
        redirect_uri = 'http://127.0.0.1:5000/api/token/callback'

        flow = InstalledAppFlow.from_client_secrets_file(
            'credentials.json',
            ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/spreadsheets']
        )
        flow.redirect_uri = redirect_uri

        authorization_url, state = flow.authorization_url(
            access_type='offline',
            include_granted_scopes='true',
            prompt='consent'
        )

        print(f"[OAuth] Redirect URI set to: {redirect_uri}")
        print(f"[OAuth] Authorization URL created (first 300 chars): {authorization_url[:300]}")
        print(f"[OAuth] State: {state}")

        # L∆∞u flow theo state ƒë·ªÉ callback d√πng l·∫°i
        if not hasattr(app, '_oauth_flow_store'):
            app._oauth_flow_store = {}
        app._oauth_flow_store[state] = flow

        # L∆∞u state v√†o session (kh√¥ng b·∫Øt bu·ªôc nh∆∞ng gi√∫p debug)
        session['oauth_state'] = state
        session['oauth_redirect_uri'] = redirect_uri

        return jsonify({
            'success': True,
            'message': 'ƒê√£ t·∫°o URL ·ªßy quy·ªÅn. Vui l√≤ng m·ªü Chrome ƒë·ªÉ ho√†n t·∫•t qu√° tr√¨nh ·ªßy quy·ªÅn.',
            'auth_url': authorization_url
        })
        
    except Exception as e:
        import traceback
        error_msg = str(e)
        error_trace = traceback.format_exc()
        print(f"Error in api_token_authorize: {error_msg}")
        print(f"Traceback: {error_trace}")
        
        return jsonify({
            'success': False,
            'message': f'L·ªói khi t·∫°o URL ·ªßy quy·ªÅn: {error_msg}'
        }), 500

@app.route('/api/token/callback')
def api_token_callback():
    """Callback endpoint ƒë·ªÉ nh·∫≠n authorization code t·ª´ Google."""
    try:
        # L·∫•y authorization code t·ª´ query string
        code = request.args.get('code')
        state = request.args.get('state')
        error = request.args.get('error')
        
        if error:
            return f'''
            <html>
            <head><title>Authorization Error</title></head>
            <body>
                <h1>L·ªói ·ªßy quy·ªÅn</h1>
                <p>Google ƒë√£ tr·∫£ v·ªÅ l·ªói: {error}</p>
                <p>Vui l√≤ng th·ª≠ l·∫°i.</p>
                <script>
                    setTimeout(function() {{
                        window.close();
                    }}, 3000);
                </script>
            </body>
            </html>
            ''', 400
        
        if not code:
            return '''
            <html>
            <head><title>Authorization Error</title></head>
            <body>
                <h1>L·ªói ·ªßy quy·ªÅn</h1>
                <p>Kh√¥ng nh·∫≠n ƒë∆∞·ª£c authorization code t·ª´ Google.</p>
                <p>Vui l√≤ng th·ª≠ l·∫°i.</p>
                <script>
                    setTimeout(function() {
                        window.close();
                    }, 3000);
                </script>
            </body>
            </html>
            ''', 400
        
        # L·∫•y flow v√† redirect_uri theo state ƒë√£ l∆∞u
        flow = None
        redirect_uri = None

        # ∆Øu ti√™n l·∫•y t·ª´ store (an to√†n h∆°n, tr√°nh mismatching_state)
        if hasattr(app, '_oauth_flow_store') and state in app._oauth_flow_store:
            flow = app._oauth_flow_store.pop(state)
            redirect_uri = getattr(flow, 'redirect_uri', None)
        else:
            # Fallback: ki·ªÉm tra session (c√≥ th·ªÉ m·∫•t n·∫øu reload)
            if 'oauth_state' not in session or session['oauth_state'] != state:
                return '''
                <html>
                <head><title>Authorization Error</title></head>
                <body>
                    <h1>L·ªói b·∫£o m·∫≠t</h1>
                    <p>State kh√¥ng kh·ªõp. Vui l√≤ng th·ª≠ l·∫°i.</p>
                    <script>
                        setTimeout(function() {
                            window.close();
                        }, 3000);
                    </script>
                </body>
                </html>
                ''', 400
            redirect_uri = session.get('oauth_redirect_uri')

        if not flow:
            # N·∫øu kh√¥ng c√≥ flow, t·∫°o m·ªõi v·ªõi redirect_uri ƒë√£ bi·∫øt
            if not redirect_uri:
                redirect_uri = 'http://127.0.0.1:5000/api/token/callback'
            from google_auth_oauthlib.flow import InstalledAppFlow
            flow = InstalledAppFlow.from_client_secrets_file(
                'credentials.json',
                ['https://www.googleapis.com/auth/drive', 'https://www.googleapis.com/auth/spreadsheets']
            )
            flow.redirect_uri = redirect_uri

        # Exchange authorization code ƒë·ªÉ l·∫•y credentials
        flow.fetch_token(code=code)
        creds = flow.credentials
        
        # L∆∞u credentials v√†o file
        with open('token.json', 'w') as token:
            token.write(creds.to_json())
        
        # X√≥a session data
        session.pop('oauth_state', None)
        session.pop('oauth_redirect_uri', None)
        # D·ªçn store
        if hasattr(app, '_oauth_flow_store'):
            app._oauth_flow_store.pop(state, None)
        
        # Publish token status update
        try:
            publish_token_status('valid', 'Token ƒë√£ ƒë∆∞·ª£c ·ªßy quy·ªÅn th√†nh c√¥ng!')
        except Exception:
            pass
        
        return '''
        <html>
        <head><title>Authorization Success</title></head>
        <body>
            <h1>‚úÖ ·ª¶y quy·ªÅn th√†nh c√¥ng!</h1>
            <p>Token ƒë√£ ƒë∆∞·ª£c l∆∞u th√†nh c√¥ng. B·∫°n c√≥ th·ªÉ ƒë√≥ng c·ª≠a s·ªï n√†y.</p>
            <script>
                // Th√¥ng b√°o cho parent window (n·∫øu c√≥)
                if (window.opener) {
                    window.opener.postMessage({type: 'token_authorized', success: true}, '*');
                }
                setTimeout(function() {
                    window.close();
                }, 2000);
            </script>
        </body>
        </html>
        '''
        
    except Exception as e:
        import traceback
        error_msg = str(e)
        error_trace = traceback.format_exc()
        print(f"Error in api_token_callback: {error_msg}")
        print(f"Traceback: {error_trace}")
        
        return f'''
        <html>
        <head><title>Authorization Error</title></head>
        <body>
            <h1>L·ªói x·ª≠ l√Ω ·ªßy quy·ªÅn</h1>
            <p>ƒê√£ x·∫£y ra l·ªói: {error_msg}</p>
            <p>Vui l√≤ng th·ª≠ l·∫°i.</p>
            <script>
                setTimeout(function() {{
                    window.close();
                }}, 5000);
            </script>
        </body>
        </html>
        ''', 500

@app.route('/api/token/refresh', methods=['POST'])
def api_token_refresh():
    """API endpoint to try refreshing token."""
    try:
        if 'user_id' not in session:
            return jsonify({'success': False, 'error': 'Unauthorized'}), 401
        
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'success': False, 'error': 'User not found'}), 401
        
        if 'ADMIN' not in user.roles:
            return jsonify({'success': False, 'error': 'Admin only'}), 403
        
        google_api = GoogleDriveAPI()
        if google_api.refresh_token():
            google_api.save_last_refresh_time()
            publish_token_status('valid', 'Token ƒë√£ ƒë∆∞·ª£c refresh th√†nh c√¥ng!')
            return jsonify({
                'success': True,
                'message': 'Token ƒë√£ ƒë∆∞·ª£c refresh th√†nh c√¥ng!'
            })
        else:
            publish_token_status('expired', 'Kh√¥ng th·ªÉ refresh token. C·∫ßn x√°c th·ª±c l·∫°i.', needs_reauth=True)
            return jsonify({
                'success': False,
                'message': 'Kh√¥ng th·ªÉ refresh token. C·∫ßn ch·∫°y refresh_token.py ƒë·ªÉ x√°c th·ª±c l·∫°i.'
            }), 400
    except Exception as e:
        import traceback
        error_msg = str(e)
        error_trace = traceback.format_exc()
        print(f"Error in api_token_refresh: {error_msg}")
        print(f"Traceback: {error_trace}")
        
        if 'invalid_grant' in error_msg.lower():
            publish_token_status('expired', 'Token kh√¥ng h·ª£p l·ªá (invalid_grant). C·∫ßn x√°c th·ª±c l·∫°i.', needs_reauth=True)
            return jsonify({
                'success': False,
                'message': 'Token kh√¥ng h·ª£p l·ªá (invalid_grant). C·∫ßn ch·∫°y refresh_token.py ƒë·ªÉ x√°c th·ª±c l·∫°i.'
            }), 400
        
        # ƒê·∫£m b·∫£o lu√¥n tr·∫£ v·ªÅ JSON
        return jsonify({
            'success': False,
            'message': f'L·ªói khi refresh token: {error_msg}'
        }), 500

@app.route('/leave-request/<int:request_id>/edit', methods=['GET', 'POST'])
def edit_leave_request(request_id):
    """S·ª≠a ƒë∆°n xin ngh·ªâ ph√©p"""
    if 'user_id' not in session:
        flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
        return redirect(url_for('login'))
    
    user = db.session.get(User, session['user_id'])
    if not user:
        session.clear()
        flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
        return redirect(url_for('login'))
    
    leave_request = LeaveRequest.query.get_or_404(request_id)
    
    # Ch·ªâ ng∆∞·ªùi t·∫°o ƒë∆°n m·ªõi c√≥ th·ªÉ s·ª≠a
    if user.id != leave_request.user_id:
        abort(403)
    
    # Ch·ªâ c√≥ th·ªÉ s·ª≠a khi ƒë∆°n ƒëang ·ªü tr·∫°ng th√°i ch·ªù ph√™ duy·ªát ho·∫∑c b·ªã t·ª´ ch·ªëi
    if leave_request.status not in ['pending', 'rejected']:
        flash('Ch·ªâ c√≥ th·ªÉ s·ª≠a ƒë∆°n khi ƒëang ch·ªù ph√™ duy·ªát ho·∫∑c b·ªã t·ª´ ch·ªëi', 'error')
        return redirect(url_for('view_leave_request', request_id=request_id))
    
    if request.method == 'POST':
        try:
            data = request.form
            
            # C·∫≠p nh·∫≠t th√¥ng tin nh√¢n vi√™n v√† l√Ω do
            leave_request.employee_name = data.get('employee_name')
            leave_request.team = data.get('team')
            leave_request.employee_code = data.get('employee_code')
            leave_request.request_type = data.get('request_type', 'leave')
            leave_request.late_early_type = data.get('late_early_type')
            leave_request.leave_reason = data.get('leave_reason')

            # C·∫≠p nh·∫≠t th·ªùi gian t·ª´ c√°c tr∆∞·ªùng date/time hi·ªán c√≥ tr√™n form
            from_time_str = data.get('leave_from_time') or '00:00'
            to_time_str = data.get('leave_to_time') or '00:00'
            
            clean_from_time = clean_time_format(from_time_str)
            clean_to_time = clean_time_format(to_time_str)
            
            from_time = clean_from_time.split(':')
            to_time = clean_to_time.split(':')
            from_date_parts = (data.get('leave_from_date') or '2024-01-01').split('-')
            to_date_parts = (data.get('leave_to_date') or '2024-01-01').split('-')

            leave_request.leave_from_hour = int(from_time[0])
            leave_request.leave_from_minute = int(from_time[1])
            leave_request.leave_from_year = int(from_date_parts[0])
            leave_request.leave_from_month = int(from_date_parts[1])
            leave_request.leave_from_day = int(from_date_parts[2])

            leave_request.leave_to_hour = int(to_time[0])
            leave_request.leave_to_minute = int(to_time[1])
            leave_request.leave_to_year = int(to_date_parts[0])
            leave_request.leave_to_month = int(to_date_parts[1])
            leave_request.leave_to_day = int(to_date_parts[2])

            # C·∫≠p nh·∫≠t h√¨nh th·ª©c ngh·ªâ
            leave_request.annual_leave_days = float(data.get('annual_leave_days', 0) or 0)
            leave_request.unpaid_leave_days = float(data.get('unpaid_leave_days', 0) or 0)
            leave_request.special_leave_days = float(data.get('special_leave_days', 0) or 0)
            leave_request.japan_holiday_days = float(data.get('japan_holiday_days', 0) or 0)
            leave_request.scope_leave_days = float(data.get('scope_leave_days', 0) or 0)
            leave_request.special_leave_type = data.get('special_leave_type')
            # C·∫≠p nh·∫≠t ca l√†m vi·ªác √°p d·ª•ng khi xin ngh·ªâ (n·∫øu c√≥ ch·ªçn)
            sel_shift = data.get('leave_shift_code')
            if sel_shift in ['1','2','3','4']:
                leave_request.shift_code = sel_shift

            # Chu·∫©n h√≥a b·ªôi s·ªë 0.5 cho s·ªë ng√†y
            def ensure_half_step(x):
                return (int(round((x or 0.0) * 2)) / 2.0)

            # Auto-calculate japan_holiday_days v√† scope_leave_days n·∫øu ng∆∞·ªùi d√πng kh√¥ng nh·∫≠p
            try:
                leave_reason_lower = (leave_request.leave_reason or '').lower()
                user_department_lower = (user.department or '').lower()

                # T√≠nh s·ªë gi·ªù ngh·ªâ t·ª´ th·ªùi gian ƒëƒÉng k√Ω
                from datetime import datetime as dt_calc
                leave_from_dt = dt_calc(
                    leave_request.leave_from_year, leave_request.leave_from_month, leave_request.leave_from_day,
                    leave_request.leave_from_hour, leave_request.leave_from_minute
                )
                leave_to_dt = dt_calc(
                    leave_request.leave_to_year, leave_request.leave_to_month, leave_request.leave_to_day,
                    leave_request.leave_to_hour, leave_request.leave_to_minute
                )
                duration_hours = (leave_to_dt - leave_from_dt).total_seconds() / 3600

                # T√≠nh s·ªë ng√†y t·ª± ƒë·ªông (1 ng√†y = 8 gi·ªù, l√†m tr√≤n 0.5)
                auto_days = ensure_half_step(duration_hours / 8.0)

                # Ki·ªÉm tra ƒëi·ªÅu ki·ªán cho ngh·ªâ l·ªÖ Nh·∫≠t (York)
                is_york_related = (
                    'york' in user_department_lower or
                    'l·ªÖ nh·∫≠t' in leave_reason_lower or
                    'le nhat' in leave_reason_lower or
                    'ngh·ªâ b√π' in leave_reason_lower and 'nh·∫≠t' in leave_reason_lower
                )

                # Ki·ªÉm tra ƒëi·ªÅu ki·ªán cho ngh·ªâ Scope
                is_scope_related = 'scope' in user_department_lower

                # T·ª± ƒë·ªông ƒëi·ªÅn japan_holiday_days n·∫øu li√™n quan ƒë·∫øn York v√† ch∆∞a nh·∫≠p
                if is_york_related and (leave_request.japan_holiday_days or 0) == 0:
                    total_other_days = (
                        (leave_request.annual_leave_days or 0) +
                        (leave_request.unpaid_leave_days or 0) +
                        (leave_request.special_leave_days or 0) +
                        (leave_request.scope_leave_days or 0)
                    )
                    if total_other_days == 0 and auto_days > 0:
                        leave_request.japan_holiday_days = auto_days
                        _safe_print(f"[Leave][Edit][Auto] Auto-filled japan_holiday_days={auto_days}")

                # T·ª± ƒë·ªông ƒëi·ªÅn scope_leave_days n·∫øu li√™n quan ƒë·∫øn Scope v√† ch∆∞a nh·∫≠p
                if is_scope_related and not is_york_related and (leave_request.scope_leave_days or 0) == 0:
                    total_other_days = (
                        (leave_request.annual_leave_days or 0) +
                        (leave_request.unpaid_leave_days or 0) +
                        (leave_request.special_leave_days or 0) +
                        (leave_request.japan_holiday_days or 0)
                    )
                    if total_other_days == 0 and auto_days > 0:
                        leave_request.scope_leave_days = auto_days
                        _safe_print(f"[Leave][Edit][Auto] Auto-filled scope_leave_days={auto_days}")
            except Exception as auto_calc_err:
                _safe_print(f"[Leave][Edit][Auto] Error: {auto_calc_err}")

            leave_request.annual_leave_days = ensure_half_step(leave_request.annual_leave_days)
            leave_request.unpaid_leave_days = ensure_half_step(leave_request.unpaid_leave_days)
            leave_request.special_leave_days = ensure_half_step(leave_request.special_leave_days)
            leave_request.japan_holiday_days = ensure_half_step(leave_request.japan_holiday_days)
            leave_request.scope_leave_days = ensure_half_step(leave_request.scope_leave_days)

            # N·∫øu ƒë∆°n t·ª´ng b·ªã t·ª´ ch·ªëi, khi ng∆∞·ªùi d√πng s·ª≠a v√† g·ª≠i l·∫°i => reset v·ªÅ tr·∫°ng th√°i ch·ªù tr∆∞·ªüng nh√≥m duy·ªát
            if leave_request.status == 'rejected':
                leave_request.status = 'pending'
                leave_request.step = 'leader'
                leave_request.current_approver_id = None
                leave_request.reject_reason = None
                # X√≥a to√†n b·ªô ch·ªØ k√Ω/ph√™ duy·ªát c≈© ƒë·ªÉ quy tr√¨nh duy·ªát l·∫°i t·ª´ ƒë·∫ßu
                leave_request.team_leader_signature = None
                leave_request.team_leader_signer_id = None
                leave_request.team_leader_approved_at = None
                leave_request.manager_signature = None
                leave_request.manager_signer_id = None
                leave_request.manager_approved_at = None
                leave_request.admin_signature = None
                leave_request.admin_signer_id = None
                leave_request.admin_approved_at = None

            # R√†ng bu·ªôc: t·ªïng ng√†y xin ngh·ªâ kh√¥ng v∆∞·ª£t qu√° s·ªë ng√†y trong kho·∫£ng t·ª´ ng√†y-ƒë·∫øn ng√†y
            try:
                from_date_dt = datetime.strptime(data.get('leave_from_date', '2024-01-01'), '%Y-%m-%d')
                to_date_dt = datetime.strptime(data.get('leave_to_date', '2024-01-01'), '%Y-%m-%d')
                from_time_str = data.get('leave_from_time') or '00:00'
                to_time_str = data.get('leave_to_time') or '00:00'
                
                clean_from_time = clean_time_format(from_time_str)
                clean_to_time = clean_time_format(to_time_str)
                
                # Validate: Th·ªùi gian b·∫Øt ƒë·∫ßu ph·∫£i nh·ªè h∆°n th·ªùi gian k·∫øt th√∫c
                start_dt = datetime.combine(from_date_dt.date(), datetime.strptime(clean_from_time, '%H:%M').time())
                end_dt = datetime.combine(to_date_dt.date(), datetime.strptime(clean_to_time, '%H:%M').time())
                
                if start_dt >= end_dt:
                    flash('Th·ªùi gian t·ª´ ng√†y gi·ªù ph·∫£i nh·ªè h∆°n ƒë·∫øn ng√†y gi·ªù', 'error')
                    return redirect(url_for('edit_leave_request', request_id=request_id))
                
                # Validate: Gi·ªù k·∫øt th√∫c kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° gi·ªù ra kh·ªèi ca
                shift_code = data.get('leave_shift_code', '1')
                shift_ranges = {
                    '1': {'start': '07:30', 'end': '16:30'},
                    '2': {'start': '09:00', 'end': '18:00'},
                    '3': {'start': '11:00', 'end': '20:00'},
                    '4': {'start': '08:00', 'end': '17:00'}
                }
                
                if shift_code in shift_ranges:
                    shift_end_time = shift_ranges[shift_code]['end']
                    shift_end_dt = datetime.combine(to_date_dt.date(), datetime.strptime(shift_end_time, '%H:%M').time())
                    
                    # Ch·ªâ ki·ªÉm tra n·∫øu c√πng ng√†y (kh√¥ng ki·ªÉm tra khi ngh·ªâ qua nhi·ªÅu ng√†y)
                    if from_date_dt.date() == to_date_dt.date() and end_dt > shift_end_dt:
                        flash(f'Gi·ªù k·∫øt th√∫c ngh·ªâ ({clean_to_time}) kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° gi·ªù ra kh·ªèi ca ({shift_end_time})', 'error')
                        return redirect(url_for('edit_leave_request', request_id=request_id))
                
                available_units = _compute_leave_units_generic(from_date_dt, clean_from_time, to_date_dt, clean_to_time)
            except Exception:
                available_units = None
            if available_units is not None:
                if (leave_request.annual_leave_days + leave_request.unpaid_leave_days + leave_request.special_leave_days) > available_units + 1e-9:
                    flash('T·ªïng s·ªë ng√†y xin ngh·ªâ v∆∞·ª£t qu√° s·ªë ng√†y c√≥ th·ªÉ xin trong kho·∫£ng th·ªùi gian ƒë√£ ch·ªçn (theo ca l√†m vi·ªác).', 'error')
                    return redirect(url_for('edit_leave_request', request_id=request_id))

            leave_request.substitute_name = data.get('substitute_name')
            leave_request.substitute_employee_id = data.get('substitute_employee_id')
            
            # X·ª≠ l√Ω notes v√† use_lunch_break khi edit
            import json
            notes_from_form = data.get('notes', '').strip()
            use_lunch_break_value = data.get('use_lunch_break')
            
            # L·∫•y use_lunch_break t·ª´ notes c≈© (n·∫øu c√≥)
            existing_use_lunch_break = None
            if leave_request.notes:
                try:
                    existing_notes_data = json.loads(leave_request.notes)
                    if isinstance(existing_notes_data, dict) and 'use_lunch_break' in existing_notes_data:
                        existing_use_lunch_break = existing_notes_data['use_lunch_break']
                except (json.JSONDecodeError, TypeError, ValueError):
                    pass
            
            # N·∫øu form c√≥ g·ª≠i use_lunch_break, d√πng gi√° tr·ªã t·ª´ form
            # N·∫øu kh√¥ng, gi·ªØ l·∫°i gi√° tr·ªã c≈© (n·∫øu c√≥)
            final_use_lunch_break = None
            if use_lunch_break_value in ['true', 'false']:
                final_use_lunch_break = use_lunch_break_value == 'true'
            elif existing_use_lunch_break is not None:
                final_use_lunch_break = existing_use_lunch_break
            
            # L∆∞u notes d∆∞·ªõi d·∫°ng JSON n·∫øu c√≥ use_lunch_break ho·∫∑c c√≥ notes text
            if final_use_lunch_break is not None or notes_from_form:
                notes_data = {}
                if notes_from_form:
                    notes_data['_original_notes'] = notes_from_form
                if final_use_lunch_break is not None:
                    notes_data['use_lunch_break'] = final_use_lunch_break
                leave_request.notes = json.dumps(notes_data, ensure_ascii=False) if notes_data else None
            else:
                leave_request.notes = notes_from_form if notes_from_form else None
            
            # X·ª≠ l√Ω file upload m·ªõi
            if 'attachments' in request.files:
                files = request.files.getlist('attachments')
                new_attachments = []
                
                # L·∫•y danh s√°ch attachments hi·ªán c√≥
                existing_attachments = []
                if leave_request.attachments:
                    try:
                        existing_attachments = json.loads(leave_request.attachments)
                    except (json.JSONDecodeError, TypeError, AttributeError):
                        existing_attachments = []
                
                # X·ª≠ l√Ω c√°c file m·ªõi ƒë∆∞·ª£c upload
                for file in files:
                    if file and file.filename:
                        # T·∫°o t√™n file unique
                        filename = f"{uuid.uuid4()}_{file.filename}"
                        
                        # T·∫°o th∆∞ m·ª•c uploads n·∫øu ch∆∞a c√≥
                        upload_dir = os.path.join(app.root_path, 'uploads', 'leave_requests')
                        os.makedirs(upload_dir, exist_ok=True)
                        
                        # L∆∞u file
                        file_path = os.path.join(upload_dir, filename)
                        file.save(file_path)
                        
                        new_attachments.append({
                            'original_name': file.filename,
                            'saved_name': filename,
                            'size': file.content_length or 0
                        })
                
                # K·∫øt h·ª£p attachments c≈© v√† m·ªõi
                all_attachments = existing_attachments + new_attachments
                leave_request.attachments = json.dumps(all_attachments) if all_attachments else None

            # C·∫≠p nh·∫≠t th√¥ng tin ng√†y lo·∫°i tr·ª´ (cu·ªëi tu·∫ßn, l·ªÖ Vi·ªát, l·ªÖ Nh·∫≠t)
            leave_request.excluded_days_json = data.get('excluded_days_json') if data.get('excluded_days_json') else None
            leave_request.total_calendar_days = int(data.get('total_calendar_days', 0) or 0)
            leave_request.total_excluded_days = int(data.get('total_excluded_days', 0) or 0)
            leave_request.total_working_days = float(data.get('total_working_days', 0) or 0)
            leave_request.weekend_count = int(data.get('weekend_count', 0) or 0)
            leave_request.vietnamese_holiday_count = int(data.get('vietnamese_holiday_count', 0) or 0)
            leave_request.japanese_holiday_count = int(data.get('japanese_holiday_count', 0) or 0)

            db.session.commit()
            
            # Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ mu·ªën g·ª≠i email hay kh√¥ng
            email_consent = data.get('email_consent', 'no').lower()
            send_email = email_consent == 'yes'

            if send_email:
                try:
                    print(f"[Mail] Attempting to send update email for leave_request #{leave_request.id} by user #{user.id} ({user.name})")
                    send_leave_request_email_async(leave_request, user, action='update')
                    # Process any pending DB updates from async threads
                    from utils.email_utils import process_db_updates
                    process_db_updates()
                    # L∆∞u tr·∫°ng th√°i email v√†o session cho t·∫•t c·∫£ vai tr√≤
                    session['email_status'] = {
                        'request_id': leave_request.id,
                        'status': 'sending',
                        'message': 'ƒêang g·ª≠i email th√¥ng b√°o...'
                    }
                    # Ch·ªâ th√¥ng b√°o v·ªÅ c·∫≠p nh·∫≠t; ti·∫øn tr√¨nh email s·∫Ω do toast hi·ªÉn th·ªã
                    # flash('ƒê√£ c·∫≠p nh·∫≠t ƒë∆°n th√†nh c√¥ng! Email th√¥ng b√°o ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn ph√≤ng nh√¢n s·ª±.', 'success')
                except Exception as e:
                    print(f"[Mail] Error scheduling leave update email: {e}")
                    # L∆∞u tr·∫°ng th√°i email v√†o session cho t·∫•t c·∫£ vai tr√≤
                    session['email_status'] = {
                        'request_id': leave_request.id,
                        'status': 'error',
                        'message': f'L·ªói khi g·ª≠i email: {str(e)}'
                    }
                    flash('ƒê∆°n ƒë√£ c·∫≠p nh·∫≠t th√†nh c√¥ng, nh∆∞ng c√≥ l·ªói khi g·ª≠i email th√¥ng b√°o.', 'warning')
            else:
                # Kh√¥ng g·ª≠i email
                print(f"[Mail] User chose not to send email for leave_request update #{leave_request.id}")
                session['email_status'] = {
                    'request_id': leave_request.id,
                    'status': 'skipped',
                    'message': 'Ng∆∞·ªùi d√πng ƒë√£ ch·ªçn kh√¥ng g·ª≠i email th√¥ng b√°o'
                }
                # flash('ƒê√£ c·∫≠p nh·∫≠t ƒë∆°n th√†nh c√¥ng! (Kh√¥ng g·ª≠i email th√¥ng b√°o)', 'success')
            return redirect(url_for('leave_requests_list', status='pending'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'L·ªói khi c·∫≠p nh·∫≠t ƒë∆°n xin ngh·ªâ ph√©p: {str(e)}', 'error')
    
    # X·ª≠ l√Ω GET request - hi·ªÉn th·ªã form s·ª≠a
    work_shift = '08:00 - 17:00'
    current_role = session.get('current_role', user.roles.split(',')[0])
    
    # Parse existing attachments for template
    existing_attachments_list = []
    if leave_request.attachments:
        try:
            existing_attachments_list = json.loads(leave_request.attachments)
        except (json.JSONDecodeError, TypeError, AttributeError):
            existing_attachments_list = []
    
    return render_template('leave_request_form.html', 
                         leave_request=leave_request, 
                         is_edit=True, 
                         user=user, 
                         current_role=current_role, 
                         work_shift=work_shift,
                         existing_attachments_list=existing_attachments_list)


def _format_leave_days_summary_for_sheet(leave_request):
    """T·∫°o chu·ªói m√¥ t·∫£ s·ªë ng√†y ngh·ªâ ƒë·ªÉ ghi v√†o Google Sheet."""
    def _fmt(value):
        if value is None:
            return None
        try:
            value = float(value)
        except (TypeError, ValueError):
            return None
        if value <= 0:
            return None
        if value.is_integer():
            return str(int(value))
        return f"{value:.1f}".rstrip('0').rstrip('.')
    
    parts = []
    
    annual_text = _fmt(leave_request.annual_leave_days)
    if annual_text:
        parts.append(f"Ph√©p nƒÉm: {annual_text} ng√†y")
    
    unpaid_text = _fmt(leave_request.unpaid_leave_days)
    if unpaid_text:
        parts.append(f"Ngh·ªâ kh√¥ng l∆∞∆°ng: {unpaid_text} ng√†y")
    
    special_text = _fmt(leave_request.special_leave_days)
    if special_text:
        special_label = "Ngh·ªâ ƒë·∫∑c bi·ªát"
        if leave_request.special_leave_type:
            special_label += f" ({leave_request.special_leave_type})"
        parts.append(f"{special_label}: {special_text} ng√†y")
    
    if not parts:
        return "0 ng√†y"
    
    return " | ".join(parts)


def _generate_leave_date_range(leave_request):
    """Tr·∫£ v·ªÅ danh s√°ch ng√†y (date) n·∫±m trong kho·∫£ng ngh·ªâ ph√©p."""
    try:
        start_date = leave_request.get_leave_from_datetime().date()
        end_date = leave_request.get_leave_to_datetime().date()
    except Exception:
        return []
    
    dates = []
    current = start_date
    while current <= end_date:
        dates.append(current)
        current += timedelta(days=1)
    return dates


def schedule_leave_sheet_updates(leave_request, approver=None):
    """ƒê∆∞a th√¥ng tin s·ªë ng√†y ngh·ªâ l√™n Google Sheet (c·ªôt P) sau khi Admin ph√™ duy·ªát."""
    import sys
    from datetime import datetime as dt

    _safe_print(f"üîÑ [SCHEDULE_LEAVE_SHEET] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω ƒë∆°n #{leave_request.id if leave_request else 'None'}")

    try:
        # Kh√¥ng c√≥ ƒë∆°n ngh·ªâ th√¨ d·ª´ng
        if not leave_request:
            _safe_print(f"‚ö†Ô∏è [SCHEDULE_LEAVE_SHEET] Kh√¥ng c√≥ ƒë∆°n ngh·ªâ ph√©p")
            return

        # X·ª≠ l√Ω ri√™ng cho ƒë∆°n ngh·ªâ 30 ph√∫t: ch·ªâ ƒë·∫©y memo v√†o c·ªôt P
        if leave_request.request_type == '30min_break':
            try:
                from_hour = getattr(leave_request, 'leave_from_hour', 0) or 0
                from_minute = getattr(leave_request, 'leave_from_minute', 0) or 0
                to_hour = getattr(leave_request, 'leave_to_hour', 0) or 0
                to_minute = getattr(leave_request, 'leave_to_minute', 0) or 0
                from_time_str = f"{from_hour:02d}:{from_minute:02d}"
                to_time_str = f"{to_hour:02d}:{to_minute:02d}"
            except Exception:
                from_time_str = ""
                to_time_str = ""

            try:
                # L·∫•y nh√¢n vi√™n & team
                employee = leave_request.user
                employee_team = employee.department or leave_request.team or "Unknown"
                employee_id = employee.employee_id
            except Exception:
                employee = None
                employee_team = leave_request.team or "Unknown"
                employee_id = getattr(leave_request, 'employee_code', 'Unknown')

            from_datetime = leave_request.get_leave_from_datetime()
            leave_date = from_datetime.date() if from_datetime else datetime.utcnow().date()

            approved_by = approver.name if approver else "Admin"
            approved_at = (leave_request.admin_approved_at or datetime.utcnow()).strftime('%Y-%m-%d %H:%M:%S')

            summary_text = f"Ngh·ªâ 30 ph√∫t: {from_time_str} - {to_time_str}".strip()

            attendance_data = {
                'date': leave_date.isoformat(),
                'user_name': leave_request.employee_name,
                'approved_by': approved_by,
                'approved_at': approved_at,
                'leave_summary': summary_text,
                'memo_only': True
            }

            try:
                _safe_print(f"üìå [SCHEDULE_LEAVE_SHEET] ƒê∆°n ngh·ªâ 30 ph√∫t -> ch·ªâ c·∫≠p nh·∫≠t c·ªôt P")
                _safe_print(f"   Ng√†y: {leave_date.isoformat()}")
                _safe_print(f"   Memo: {summary_text}")
            except Exception:
                pass

            try:
                update_google_sheet_background_safe(
                    attendance_id=f"break30-{leave_request.id}",
                    employee_team=employee_team,
                    employee_id=employee_id,
                    attendance_data=attendance_data
                )
            except Exception as memo_err:
                try:
                    _safe_print(f"‚ùå [SCHEDULE_LEAVE_SHEET] L·ªói khi c·∫≠p nh·∫≠t memo ngh·ªâ 30 ph√∫t: {memo_err}")
                except Exception:
                    pass

        # X·ª≠ l√Ω ri√™ng cho ƒë∆°n ƒëi tr·ªÖ/v·ªÅ s·ªõm: c·∫≠p nh·∫≠t c·ªôt P v√† tr·ª´ gi·ªù t·ª´ c·ªôt G ho·∫∑c K
        if leave_request.request_type == 'late_early':
            try:
                from_hour = getattr(leave_request, 'leave_from_hour', 0) or 0
                from_minute = getattr(leave_request, 'leave_from_minute', 0) or 0
                to_hour = getattr(leave_request, 'leave_to_hour', 0) or 0
                to_minute = getattr(leave_request, 'leave_to_minute', 0) or 0
                from_time_str = f"{from_hour:02d}:{from_minute:02d}"
                to_time_str = f"{to_hour:02d}:{to_minute:02d}"
                
                # T√≠nh s·ªë ph√∫t ƒëi tr·ªÖ/v·ªÅ s·ªõm
                from_total_minutes = from_hour * 60 + from_minute
                to_total_minutes = to_hour * 60 + to_minute
                late_early_minutes = abs(to_total_minutes - from_total_minutes)
            except Exception:
                from_time_str = ""
                to_time_str = ""
                late_early_minutes = 0

            try:
                # L·∫•y nh√¢n vi√™n & team
                employee = leave_request.user
                employee_team = employee.department or leave_request.team or "Unknown"
                employee_id = employee.employee_id
            except Exception:
                employee = None
                employee_team = leave_request.team or "Unknown"
                employee_id = getattr(leave_request, 'employee_code', 'Unknown')

            from_datetime = leave_request.get_leave_from_datetime()
            leave_date = from_datetime.date() if from_datetime else datetime.utcnow().date()
            leave_date_str = leave_date.strftime('%d/%m/%Y')

            approved_by = approver.name if approver else "Admin"
            approved_at = (leave_request.admin_approved_at or datetime.utcnow()).strftime('%Y-%m-%d %H:%M:%S')

            # X√°c ƒë·ªãnh lo·∫°i ƒëi tr·ªÖ/v·ªÅ s·ªõm
            late_early_type = getattr(leave_request, 'late_early_type', None) or 'late'
            
            # T·∫°o memo text cho c·ªôt P (ng·∫Øn g·ªçn)
            if late_early_type == 'late':
                summary_text = f"ƒêi tr·ªÖ t·ª´ {from_time_str}-{to_time_str}"
            else:  # early
                summary_text = f"V·ªÅ s·ªõm {from_time_str}-{to_time_str}"

            attendance_data = {
                'date': leave_date.isoformat(),
                'user_name': leave_request.employee_name,
                'approved_by': approved_by,
                'approved_at': approved_at,
                'leave_summary': summary_text,
                'late_early_type': late_early_type,
                'late_early_minutes': late_early_minutes,
                'memo_only': True  # memo_only = True ƒë·ªÉ kh√¥ng ƒë·ªông v√†o c√°c c·ªôt N, O, E, M. Logic tr·ª´ gi·ªù G/K ch·∫°y ri√™ng.
            }

            try:
                _safe_print(f"üìå [SCHEDULE_LEAVE_SHEET] ƒê∆°n ƒëi tr·ªÖ/v·ªÅ s·ªõm -> c·∫≠p nh·∫≠t c·ªôt P v√† tr·ª´ gi·ªù")
                _safe_print(f"   Ng√†y: {leave_date.isoformat()}")
                _safe_print(f"   Lo·∫°i: {late_early_type}")
                _safe_print(f"   Memo: {summary_text}")
                _safe_print(f"   S·ªë ph√∫t: {late_early_minutes}")
            except Exception:
                pass

            try:
                update_google_sheet_background_safe(
                    attendance_id=f"late_early-{leave_request.id}",
                    employee_team=employee_team,
                    employee_id=employee_id,
                    attendance_data=attendance_data
                )
            except Exception as late_early_err:
                try:
                    _safe_print(f"‚ùå [SCHEDULE_LEAVE_SHEET] L·ªói khi c·∫≠p nh·∫≠t ƒë∆°n ƒëi tr·ªÖ/v·ªÅ s·ªõm: {late_early_err}")
                except Exception:
                    pass

        # C√°c lo·∫°i kh√°c ngo√†i 'leave', '30min_break' v√† 'late_early' th√¨ kh√¥ng x·ª≠ l√Ω
        if leave_request.request_type != 'leave':
            _safe_print(f"‚ö†Ô∏è [SCHEDULE_LEAVE_SHEET] Kh√¥ng ph·∫£i ƒë∆°n ngh·ªâ ph√©p (type: {leave_request.request_type})")
            return

        # D√πng c√πng logic ph√¢n b·ªï ng√†y nh∆∞ Excel export ƒë·ªÉ m·ªói ng√†y c√≥ ƒë√∫ng s·ªë ng√†y ngh·ªâ
        try:
            _safe_print(f"üìä [SCHEDULE_LEAVE_SHEET] ƒêang ph√¢n b·ªï ng√†y ngh·ªâ...")

            from utils.excel_leave_processor import process_leave_requests_for_excel
            daily_leaves = process_leave_requests_for_excel([leave_request])

            _safe_print(f"‚úÖ [SCHEDULE_LEAVE_SHEET] Ph√¢n b·ªï th√†nh c√¥ng: {len(daily_leaves)} ng√†y")
        except Exception as alloc_err:
            import traceback
            _safe_print(f"‚ùå [SCHEDULE_LEAVE_SHEET] L·ªói ph√¢n b·ªï ng√†y ngh·ªâ: {alloc_err}")
            _safe_print(traceback.format_exc())
            daily_leaves = []

        if not daily_leaves:
            _safe_print(f"‚ö†Ô∏è [SCHEDULE_LEAVE_SHEET] Kh√¥ng c√≥ d·ªØ li·ªáu daily_leaves cho ƒë∆°n #{leave_request.id}")
            return

        employee = leave_request.user or db.session.get(User, leave_request.user_id)

        if not employee or not employee.employee_id:
            _safe_print(f"‚ö†Ô∏è [SCHEDULE_LEAVE_SHEET] Thi·∫øu th√¥ng tin nh√¢n vi√™n cho ƒë∆°n #{leave_request.id}")
            return

        employee_team = employee.department or leave_request.team or "Unknown"
        approved_by = approver.name if approver else "Admin"
        approved_at = (leave_request.admin_approved_at or datetime.utcnow()).strftime('%Y-%m-%d %H:%M:%S')
        attendance_prefix = f"leave-{leave_request.id}"
        employee_id = employee.employee_id

        def _worker():
            import sys
            _safe_print(f"üöÄ [LEAVE_SHEET_UPDATE] X·ª≠ l√Ω {len(daily_leaves)} ng√†y ngh·ªâ cho ƒë∆°n #{leave_request.id}")
            
            # T·∫°o thread ri√™ng cho m·ªói ng√†y ƒë·ªÉ ch·∫°y song song (parallel)
            threads = []
            for idx, day_leave in enumerate(daily_leaves, start=1):
                def _process_day(day_idx, day_data):
                    """X·ª≠ l√Ω m·ªôt ng√†y trong thread ri√™ng"""
                    leave_date = day_data['date']
                    leave_type = day_data.get('leave_type', {}) or {}

                    # L·∫•y s·ªë ng√†y cho t·ª´ng ng√†y (c√≥ th·ªÉ l·∫ª 0.5, 1.5, ...)
                    raw_days = day_data.get('fractional_days', leave_type.get('days', 1.0))
                    try:
                        day_value = float(raw_days)
                    except (TypeError, ValueError):
                        day_value = 0.0

                    # Format s·ªë ng√†y: 1, 1.5, 2.5...
                    if day_value <= 0:
                        day_text = "0"
                    elif abs(day_value - round(day_value)) < 1e-9:
                        day_text = str(int(round(day_value)))
                    else:
                        day_text = f"{day_value:.1f}".rstrip('0').rstrip('.')

                    # Nh√£n lo·∫°i ngh·ªâ cho ng√†y n√†y
                    type_name = str(leave_type.get('name') or '').strip() or "Ngh·ªâ"
                    special_type = leave_type.get('special_type')
                    if special_type:
                        type_name += f" ({special_type})"

                    summary_text = f"{type_name}: {day_text} ng√†y"
                    full_leave_day = abs(day_value - 1.0) < 1e-9
                    
                    # L·∫•y use_lunch_break t·ª´ notes (l∆∞u d∆∞·ªõi d·∫°ng JSON)
                    use_lunch_break = None
                    if leave_request.notes:
                        try:
                            import json
                            notes_data = json.loads(leave_request.notes)
                            if isinstance(notes_data, dict) and 'use_lunch_break' in notes_data:
                                use_lunch_break = bool(notes_data['use_lunch_break'])
                        except Exception:
                            pass

                    attendance_data = {
                        'date': leave_date.isoformat(),
                        'user_name': leave_request.employee_name,
                        'approved_by': approved_by,
                        'approved_at': approved_at,
                        'leave_summary': summary_text,
                        'full_leave_day': full_leave_day,
                        'use_lunch_break': use_lunch_break,
                        'leave_fraction_days': day_value,
                        # === TH√äM CHO LOGIC 0.5 NG√ÄY ===
                        # L·∫•y leave_start_time t·ª´ day_data ho·∫∑c fallback v·ªÅ leave_request
                        'leave_start_time': day_data.get('start_time').strftime('%H:%M') if day_data.get('start_time') else leave_request.get_leave_from_datetime().strftime('%H:%M'),
                        'leave_end_time': day_data.get('end_time').strftime('%H:%M') if day_data.get('end_time') else leave_request.get_leave_to_datetime().strftime('%H:%M'),
                        # L·∫•y shift_code: ∆∞u ti√™n t·ª´ leave_request, fallback v·ªÅ employee, fallback v·ªÅ '1'
                        'shift_code': leave_request.shift_code or getattr(employee, 'shift_code', None) or '1'
                    }

                    # G·ªçi h√†m c·∫≠p nh·∫≠t Google Sheet
                    try:
                        update_google_sheet_background_safe(
                            attendance_id=f"{attendance_prefix}-{day_idx}",
                            employee_team=employee_team,
                            employee_id=employee_id,
                            attendance_data=attendance_data
                        )
                        _safe_print(f"‚úÖ [LEAVE_SHEET_UPDATE] Ho√†n th√†nh ng√†y {day_idx}/{len(daily_leaves)}")
                    except Exception as func_err:
                        _safe_print(f"‚ùå [LEAVE_SHEET_UPDATE] L·ªói ng√†y {day_idx}: {func_err}")
                
                # T·∫°o thread cho ng√†y n√†y v√† ch·∫°y ngay l·∫≠p t·ª©c
                thread = threading.Thread(
                    target=_process_day,
                    args=(idx, day_leave),
                    daemon=True
                )
                thread.start()
                threads.append(thread)
            
            # Kh√¥ng ch·ªù c√°c thread - ƒë·ªÉ ch√∫ng ch·∫°y song song trong background
            _safe_print(f"‚úÖ [LEAVE_SHEET_UPDATE] ƒê√£ kh·ªüi ƒë·ªông {len(threads)} thread song song")

        threading.Thread(target=_worker, daemon=True).start()
        _safe_print(f"‚úÖ [SCHEDULE_LEAVE_SHEET] ƒê√£ kh·ªüi ƒë·ªông background thread")
            
    except Exception as sheet_error:
        import traceback
        _safe_print(f"‚ùå [SCHEDULE_LEAVE_SHEET] L·ªói: {sheet_error}")
        _safe_print(traceback.format_exc())
            
        # --- ROLLBACK LOGIC ---
        # N·∫øu c√≥ l·ªói nghi√™m tr·ªçng khi·∫øn kh√¥ng th·ªÉ ch·∫°y worker, c·∫ßn rollback tr·∫°ng th√°i v·ªÅ pending_admin
        if leave_request:
            try:
                _safe_print(f"üîÑ [ROLLBACK] ƒêang ho√†n t√°c tr·∫°ng th√°i ƒë∆°n #{leave_request.id} v·ªÅ 'pending_admin'...")

                # C·∫ßn t·∫°o app context m·ªõi ƒë·ªÉ rollback v√¨ ƒëang ·ªü thread kh√°c/context c≈© c√≥ th·ªÉ ƒë√£ ƒë√≥ng
                with app.app_context():
                    lr_to_rollback = db.session.get(LeaveRequest, leave_request.id)
                    if lr_to_rollback and lr_to_rollback.status == 'approved':
                        lr_to_rollback.status = 'pending_admin'
                        lr_to_rollback.admin_approved_at = None
                        lr_to_rollback.admin_signer_id = None

                        # L∆∞u l·ªói v√†o c·ªôt google_sheet_sync_error
                        lr_to_rollback.google_sheet_synced = False
                        lr_to_rollback.google_sheet_sync_error = str(sheet_error)

                        # Th√™m ghi ch√∫ l·ªói
                        current_notes = lr_to_rollback.notes or ""
                        error_note = f"\n[System Error {dt.now().strftime('%d/%m %H:%M')}] Google Sheet Sync Failed: {sheet_error}"
                        lr_to_rollback.notes = current_notes + error_note

                        db.session.commit()
                        _safe_print(f"‚úÖ [ROLLBACK] Ho√†n t·∫•t. Admin c·∫ßn duy·ªát l·∫°i ƒë∆°n n·∫£y.")
            except Exception as rollback_err:
                _safe_print(f"‚ùå [ROLLBACK_FAILED] L·ªói khi rollback: {rollback_err}")


def trigger_schedule_leave_sheet_updates_async(leave_request_id, approver_id=None):
    """Ch·∫°y schedule_leave_sheet_updates trong background ƒë·ªÉ tr√°nh block request."""
    def _runner():
        sync_success = False
        sync_error_msg = None

        try:
            _safe_print(f"üßµ [LEAVE_SHEET_ASYNC] Thread b·∫Øt ƒë·∫ßu cho ƒë∆°n #{leave_request_id}")
            with app.app_context():
                lr = db.session.get(LeaveRequest, leave_request_id)
                approver = db.session.get(User, approver_id) if approver_id else None
                if not lr:
                    _safe_print(f"‚ö†Ô∏è [LEAVE_SHEET_ASYNC] Kh√¥ng t√¨m th·∫•y ƒë∆°n #{leave_request_id}")
                    return

                # TƒÉng s·ªë l·∫ßn th·ª≠ sync
                lr.google_sheet_sync_attempts = (lr.google_sheet_sync_attempts or 0) + 1
                db.session.commit()

                # Th·ª±c hi·ªán sync
                schedule_leave_sheet_updates(lr, approver)

                # N·∫øu kh√¥ng c√≥ exception, coi nh∆∞ th√†nh c√¥ng
                sync_success = True

        except Exception as async_err:
            sync_error_msg = str(async_err)
            db.session.rollback()  # Rollback transaction on error
            try:
                import traceback
                _safe_print(f"‚ùå [LEAVE_SHEET_ASYNC] L·ªói khi ch·∫°y background cho ƒë∆°n #{leave_request_id}: {async_err}")
                _safe_print(traceback.format_exc())
            except Exception:
                pass
        finally:
            # C·∫≠p nh·∫≠t tr·∫°ng th√°i sync v√†o database
            try:
                with app.app_context():
                    lr = db.session.get(LeaveRequest, leave_request_id)
                    if lr:
                        from datetime import datetime as dt
                        if sync_success:
                            lr.google_sheet_synced = True
                            lr.google_sheet_sync_at = dt.now()
                            lr.google_sheet_sync_error = None
                            _safe_print(f"‚úÖ [LEAVE_SHEET_ASYNC] ƒê√£ ƒë√°nh d·∫•u ƒë∆°n #{leave_request_id} l√† ƒë√£ sync th√†nh c√¥ng")
                        else:
                            lr.google_sheet_synced = False
                            lr.google_sheet_sync_error = sync_error_msg or "Unknown error"
                            _safe_print(f"‚ùå [LEAVE_SHEET_ASYNC] ƒê√£ ƒë√°nh d·∫•u ƒë∆°n #{leave_request_id} l√† sync th·∫•t b·∫°i: {sync_error_msg}")
                        db.session.commit()
            except Exception as db_err:
                db.session.rollback()  # Rollback transaction on error
                _safe_print(f"‚ö†Ô∏è [LEAVE_SHEET_ASYNC] L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i sync: {db_err}")

            try:
                _safe_print(f"üßµ [LEAVE_SHEET_ASYNC] Thread k·∫øt th√∫c cho ƒë∆°n #{leave_request_id}")
            except Exception:
                pass

    thread = threading.Thread(target=_runner, name=f"leave-sheet-{leave_request_id}", daemon=True)
    thread.start()


@app.route('/leave-request/<int:request_id>/approve', methods=['POST'])
def approve_leave_request(request_id):
    """Ph√™ duy·ªát ho·∫∑c t·ª´ ch·ªëi ƒë∆°n xin ngh·ªâ ph√©p - Logic ƒëa c·∫•p ƒë·ªìng b·ªô v·ªõi ch·∫•m c√¥ng"""
    import sys
    from datetime import datetime as dt

    _safe_print(f"üöÄ [LEAVE_APPROVE] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω ƒë∆°n #{request_id}")
    
    if 'user_id' not in session:
        return jsonify({'error': 'Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y'}), 401
    
    user = db.session.get(User, session['user_id'])
    if not user:
        session.clear()
        return jsonify({'error': 'Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!'}), 401
    
    user_roles = user.get_roles_list()
    current_role = session.get('current_role', user_roles[0] if user_roles else 'EMPLOYEE')

    _safe_print(f"   üë§ User: {user.name}, Role: {current_role}")
    
    if current_role not in ['ADMIN', 'MANAGER', 'TEAM_LEADER']:
        _safe_print(f"‚ùå [LEAVE_APPROVE] User kh√¥ng c√≥ quy·ªÅn ph√™ duy·ªát (role: {current_role})")
        abort(403)
    
    # Ki·ªÉm tra quy·ªÅn ph√™ duy·ªát
    has_permission, error_message = check_leave_approval_permission(user.id, request_id, current_role)
    if not has_permission:
        _safe_print(f"‚ùå [LEAVE_APPROVE] Kh√¥ng c√≥ quy·ªÅn ph√™ duy·ªát: {error_message}")
        return jsonify({'error': error_message}), 403

    leave_request = LeaveRequest.query.get(request_id)
    if not leave_request:
        _safe_print(f"‚ùå [LEAVE_APPROVE] Leave request {request_id} not found")
        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y ƒë∆°n ngh·ªâ ph√©p'}), 404

    action = request.form.get('action')
    reason = request.form.get('rejection_reason', '')
    csrf_token = request.form.get('csrf_token')

    _safe_print(f"   üìù Action: {action}, Status: {leave_request.status}")
    
    if not action:
        _safe_print(f"‚ùå [LEAVE_APPROVE] No action provided for request {request_id}")
        return jsonify({'error': 'Kh√¥ng c√≥ h√†nh ƒë·ªông ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh'}), 400

    try:
        if action == 'approve':
            # Logic ph√™ duy·ªát ƒëa c·∫•p ƒë·ªìng b·ªô v·ªõi ch·∫•m c√¥ng
            if current_role == 'TEAM_LEADER':
                if leave_request.status != 'pending':
                    return jsonify({'error': 'ƒê∆°n ngh·ªâ ph√©p kh√¥ng ·ªü tr·∫°ng th√°i ch·ªù duy·ªát'}), 400
                
                # Chuy·ªÉn l√™n Manager - t√¨m user c√≥ role MANAGER (qu·∫£n l√Ω t·∫•t c·∫£ ph√≤ng ban)
                manager = User.query.filter(
                    User.roles.like('%MANAGER%'),
                    User.is_deleted == False
                ).first()
                
                if manager:
                    # C√≥ MANAGER - chuy·ªÉn l√™n MANAGER
                    leave_request.status = 'pending_manager'
                    leave_request.step = 'manager'
                    leave_request.current_approver_id = manager.id
                    leave_request.team_leader_signer_id = user.id
                    leave_request.team_leader_approved_at = datetime.now()
                    message = 'ƒê√£ chuy·ªÉn l√™n Qu·∫£n l√Ω ph√™ duy·ªát'
                else:
                    # Kh√¥ng c√≥ MANAGER - chuy·ªÉn l√™n ADMIN
                    admin = User.query.filter(
                        User.roles.like('%ADMIN%'),
                        User.is_deleted == False
                    ).first()
                    if admin:
                        leave_request.status = 'pending_admin'
                        leave_request.step = 'admin'
                        leave_request.current_approver_id = admin.id
                        leave_request.team_leader_signer_id = user.id
                        leave_request.team_leader_approved_at = datetime.now()
                        message = 'ƒê√£ chuy·ªÉn l√™n Admin ph√™ duy·ªát (kh√¥ng c√≥ Manager)'
                    else:
                        # Kh√¥ng c√≥ c·∫£ MANAGER v√† ADMIN - b√°o l·ªói, kh√¥ng cho ph√™ duy·ªát tr·ª±c ti·∫øp
                        return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y Qu·∫£n l√Ω ho·∫∑c Qu·∫£n tr·ªã vi√™n ƒë·ªÉ ph√™ duy·ªát. Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã h·ªá th·ªëng.'}), 400
                
            elif current_role == 'MANAGER':
                if leave_request.status != 'pending_manager':
                    return jsonify({'error': 'ƒê∆°n ngh·ªâ ph√©p ch∆∞a ƒë∆∞·ª£c Tr∆∞·ªüng nh√≥m ph√™ duy·ªát'}), 400
                
                # Chuy·ªÉn l√™n Admin - t√¨m user c√≥ role ADMIN
                admin = User.query.filter(
                    User.roles.like('%ADMIN%'),
                    User.is_deleted == False
                ).first()
                if not admin:
                    return jsonify({'error': 'Kh√¥ng t√¨m th·∫•y qu·∫£n tr·ªã vi√™n'}), 400
                
                leave_request.status = 'pending_admin'
                leave_request.step = 'admin'
                leave_request.current_approver_id = admin.id
                leave_request.manager_signer_id = user.id
                leave_request.manager_approved_at = datetime.now()
                message = 'ƒê√£ ph√™ duy·ªát th√†nh c√¥ng'
                
            elif current_role == 'ADMIN':
                if leave_request.status != 'pending_admin':
                    return jsonify({'error': 'ƒê∆°n ngh·ªâ ph√©p ch∆∞a ƒë∆∞·ª£c Qu·∫£n l√Ω ph√™ duy·ªát'}), 400
                
                # Check Google API token tr∆∞·ªõc khi ADMIN approve
                token_status = check_google_token_status()
                if not token_status.get('can_approve', False):
                    # Publish notification to all admins
                    publish_token_status('expired', token_status.get('message', 'Token h·∫øt h·∫°n'), needs_reauth=True)
                    return jsonify({
                        'error': f"‚ö†Ô∏è Token Google API h·∫øt h·∫°n. {token_status.get('message', 'Vui l√≤ng refresh token tr∆∞·ªõc khi ph√™ duy·ªát.')}",
                        'error_code': 'token_expired',
                        'needs_reauth': True
                    }), 503

                # Validation th√¥ng tin nh√¢n vi√™n tr∆∞·ªõc khi ADMIN approve
                request_user = db.session.get(User, leave_request.user_id)
                validation_errors = []

                if not leave_request.employee_code or (leave_request.employee_code and leave_request.employee_code.strip() == ''):
                    validation_errors.append('Thi·∫øu m√£ nh√¢n vi√™n (employee_code) tr√™n ƒë∆°n')

                if not leave_request.team or (leave_request.team and leave_request.team.strip() == ''):
                    validation_errors.append('Thi·∫øu th√¥ng tin team/ph√≤ng ban tr√™n ƒë∆°n')

                if request_user and (not request_user.employee_id or request_user.employee_id.strip() == ''):
                    validation_errors.append('User kh√¥ng c√≥ employee_id trong h·ªá th·ªëng')

                if validation_errors:
                    _safe_print(f"‚ùå [LEAVE_APPROVE] Validation failed cho ƒë∆°n #{request_id}: {validation_errors}")
                    return jsonify({
                        'error': 'Kh√¥ng th·ªÉ ph√™ duy·ªát do thi·∫øu th√¥ng tin',
                        'validation_errors': validation_errors,
                        'suggestion': 'Vui l√≤ng c·∫≠p nh·∫≠t th√¥ng tin nh√¢n vi√™n tr∆∞·ªõc khi ph√™ duy·ªát'
                    }), 400

                # Ph√™ duy·ªát cu·ªëi c√πng
                leave_request.status = 'approved'
                leave_request.step = 'done'
                leave_request.current_approver_id = None
                leave_request.admin_signer_id = user.id
                leave_request.admin_approved_at = datetime.now()
                message = 'ƒê∆°n xin ngh·ªâ ph√©p ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát ho√†n t·∫•t!'
                
        elif action == 'reject':
            # T·ª´ ch·ªëi - chuy·ªÉn v·ªÅ nh√¢n vi√™n ch·ªânh s·ª≠a
            leave_request.status = 'rejected'
            leave_request.step = 'employee_edit'
            leave_request.current_approver_id = leave_request.user_id
            leave_request.reject_reason = reason
            
            # Th√™m vai tr√≤ ng∆∞·ªùi t·ª´ ch·ªëi v√†o l√Ω do t·ª´ ch·ªëi
            if reason:
                leave_request.notes = f"L√Ω do t·ª´ ch·ªëi: {reason} ( {current_role} )"
            else:
                leave_request.notes = f"L√Ω do t·ª´ ch·ªëi: ( {current_role} )"
            message = 'ƒê∆°n xin ngh·ªâ ph√©p ƒë√£ b·ªã t·ª´ ch·ªëi!'
        else:
            return jsonify({'error': 'H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá!'}), 400
        
        db.session.commit()

        # Ki·ªÉm tra ƒëi·ªÅu ki·ªán ƒë·ªÉ c·∫≠p nh·∫≠t Google Sheet
        has_admin_approval = (leave_request.admin_approved_at is not None or leave_request.admin_signer_id is not None)
        should_update_sheet = (action == 'approve' and leave_request.status == 'approved' and has_admin_approval)
        if should_update_sheet:
            try:
                # Refresh leave_request t·ª´ database sau khi commit ƒë·ªÉ ƒë·∫£m b·∫£o c√≥ d·ªØ li·ªáu m·ªõi nh·∫•t
                db.session.refresh(leave_request)

                _safe_print(f"üìã [LEAVE_APPROVAL] Admin {user.name} ph√™ duy·ªát ƒë∆°n #{leave_request.id} - {leave_request.employee_name}")

                trigger_schedule_leave_sheet_updates_async(leave_request.id, user.id if user else None)

                _safe_print(f"‚úÖ [LEAVE_APPROVAL] ƒê√£ kh·ªüi ƒë·ªông background c·∫≠p nh·∫≠t Google Sheet cho ƒë∆°n #{leave_request.id}")
            except Exception as sheet_err:
                import traceback
                _safe_print(f"‚ùå [LEAVE_APPROVAL] L·ªói Google Sheet cho ƒë∆°n #{leave_request.id}: {sheet_err}")
                _safe_print(traceback.format_exc())

        _safe_print(f"‚úÖ [LEAVE_APPROVE] Ho√†n th√†nh ƒë∆°n #{request_id}: {message}")
        return jsonify({'message': message})

    except Exception as e:
        db.session.rollback()
        import traceback
        _safe_print(f"‚ùå [LEAVE_APPROVE] L·ªói ƒë∆°n #{request_id}: {e}")
        _safe_print(traceback.format_exc())
        return jsonify({'error': f'L·ªói khi x·ª≠ l√Ω ƒë∆°n xin ngh·ªâ ph√©p: {str(e)}'}), 500

@app.route('/leave-request/<int:request_id>/delete')
def delete_leave_request(request_id):
    """X√≥a ƒë∆°n xin ngh·ªâ ph√©p"""
    if 'user_id' not in session:
        flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
        return redirect(url_for('login'))
    
    user = db.session.get(User, session['user_id'])
    if not user:
        session.clear()
        flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
        return redirect(url_for('login'))
    
    leave_request = LeaveRequest.query.get_or_404(request_id)
    
    # Ch·ªâ ng∆∞·ªùi t·∫°o ƒë∆°n m·ªõi c√≥ th·ªÉ x√≥a
    if user.id != leave_request.user_id:
        abort(403)
    
    # Ch·ªâ c√≥ th·ªÉ x√≥a khi ƒë∆°n ƒëang ·ªü tr·∫°ng th√°i ch·ªù ph√™ duy·ªát ho·∫∑c b·ªã t·ª´ ch·ªëi
    if leave_request.status not in ['pending', 'rejected']:
        flash('Ch·ªâ c√≥ th·ªÉ x√≥a ƒë∆°n khi ƒëang ch·ªù ph√™ duy·ªát ho·∫∑c b·ªã t·ª´ ch·ªëi', 'error')
        return redirect(url_for('view_leave_request', request_id=request_id))
    
    try:
        try:
            # G·ª≠i email th√¥ng b√°o t·ªõi HR v·ªÅ vi·ªác ng∆∞·ªùi d√πng h·ªßy/x√≥a ƒë∆°n
            send_leave_request_email_async(leave_request, user, action='delete')
            from utils.email_utils import process_db_updates
            process_db_updates()
            upsert_email_status(leave_request.id, 'sending', 'ƒêang g·ª≠i email th√¥ng b√°o h·ªßy/x√≥a ƒë∆°n...')
            session['email_status'] = {
                'request_id': leave_request.id,
                'status': 'sending',
                'message': 'ƒêang g·ª≠i email th√¥ng b√°o h·ªßy/x√≥a ƒë∆°n...'
            }
        except Exception as mail_err:
            session['email_status'] = {
                'request_id': leave_request.id,
                'status': 'error',
                'message': f'L·ªói khi g·ª≠i email th√¥ng b√°o h·ªßy/x√≥a ƒë∆°n: {str(mail_err)}'
            }
        db.session.delete(leave_request)
        db.session.commit()
        # flash('ƒê∆°n xin ngh·ªâ ph√©p ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng!', 'success')
        return redirect(url_for('leave_requests_list'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'L·ªói khi x√≥a ƒë∆°n xin ngh·ªâ ph√©p: {str(e)}', 'error')
        return redirect(url_for('view_leave_request', request_id=request_id))

@app.route('/leave-history')
def leave_history():
    """Hi·ªÉn th·ªã l·ªãch s·ª≠ ngh·ªâ ph√©p: t·∫•t c·∫£ ƒë∆°n ngh·ªâ ph√©p c·ªßa ch√≠nh ng∆∞·ªùi d√πng"""
    try:
        if 'user_id' not in session:
            flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
            return redirect(url_for('login'))

        user = db.session.get(User, session['user_id'])
        if not user:
            session.clear()
            flash('Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá!', 'error')
            return redirect(url_for('login'))

        current_role = session.get('current_role', user.roles.split(',')[0])

        page = request.args.get('page', 1, type=int)
        per_page = 10

        try:
            # L·ªãch s·ª≠ ngh·ªâ ph√©p
            # - ADMIN: xem to√†n b·ªô l·ªãch s·ª≠ ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát c·ªßa t·∫•t c·∫£ nh√¢n vi√™n
            # - Ng∆∞·ªùi d√πng kh√°c: xem l·ªãch s·ª≠ ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát c·ªßa ch√≠nh m√¨nh
            if current_role == 'ADMIN':
                query = LeaveRequest.query.filter(LeaveRequest.status == 'approved')
            else:
                query = LeaveRequest.query.filter(LeaveRequest.user_id == user.id, LeaveRequest.status == 'approved')

            # B·ªô l·ªçc (GET)
            keyword = (request.args.get('q') or '').strip()
            department = (request.args.get('department') or '').strip()
            from_date_str = (request.args.get('from_date') or '').strip()
            to_date_str = (request.args.get('to_date') or '').strip()
            status_filter = (request.args.get('status') or '').strip()
            request_type_filter = (request.args.get('request_type') or '').strip()

            if keyword:
                # T√¨m theo t√™n ho·∫∑c m√£ nh√¢n vi√™n
                query = query.filter(
                    db.or_(
                        LeaveRequest.employee_name.ilike(f"%{keyword}%"),
                        LeaveRequest.employee_code.ilike(f"%{keyword}%")
                    )
                )

            if department and current_role == 'ADMIN':
                # Join sang User ƒë·ªÉ l·ªçc theo ph√≤ng ban
                query = query.join(User, User.id == LeaveRequest.user_id).filter(User.department == department)

            if status_filter:
                query = query.filter(LeaveRequest.status == status_filter)

            if request_type_filter:
                # H·ªó tr·ª£: leave | late_early | 30min_break
                query = query.filter(LeaveRequest.request_type == request_type_filter)

            # L·ªçc theo ng√†y xin ngh·ªâ th·ª±c t·∫ø
            try:
                if from_date_str:
                    from_dt = datetime.strptime(from_date_str, '%Y-%m-%d')
                    # L·ªçc c√°c ƒë∆°n c√≥ ng√†y k·∫øt th√∫c ngh·ªâ >= ng√†y b·∫Øt ƒë·∫ßu l·ªçc
                    query = query.filter(
                        db.or_(
                            # Ng√†y k·∫øt th√∫c ngh·ªâ >= ng√†y l·ªçc
                            db.and_(
                                LeaveRequest.leave_to_year > from_dt.year
                            ),
                            db.and_(
                                LeaveRequest.leave_to_year == from_dt.year,
                                LeaveRequest.leave_to_month > from_dt.month
                            ),
                            db.and_(
                                LeaveRequest.leave_to_year == from_dt.year,
                                LeaveRequest.leave_to_month == from_dt.month,
                                LeaveRequest.leave_to_day >= from_dt.day
                            )
                        )
                    )
                if to_date_str:
                    to_dt = datetime.strptime(to_date_str, '%Y-%m-%d')
                    # L·ªçc c√°c ƒë∆°n c√≥ ng√†y b·∫Øt ƒë·∫ßu ngh·ªâ <= ng√†y k·∫øt th√∫c l·ªçc
                    query = query.filter(
                        db.or_(
                            # Ng√†y b·∫Øt ƒë·∫ßu ngh·ªâ <= ng√†y l·ªçc
                            db.and_(
                                LeaveRequest.leave_from_year < to_dt.year
                            ),
                            db.and_(
                                LeaveRequest.leave_from_year == to_dt.year,
                                LeaveRequest.leave_from_month < to_dt.month
                            ),
                            db.and_(
                                LeaveRequest.leave_from_year == to_dt.year,
                                LeaveRequest.leave_from_month == to_dt.month,
                                LeaveRequest.leave_from_day <= to_dt.day
                            )
                        )
                    )
            except Exception:
                pass

            query = query.order_by(LeaveRequest.created_at.desc())

            pagination = query.paginate(page=page, per_page=per_page, error_out=False)

        except Exception as query_error:
            print(f"[ERROR] Database query error in leave_history: {query_error}")
            import traceback
            traceback.print_exc()
            flash(f'L·ªói truy v·∫•n d·ªØ li·ªáu: {str(query_error)}', 'error')
            return render_template('leave_history.html',
                                   leave_requests=[],
                                   pagination=None,
                                   user=user,
                                   current_role=current_role)

        # Danh s√°ch ph√≤ng ban cho filter
        try:
            # Th·ª≠ l·∫•y t·ª´ b·∫£ng Department tr∆∞·ªõc
            dept_objects = Department.query.filter(Department.is_active == True).order_by(Department.name.asc()).all()
            if dept_objects:
                departments = [d.name for d in dept_objects]
            else:
                # Fallback: distinct t·ª´ User n·∫øu Department tr·ªëng
                departments = sorted({u.department for u in User.query.filter(User.department.isnot(None), User.department != '').all()})
        except Exception as e:
            # Fallback: distinct t·ª´ User
            departments = sorted({u.department for u in User.query.filter(User.department.isnot(None), User.department != '').all()})

        return render_template('leave_history.html',
                               leave_requests=pagination.items,
                               pagination=pagination,
                               user=user,
                               current_role=current_role,
                               departments=departments,
                               current_filters={
                                   'q': keyword,
                                   'department': department,
                                   'from_date': from_date_str,
                                   'to_date': to_date_str,
                                   'status': status_filter,
                                   'request_type': request_type_filter
                               })
    except Exception as e:
        print(f"[ERROR] Error in leave_history: {e}")
        import traceback
        traceback.print_exc()
        flash(f'C√≥ l·ªói x·∫£y ra: {str(e)}', 'error')
        return redirect(url_for('dashboard'))
@app.route('/leave-request/back-to-dashboard')
def back_to_dashboard():
    """Quay v·ªÅ dashboard v·ªõi vai tr√≤ hi·ªán t·∫°i"""
    if 'user_id' not in session:
        flash('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y', 'error')
        return redirect(url_for('login'))
    
    # L·∫•y vai tr√≤ hi·ªán t·∫°i t·ª´ session
    current_role = session.get('current_role', 'EMPLOYEE')
    # Redirect to dashboard with current role
    
    # Chuy·ªÉn h∆∞·ªõng v·ªÅ dashboard v·ªõi vai tr√≤ hi·ªán t·∫°i
    return redirect(url_for('dashboard', role=current_role))


# A4: CSRF protection enabled - chatbot widget now sends X-CSRFToken header
@app.route('/api/chatbot', methods=['POST'])
@rate_limit(max_requests=30, window_seconds=60)  # Gi·ªõi h·∫°n ƒë·ªÉ tr√°nh spam g·ªçi AI
def api_chatbot():
    """
    API chatbot AI h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng h·ªá th·ªëng.
    H·ªó tr·ª£:
    - Ollama local (m·∫∑c ƒë·ªãnh): CHATBOT_PROVIDER=ollama
    - DeepSeek API (ki·ªÉu OpenAI): CHATBOT_PROVIDER=deepseek, c·∫ßn DEEPSEEK_API_KEY
    """
    try:
        if not is_app_activated():
            return jsonify({'error': '·ª®ng d·ª•ng ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t ho·∫∑c license kh√¥ng h·ª£p l·ªá.'}), 403

        if not request.is_json:
            return jsonify({'error': 'Y√™u c·∫ßu kh√¥ng h·ª£p l·ªá (thi·∫øu JSON).'}), 400

        data = request.get_json() or {}
        message = (data.get('message') or '').strip()
        if not message:
            return jsonify({'error': 'Vui l√≤ng nh·∫≠p n·ªôi dung c√¢u h·ªèi.'}), 400

        # Ch·∫∑n c√°c input qu√° ng·∫Øn/v√¥ nghƒ©a ƒë·ªÉ tr√°nh g·ªçi LLM kh√¥ng c·∫ßn thi·∫øt
        import re
        normalized_msg = re.sub(r'[\s\W_]+', '', message.lower())
        if len(normalized_msg) < 3:
            return jsonify({'answer': _CHATBOT_CLARIFY_MESSAGE}), 200

        # L·∫•y l·ªãch s·ª≠ h·ªôi tho·∫°i t·ª´ request n·∫øu c√≥
        conversation_history = data.get('conversation_history', [])
        if conversation_history and isinstance(conversation_history, list):
            # ƒê·∫£m b·∫£o format ƒë√∫ng
            conversation_history = [
                {'role': msg.get('role', 'user'), 'content': str(msg.get('content', ''))}
                for msg in conversation_history
                if msg.get('content', '').strip()
            ]

        # L·∫•y UI context t·ª´ request n·∫øu c√≥
        ui_context = data.get('ui_context', {})
        if not isinstance(ui_context, dict):
            ui_context = {}

        # L·∫•y context ng∆∞·ªùi d√πng t·ª´ session n·∫øu c√≥
        user_context = {}
        try:
            if 'user_id' in session:
                user = db.session.get(User, session['user_id'])
                if user:
                    user_context['user_name'] = user.name
                    user_context['department'] = getattr(user, 'department', None)
                    # ∆Øu ti√™n role hi·ªán t·∫°i trong session; n·∫øu ch∆∞a c√≥ th√¨ l·∫•y role ƒë·∫ßu ti√™n c·ªßa user
                    user_roles = []
                    try:
                        user_roles = user.get_roles_list()
                    except Exception:
                        # N·∫øu model kh√¥ng c√≥ get_roles_list th√¨ fallback v·ªÅ chu·ªói roles
                        if getattr(user, 'roles', None):
                            user_roles = [r.strip() for r in str(user.roles).split(',') if r.strip()]
                    current_role = session.get('current_role')
                    if not current_role and user_roles:
                        current_role = user_roles[0]
                    user_context['role'] = current_role or None
        except Exception as e:
            print(f"[CHATBOT] L·ªói l·∫•y context ng∆∞·ªùi d√πng: {e}")

        try:
            print(f"[CHATBOT] /api/chatbot called by user_id={session.get('user_id')} role={session.get('current_role')}, history_length={len(conversation_history)}, ui_context_keys={list(ui_context.keys())}")
        except Exception:
            pass

        answer = call_chatbot_llm(message, user_context=user_context, conversation_history=conversation_history, ui_context=ui_context)
        return jsonify({'answer': answer})

    except Exception as e:
        print(f"[CHATBOT] L·ªói trong api_chatbot: {e}")
        return jsonify({'error': 'C√≥ l·ªói x·∫£y ra khi g·ªçi tr·ª£ l√Ω AI. Vui l√≤ng th·ª≠ l·∫°i sau.'}), 500


@app.route('/api/pending-leave-count')
def api_pending_leave_count():
    """API ƒë·ªÉ l·∫•y s·ªë l∆∞·ª£ng ƒë∆°n ngh·ªâ ph√©p c·∫ßn ph√™ duy·ªát"""
    try:
        # Ki·ªÉm tra user ƒë√£ ƒëƒÉng nh·∫≠p
        if 'user_id' not in session:
            return jsonify({'error': 'Unauthorized'}), 401
        
        user = db.session.get(User, session['user_id'])
        if not user:
            return jsonify({'error': 'User not found'}), 404
        
        # Ch·ªâ tr∆∞·ªüng nh√≥m, qu·∫£n l√Ω v√† qu·∫£n tr·ªã vi√™n m·ªõi c√≥ quy·ªÅn xem
        user_roles = user.get_roles_list()
        if not any(role in ['TEAM_LEADER', 'MANAGER', 'ADMIN'] for role in user_roles):
            return jsonify({'error': 'Forbidden'}), 403
        
        # ƒê·∫øm s·ªë ƒë∆°n ngh·ªâ ph√©p ƒëang ch·ªù ph√™ duy·ªát theo vai tr√≤
        current_role = session.get('current_role', user_roles[0] if user_roles else 'EMPLOYEE')
        
        if current_role == 'TEAM_LEADER':
            # TEAM_LEADER ch·ªâ ƒë·∫øm ƒë∆°n pending c·ªßa nh√¢n vi√™n c√πng ph√≤ng ban
            pending_count = LeaveRequest.query.filter(
                LeaveRequest.status == 'pending',
                LeaveRequest.user.has(User.department == user.department)
            ).count()
        elif current_role == 'MANAGER':
            pending_count = LeaveRequest.query.filter_by(status='pending_manager').count()
        elif current_role == 'ADMIN':
            pending_count = LeaveRequest.query.filter_by(status='pending_admin').count()
        else:
            pending_count = 0
        
        return jsonify({'count': pending_count})
        
    except Exception as e:
        print(f"Error in api_pending_leave_count: {e}")
        return jsonify({'error': 'Internal server error'}), 500



@csrf.exempt  # T·∫°m th·ªùi b·ªè qua CSRF ƒë·ªÉ test
@app.route('/test-excel')
def test_excel():
    """Test endpoint ƒë·ªÉ ki·ªÉm tra Excel export"""
    try:
        # T·∫°o file Excel ƒë∆°n gi·∫£n
        wb = Workbook()
        ws = wb.active
        ws.title = "Test"
        ws.cell(row=1, column=1, value="Test")
        ws.cell(row=2, column=1, value="Hello World")
        
        # L∆∞u file v√†o memory
        from io import BytesIO
        output = BytesIO()
        wb.save(output)
        output.seek(0)
        
        # T·∫°o response
        filename = f"test_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        return send_file(
            output,
            as_attachment=True,
            download_name=filename,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
        
    except Exception as e:
        print(f"[ERROR] Error in test Excel: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói test Excel: {str(e)}'}), 500

# Test route ƒë·ªÉ ki·ªÉm tra routing
@app.route('/test-export-route')
def test_export_route():
    return jsonify({'message': 'Route test ho·∫°t ƒë·ªông!'}), 200

# Route export attendance history Excel - REMOVED DUPLICATE (route is defined at line 7003)


@csrf.exempt  # T·∫°m th·ªùi b·ªè qua CSRF ƒë·ªÉ test
@app.route('/export-leave-history-excel')
def export_leave_history_excel():
    """Xu·∫•t l·ªãch s·ª≠ ngh·ªâ ph√©p ra file Excel cho ADMIN - T√°ch t·ª´ng ng√†y ri√™ng bi·ªát"""
    try:
        # Import utility functions
        from utils.excel_leave_processor import process_leave_requests_for_excel
        from openpyxl import Workbook
        from openpyxl.styles import Font, PatternFill, Alignment
        
        # L·∫•y d·ªØ li·ªáu theo b·ªô l·ªçc gi·ªëng trang danh s√°ch
        if 'user_id' not in session:
            return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p'}), 401

        user = db.session.get(User, session['user_id'])
        current_role = session.get('current_role', user.roles.split(',')[0]) if user else 'EMPLOYEE'

        if current_role == 'ADMIN':
            query = LeaveRequest.query.filter(LeaveRequest.status == 'approved')
        else:
            query = LeaveRequest.query.filter(LeaveRequest.user_id == user.id, LeaveRequest.status == 'approved')

        # Nh·∫≠n tham s·ªë filter t·ª´ query string
        keyword = (request.args.get('q') or '').strip()
        department = (request.args.get('department') or '').strip()
        from_date_str = (request.args.get('from_date') or '').strip()
        to_date_str = (request.args.get('to_date') or '').strip()
        status_filter = (request.args.get('status') or '').strip()
        request_type_filter = (request.args.get('request_type') or '').strip()

        if keyword:
            query = query.filter(
                db.or_(
                    LeaveRequest.employee_name.ilike(f"%{keyword}%"),
                    LeaveRequest.employee_code.ilike(f"%{keyword}%")
                )
            )

        if department and current_role == 'ADMIN':
            query = query.join(User, User.id == LeaveRequest.user_id).filter(User.department == department)

        if status_filter:
            query = query.filter(LeaveRequest.status == status_filter)

        if request_type_filter:
            # H·ªó tr·ª£: leave | late_early | 30min_break
            query = query.filter(LeaveRequest.request_type == request_type_filter)

        # L·ªçc theo kho·∫£ng ng√†y t∆∞∆°ng t·ª± trang danh s√°ch
        try:
            if from_date_str:
                from_dt = datetime.strptime(from_date_str, '%Y-%m-%d')
                query = query.filter(
                    db.or_(
                        db.and_(LeaveRequest.leave_to_year > from_dt.year),
                        db.and_(LeaveRequest.leave_to_year == from_dt.year, LeaveRequest.leave_to_month > from_dt.month),
                        db.and_(
                            LeaveRequest.leave_to_year == from_dt.year,
                            LeaveRequest.leave_to_month == from_dt.month,
                            LeaveRequest.leave_to_day >= from_dt.day
                        )
                    )
                )
            if to_date_str:
                to_dt = datetime.strptime(to_date_str, '%Y-%m-%d')
                query = query.filter(
                    db.or_(
                        db.and_(LeaveRequest.leave_from_year < to_dt.year),
                        db.and_(LeaveRequest.leave_from_year == to_dt.year, LeaveRequest.leave_from_month < to_dt.month),
                        db.and_(
                            LeaveRequest.leave_from_year == to_dt.year,
                            LeaveRequest.leave_from_month == to_dt.month,
                            LeaveRequest.leave_from_day <= to_dt.day
                        )
                    )
                )
        except Exception:
            pass

        leave_requests = query.order_by(LeaveRequest.created_at.desc()).all()

        # X·ª≠ l√Ω d·ªØ li·ªáu ƒë·ªÉ t√°ch t·ª´ng ng√†y
        daily_leaves = process_leave_requests_for_excel(leave_requests)

        # T·∫°o file Excel
        wb = Workbook()
        ws = wb.active
        # ƒê·∫∑t ti√™u ƒë·ªÅ sheet ti·∫øng Vi·ªát (<=31 k√Ω t·ª±, kh√¥ng ch·ª©a: : \\ / ? * [ ])
        ws.title = "L·ªãch s·ª≠ ngh·ªâ ph√©p"
        
        # ƒê·ªãnh d·∫°ng header
        header_font = Font(bold=True, color="FFFFFF", size=12)
        header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
        header_alignment = Alignment(horizontal="center", vertical="center")
        
        # T·∫°o header m·ªõi v·ªõi th√¥ng tin chi ti·∫øt h∆°n
        headers = [
            "Ng√†y ngh·ªâ", 
            "T√™n nh√¢n vi√™n", 
            "M√£ nh√¢n vi√™n", 
            "Th·ªùi gian ngh·ªâ", 
            "Lo·∫°i ngh·ªâ", 
            "S·ªë ng√†y"
        ]
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = header_alignment
        
        # (ƒê√£ chuy·ªÉn xu·ªëng cu·ªëi h√†m ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng b·ªã ghi ƒë√®)

        # Th√™m d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c t√°ch theo ng√†y
        for row, day_leave in enumerate(daily_leaves, 2):
            try:
                # 1. Ng√†y ngh·ªâ
                date_str = day_leave['date'].strftime('%d/%m/%Y')
                cell_a = ws.cell(row=row, column=1, value=date_str)
                cell_a.alignment = Alignment(horizontal="center", vertical="center")

                # 2. T√™n nh√¢n vi√™n
                employee_name = str(day_leave['employee_name']).replace('\x00', '').replace('\r', '').replace('\n', ' ')
                cell_b = ws.cell(row=row, column=2, value=employee_name)
                # T·∫ÆT wrap_text ƒë·ªÉ bu·ªôc excel hi·ªÉn th·ªã ngang, ki·ªÉm tra xem width c√≥ ƒÉn kh√¥ng
                cell_b.alignment = Alignment(vertical="center", wrap_text=False)

                # 3. M√£ nh√¢n vi√™n
                employee_code = str(day_leave['employee_code']).replace('\x00', '').replace('\r', '').replace('\n', ' ')
                cell_c = ws.cell(row=row, column=3, value=employee_code)
                cell_c.alignment = Alignment(horizontal="center", vertical="center")
                
                # 4. Th·ªùi gian ngh·ªâ (gi·ªù b·∫Øt ƒë·∫ßu - gi·ªù k·∫øt th√∫c)
                start_time_str = day_leave['start_time'].strftime('%H:%M')
                end_time_str = day_leave['end_time'].strftime('%H:%M')
                time_info = f"{start_time_str} - {end_time_str}"
                cell_d = ws.cell(row=row, column=4, value=time_info)
                cell_d.alignment = Alignment(horizontal="center", vertical="center")
                
                # 5. Lo·∫°i ngh·ªâ
                leave_type = day_leave['leave_type']
                leave_type_text = str(leave_type['name']) if leave_type['name'] else ""
                if leave_type.get('special_type'):
                    special_type = str(leave_type['special_type']).replace('\x00', '').replace('\r', '').replace('\n', ' ')
                    leave_type_text += f" ({special_type})"
                # Lo·∫°i b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát
                leave_type_text = leave_type_text.replace('\x00', '').replace('\r', '').replace('\n', ' ')
                cell_e = ws.cell(row=row, column=5, value=leave_type_text)
                cell_e.alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)
                
                # 6. S·ªë ng√†y ho·∫∑c S·ªë gi·ªù:ph√∫t
                leave_type_code = leave_type.get('type', 'unknown')
                
                # V·ªõi c√°c lo·∫°i ngh·ªâ ƒë·∫∑c bi·ªát (ƒëi tr·ªÖ, v·ªÅ s·ªõm, ngh·ªâ 30 ph√∫t), hi·ªÉn th·ªã s·ªë gi·ªù:ph√∫t
                if leave_type_code in ['late_arrival', 'early_departure', '30min_break', 'late_early']:
                    # T√≠nh s·ªë gi·ªù:ph√∫t t·ª´ start_time v√† end_time
                    from datetime import datetime, timedelta
                    start_dt = datetime.combine(day_leave['date'], day_leave['start_time'])
                    end_dt = datetime.combine(day_leave['date'], day_leave['end_time'])
                    duration = end_dt - start_dt
                    
                    # Chuy·ªÉn ƒë·ªïi th√†nh gi·ªù:ph√∫t
                    total_minutes = int(duration.total_seconds() / 60)
                    hours = total_minutes // 60
                    minutes = total_minutes % 60
                    days_value = f"{hours:02d}:{minutes:02d}"
                else:
                    # V·ªõi c√°c lo·∫°i ngh·ªâ th√¥ng th∆∞·ªùng, hi·ªÉn th·ªã s·ªë ng√†y
                    days_value = day_leave.get('fractional_days', leave_type.get('days', 1.0))
                
                cell_f = ws.cell(row=row, column=6, value=days_value)
                cell_f.alignment = Alignment(horizontal="center", vertical="center")
                
            except Exception as e:
                print(f"[ERROR] Error adding row {row}: {e}")
                import traceback
                traceback.print_exc()
                # Th√™m d·ªØ li·ªáu c∆° b·∫£n n·∫øu c√≥ l·ªói
                try:
                    ws.cell(row=row, column=1, value="L·ªói d·ªØ li·ªáu")
                    employee_name = str(day_leave.get('employee_name', 'N/A')).replace('\x00', '').replace('\r', '').replace('\n', ' ')
                    ws.cell(row=row, column=2, value=employee_name)
                except Exception:
                    ws.cell(row=row, column=1, value="Critical Error")
                ws.cell(row=row, column=3, value="L·ªói hi·ªÉn th·ªã th·ªùi gian")
                ws.cell(row=row, column=4, value="L·ªói hi·ªÉn th·ªã l√Ω do")
                ws.cell(row=row, column=5, value="L·ªói hi·ªÉn th·ªã lo·∫°i ngh·ªâ")
                ws.cell(row=row, column=6, value="L·ªói")
                ws.cell(row=row, column=7, value="L·ªói")
        
        # ƒêi·ªÅu ch·ªânh ƒë·ªô r·ªông c·ªôt - C·∫¨P NH·∫¨T M·ªöI (ƒê√£ chuy·ªÉn xu·ªëng cu·ªëi)
        ws.column_dimensions['A'].width = 15  # Ng√†y ngh·ªâ
        ws.column_dimensions['B'].width = 40  # T√™n nh√¢n vi√™n (Gi·∫£m xu·ªëng 40)
        ws.column_dimensions['C'].width = 17  # M√£ nh√¢n vi√™n (TƒÉng 10%)
        ws.column_dimensions['D'].width = 25  # Th·ªùi gian ngh·ªâ
        ws.column_dimensions['E'].width = 40  # Lo·∫°i ngh·ªâ
        ws.column_dimensions['F'].width = 12  # S·ªë ng√†y (TƒÉng th√™m)
        
        # ƒêi·ªÅu ch·ªânh chi·ªÅu cao h√†ng
        for row in range(2, len(daily_leaves) + 2):
            ws.row_dimensions[row].height = 30  # Chi·ªÅu cao ph√π h·ª£p cho d·ªØ li·ªáu ƒë√£ t√°ch
        
        # Th√™m filter cho header
        ws.auto_filter.ref = f"A1:{get_column_letter(len(headers))}{len(daily_leaves) + 1}"
        
        # L∆∞u file v√†o memory
        from io import BytesIO
        output = BytesIO()

        try:
            wb.save(output)
            output.seek(0)
        except Exception as save_error:
            print(f"[ERROR] Error saving Excel file: {save_error}")
            raise save_error
        
        # T·∫°o response
        # T√™n file ti·∫øng Vi·ªát + fallback ASCII theo RFC 5987
        vn_filename = f"L·ªãch_s·ª≠_ngh·ªâ_ph√©p_chi_ti·∫øt_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        from urllib.parse import quote
        ascii_fallback = "lich_su_nghi_phep_chi_tiet.xlsx"
        content_disposition = (
            f"attachment; filename=\"{ascii_fallback}\"; "
            f"filename*=UTF-8''{quote(vn_filename)}"
        )
        
        # T·∫°o response v·ªõi encoding ƒë√∫ng
        response = make_response(output.getvalue())
        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        response.headers['Content-Disposition'] = content_disposition
        response.headers['Content-Length'] = len(output.getvalue())
        # Th√™m header ƒë·ªÉ t·ª± ƒë·ªông t·∫£i xu·ªëng Downloads
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        
        return response
        
    except Exception as e:
        print(f"[ERROR] Error exporting Excel: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói khi xu·∫•t file Excel: {str(e)}'}), 500



@app.route('/export-attendance-excel-full', methods=['GET'])
# Note: Removed @login_required because it causes redirect to login page
# which conflicts with fetch API. Using manual session check instead (line 19344).
def export_attendance_excel_full():
    """Xu·∫•t ngh·ªâ ph√©p ra file Excel theo format ch·∫•m c√¥ng FULL v·ªõi ƒë·∫ßy ƒë·ªß th√¥ng tin ca, gi·ªù l√†m, tƒÉng ca"""
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, PatternFill, Alignment
        from openpyxl.utils import get_column_letter
        from utils.excel_leave_processor import process_leave_requests_for_excel
        from datetime import time as time_type
        
        # Helper function: Convert integer minutes to H:MM format (NO FLOATING POINT ERRORS)
        def minutes_to_hhmm(minutes):
            """Convert minutes (integer) to H:MM string format"""
            if minutes is None or minutes < 0:
                return "0:00"
            hours = minutes // 60
            mins = minutes % 60
            return f"{hours}:{mins:02d}"
        
        # Ki·ªÉm tra ƒëƒÉng nh·∫≠p
        if 'user_id' not in session:
            return jsonify({'error': 'Ch∆∞a ƒëƒÉng nh·∫≠p'}), 401

        user = db.session.get(User, session['user_id'])
        current_role = session.get('current_role', user.roles.split(',')[0]) if user else 'EMPLOYEE'

        # Query ATTENDANCE RECORDS (b·∫£n ghi ch·∫•m c√¥ng)
        if current_role == 'ADMIN':
            # ADMIN: t·∫•t c·∫£ attendance records ƒë√£ duy·ªát
            query = Attendance.query.filter(Attendance.status == 'approved')
        else:
            # User th∆∞·ªùng: ch·ªâ attendance records c·ªßa m√¨nh ƒë√£ duy·ªát
            query = Attendance.query.filter(
                Attendance.user_id == user.id,
                Attendance.status == 'approved'
            )

        # Nh·∫≠n tham s·ªë filter t·ª´ query string
        keyword = (request.args.get('q') or '').strip()
        department = (request.args.get('department') or '').strip()
        from_date_str = (request.args.get('from_date') or '').strip()
        to_date_str = (request.args.get('to_date') or '').strip()
        
        # Filter theo keyword (employee name/code)
        if keyword:
            query = query.join(User, User.id == Attendance.user_id).filter(
                db.or_(
                    User.name.ilike(f"%{keyword}%"),
                    User.employee_id.ilike(f"%{keyword}%")
                )
            )
        
        # Filter theo department (ch·ªâ ADMIN)
        if department and current_role == 'ADMIN':
            # Join User if not already joined (e.g., if keyword was not provided)
            if not keyword:
                query = query.join(User, User.id == Attendance.user_id)
            query = query.filter(User.department == department)
        
        # ---------------------------------------------------------
        # LOGIC L·ªåC TH·ªúI GIAN
        # ---------------------------------------------------------
        month_from = request.args.get('month_from')
        month_to = request.args.get('month_to')
        year_from = request.args.get('year_from')
        year_to = request.args.get('year_to')
        
        # Priority: date range > month/year range
        filter_from_date = None
        filter_to_date = None
        
        if from_date_str:
            filter_from_date = datetime.strptime(from_date_str, '%Y-%m-%d').date()
        if to_date_str:
            filter_to_date = datetime.strptime(to_date_str, '%Y-%m-%d').date()
        
        # N·∫øu kh√¥ng c√≥ date exact, d√πng month/year
        if not filter_from_date and month_from:
            try:
                import calendar
                from datetime import date as _date
                
                m_from = int(month_from)
                # Default year is current year if not provided
                y_from = int(year_from) if year_from else datetime.now().year
                
                # Determine end point
                m_to = int(month_to) if month_to else m_from
                y_to = int(year_to) if year_to else y_from
                
                if 1 <= m_from <= 12 and 1 <= m_to <= 12:
                    filter_from_date = _date(y_from, m_from, 1)
                    last_day = calendar.monthrange(y_to, m_to)[1]
                    filter_to_date = _date(y_to, m_to, last_day)
            except Exception as e:
                pass  # Silently ignore parse errors

        # ============================================================================
        # VALIDATION: Y√™u c·∫ßu ch·ªçn ng√†y th√°ng ƒë·ªÉ xu·∫•t Excel Full
        # ============================================================================
        if not filter_from_date and not filter_to_date:
            return jsonify({
                'error': 'Vui l√≤ng ch·ªçn kho·∫£ng th·ªùi gian ƒë·ªÉ xu·∫•t Excel!',
                'message': 'B·∫°n c·∫ßn ch·ªçn "T·ª´ ng√†y" v√† "ƒê·∫øn ng√†y" ho·∫∑c "Th√°ng/NƒÉm" tr∆∞·ªõc khi t·∫£i Excel Full.'
            }), 400

        # Apply filters
        if filter_from_date:
            query = query.filter(Attendance.date >= filter_from_date)

        if filter_to_date:
            query = query.filter(Attendance.date <= filter_to_date)

        attendance_records = query.order_by(Attendance.date.desc()).all()

        # T·∫°o workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Ch·∫•m c√¥ng Full"
        
        # HEADER - Match attendance history export format
        headers = [
            "Ng√†y", "Nh√¢n vi√™n", "M√£ nh√¢n vi√™n", "Ph√≤ng ban",
            "Gi·ªù v√†o", "Gi·ªù ra", "Ngh·ªâ", "ƒê·ªëi ·ª©ng",
            "T·ªïng gi·ªù l√†m", "Gi·ªù c√¥ng", "TƒÉng ca tr∆∞·ªõc 22h", "TƒÉng ca sau 22h", "Lo·∫°i ng√†y"
        ]
        
        # Style header
        header_fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
        header_font = Font(bold=True, color="FFFFFF", size=11)
        
        for col_num, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col_num, value=header)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = Alignment(horizontal="center", vertical="center")

        # Populate data
        for row_idx, att in enumerate(attendance_records, 2):
            try:
                # L·∫•y user info
                att_user = att.user
                employee_name = att_user.name if att_user else "N/A"
                employee_code = str(att_user.employee_id) if att_user else "N/A"
                department = att_user.department if att_user else "N/A"
                
                # KI·ªÇM TRA: C√≥ ƒë∆°n ƒëi tr·ªÖ/v·ªÅ s·ªõm trong ng√†y n√†y kh√¥ng?
                # Using component-based date comparison because LeaveRequest stores dates in parts
                y, m, d = att.date.year, att.date.month, att.date.day
                
                start_cond = db.or_(
                    LeaveRequest.leave_from_year < y,
                    db.and_(LeaveRequest.leave_from_year == y, LeaveRequest.leave_from_month < m),
                    db.and_(LeaveRequest.leave_from_year == y, LeaveRequest.leave_from_month == m, LeaveRequest.leave_from_day <= d)
                )
                
                end_cond = db.or_(
                    LeaveRequest.leave_to_year > y,
                    db.and_(LeaveRequest.leave_to_year == y, LeaveRequest.leave_to_month > m),
                    db.and_(LeaveRequest.leave_to_year == y, LeaveRequest.leave_to_month == m, LeaveRequest.leave_to_day >= d)
                )

                leave_request = LeaveRequest.query.filter(
                    LeaveRequest.user_id == att.user_id,
                    start_cond,
                    end_cond,
                    # Removed request_type filter to include ALL leave types (late_early, leave, 30min_break, etc.)
                    LeaveRequest.status == 'approved'
                ).first()
                
                # Chu·∫©n b·ªã gi√° tr·ªã - ƒê·ªåC T·ª™ INTEGER MINUTES COLUMNS
                actual_checkin = att.check_in
                actual_checkout = att.check_out
                # Read from *_minutes columns (integer) instead of float hours
                break_minutes = att.break_time_minutes if att.break_time_minutes is not None else 60  # Default 1h
                work_minutes = att.total_work_minutes or 0
                regular_minutes = att.regular_work_minutes or 0
                
                # --- DEBUG LOGGING ---
                # --- DEBUG LOGGING ---
                if 'BUD B' in employee_name:
                    debug_path = r'c:/Users/ADMIN/Desktop/231020253/attendances-management-system-dmi/debug_export.txt'
                    try:
                        with open(debug_path, 'a', encoding='utf-8') as f:
                            f.write(f"\n[Record] {att.date} - {employee_name} (Code: {employee_code})\n")
                            f.write(f"   Leave Request Found: {bool(leave_request)}\n")
                            if leave_request:
                                 f.write(f"   Request Type: {leave_request.request_type}\n")
                                 f.write(f"   LE Type: {leave_request.late_early_type}\n")
                                 f.write(f"   Status: {leave_request.status}\n")
                                 f.write(f"   Period: {leave_request.leave_from_hour}:{leave_request.leave_from_minute} - {leave_request.leave_to_hour}:{leave_request.leave_to_minute}\n")
                    except Exception as e:
                        print(f"Failed to write debug: {e}")


                
                # M√†u cam cho row c√≥ leave request
                orange_fill = PatternFill(start_color="FFA500", end_color="FFA500", fill_type="solid")
                has_leave = False
                
                # N·∫æU C√ì ƒê∆†N ƒêI TR·ªÑ/V·ªÄ S·ªöM (late_early) -> Highlight & C·∫≠p nh·∫≠t gi·ªù
                # User y√™u c·∫ßu: CH·ªà t√¥ cam nh·ªØng ng∆∞·ªùi c√≥ ƒëi tr·ªÖ, v·ªÅ s·ªõm
                # Check BOTH request_type AND late_early_type to be safe
                is_late_early = False
                if leave_request:
                     if leave_request.request_type == 'late_early':
                         is_late_early = True
                     elif leave_request.late_early_type in ['late', 'early']:
                         is_late_early = True
                
                if 'BUD B' in employee_name:
                     if leave_request:
                         pass  # Previously debug logging for BUD B

                if is_late_early:
                    has_leave = True
                    
                    # X·ª≠ l√Ω logic thay ƒë·ªïi gi·ªù cho ƒêi tr·ªÖ / V·ªÅ s·ªõm
                    late_early_type = leave_request.late_early_type
                        
                    if late_early_type == 'late':
                        # ƒêi tr·ªÖ: Th·ªùi gian ngh·ªâ l√† t·ª´ [Shift Start] ƒë·∫øn [Th·ª±c t·∫ø ƒë·∫øn]
                        # -> Gi·ªù v√†o l√†m th·ª±c t·∫ø l√† th·ªùi ƒëi·ªÉm K·∫æT TH√öC c·ªßa kho·∫£ng ngh·ªâ (leave_to)
                        try:
                            # Use req_time as checkin
                            # BUT we need to know if this checkin is INSIDE the shift or not?
                            # Usually yes.
                            req_time = time_type(leave_request.leave_to_hour, leave_request.leave_to_minute)
                            actual_checkin = datetime.combine(att.date, req_time)
                        except Exception:
                            pass 
                    
                    elif late_early_type == 'early':
                        # V·ªÅ s·ªõm: Th·ªùi gian ngh·ªâ l√† t·ª´ [Th·ª±c t·∫ø v·ªÅ] ƒë·∫øn [Shift End]
                        # -> Gi·ªù ra th·ª±c t·∫ø l√† th·ªùi ƒëi·ªÉm B·∫ÆT ƒê·∫¶U c·ªßa kho·∫£ng ngh·ªâ (leave_from)
                        try:
                            req_time = time_type(leave_request.leave_from_hour, leave_request.leave_from_minute)
                            actual_checkout = datetime.combine(att.date, req_time)
                        except Exception as e:
                            pass

                    # T√çNH L·∫†I work minutes v√† regular minutes d·ª±a tr√™n gi·ªù v√†o/ra th·ª±c t·∫ø (ƒë√£ ƒëi·ªÅu ch·ªânh)
                    if actual_checkin and actual_checkout:
                        # T√≠nh t·ªïng th·ªùi gian c√≥ m·∫∑t t·∫°i c√¥ng ty - D√ôNG INTEGER MINUTES
                        duration_minutes = int(round((actual_checkout - actual_checkin).total_seconds() / 60))

                        # Logic tr·ª´ gi·ªù ngh·ªâ tr∆∞a th√¥ng minh:
                        # Ki·ªÉm tra xem kho·∫£ng th·ªùi gian l√†m vi·ªác c√≥ bao tr√πm gi·ªù ngh·ªâ tr∆∞a (12:00 - 13:00) hay kh√¥ng
                        # Gi·∫£ ƒë·ªãnh gi·ªù ngh·ªâ tr∆∞a chu·∫©n l√† 12:00 - 13:00 cho c√°c ca h√†nh ch√≠nh
                        break_start = datetime.combine(att.date, time_type(12, 0))
                        break_end = datetime.combine(att.date, time_type(13, 0))
                        
                        # T√≠nh th·ªùi gian giao nhau v·ªõi gi·ªù ngh·ªâ - D√ôNG INTEGER MINUTES
                        overlap_start = max(actual_checkin, break_start)
                        overlap_end = min(actual_checkout, break_end)
                        
                        break_deduction_minutes = 0
                        if overlap_end > overlap_start:
                            break_deduction_minutes = int(round((overlap_end - overlap_start).total_seconds() / 60))

                        # N·∫øu ca l√†m vi·ªác ƒë·∫∑c bi·ªát (kh√¥ng ph·∫£i h√†nh ch√≠nh) ho·∫∑c break_time trong DB kh√°c 1h
                        # th√¨ ∆∞u ti√™n d√πng break_time_minutes trong DB n·∫øu logic tr√™n kh√¥ng ph√°t hi·ªán ngh·ªâ tr∆∞a
                        # (V√≠ d·ª• ca t·ªëi, ca ƒë√™m...) - D√ôNG INTEGER MINUTES
                        db_break_minutes = att.break_time_minutes if att.break_time_minutes is not None else 60
                        
                        # N·∫øu logic t√≠nh giao nhau ra 0 nh∆∞ng trong DB c√≥ break > 0 v√† duration ƒë·ªß d√†i (>300 ph√∫t = 5h)
                        # th√¨ fallback v·ªÅ tr·ª´ break_time_minutes c·ªßa DB (ƒë·ªÉ an to√†n cho c√°c ca kh√¥ng ph·∫£i 12-13h)
                        if break_deduction_minutes == 0 and duration_minutes >= 300:
                             break_deduction_minutes = db_break_minutes

                        # --- NEW LOGIC FOR "GI·ªú C√îNG" (Regular Hours) ---
                        # We must calculate work done WITHIN the Standard Shift boundaries.
                        # Any work outside shift is Overtime, not Regular Hours.
                        
                        # 1. Determine Shift Boundaries
                        s_start = att.shift_start if att.shift_start else time_type(8, 0) # Default 8:00
                        s_end = att.shift_end if att.shift_end else time_type(17, 0)      # Default 17:00
                        
                        shift_start_dt = datetime.combine(att.date, s_start)
                        shift_end_dt = datetime.combine(att.date, s_end)
                        
                        # If shift goes to next day (e.g. 22:00 -> 06:00), handle it? 
                        # Assuming day shifts for now based on user context (Ca 1-4). 
                        # If s_end < s_start, it's overnight.
                        if s_end < s_start:
                             shift_end_dt += timedelta(days=1)

                        # 2. Intersect Actual Work with Shift Boundaries
                        # effective_work_start = max(actual_checkin, shift_start_dt)
                        # effective_work_end = min(actual_checkout, shift_end_dt)
                        
                        # NOTE: actual_checkin/checkout might include dates. 
                        # If actual_checkout is < actual_checkin, assume overnight? 
                        # att.check_out is usually datetime.
                        
                        eff_start = max(actual_checkin, shift_start_dt)
                        eff_end = min(actual_checkout, shift_end_dt)
                        
                        if eff_end > eff_start:
                            reg_duration_minutes = int(round((eff_end - eff_start).total_seconds() / 60))
                        else:
                            reg_duration_minutes = 0

                        # 3. Deduct Break from In-Shift Duration
                        # Break is 12:00-13:00. Intersect this with [eff_start, eff_end]
                        
                        break_start = datetime.combine(att.date, time_type(12, 0))
                        break_end = datetime.combine(att.date, time_type(13, 0))
                        
                        b_overlap_start = max(eff_start, break_start)
                        b_overlap_end = min(eff_end, break_end)
                        
                        reg_break_deduction_minutes = 0
                        if b_overlap_end > b_overlap_start:
                            reg_break_deduction_minutes = int(round((b_overlap_end - b_overlap_start).total_seconds() / 60))

                        # 4. Calculate Final Regular Minutes - INTEGER CALCULATION
                        regular_minutes_val = max(0, reg_duration_minutes - reg_break_deduction_minutes)
                        
                        # Cap at 480 minutes (8 hours) just in case
                        regular_minutes = min(regular_minutes_val, 480)
                        
                        # 4.5. Recalculate TOTAL WORK MINUTES (Column I - "T·ªïng gi·ªù l√†m")
                        # This should reflect adjusted checkin/checkout minus break time
                        # Total = (actual_checkout - actual_checkin) - break_deduction
                        work_minutes = max(0, duration_minutes - break_deduction_minutes)

                        # 5. Recalculate Overtimes (Column K & L)
                        # OT Before 22h: Work done between [Shift End] and [22:00]
                        # OT After 22h: Work done between [22:00] and [Checkout]
                        
                        twenty_two = datetime.combine(att.date, time_type(22, 0))
                        
                        # --- OT Before 22 --- INTEGER MINUTES CALCULATION
                        # Start of OT is usually Shift End. But if they arrived AFTER Shift End (super late), start is Checkin.
                        ot1_start = max(shift_end_dt, actual_checkin) 
                        ot1_end = min(actual_checkout, twenty_two)
                        
                        ot1_minutes = 0
                        if ot1_end > ot1_start:
                             ot1_minutes = int(round((ot1_end - ot1_start).total_seconds() / 60))
                             # Deduct break if break is IN OT? usually break is 12-13. OT is >17. No overlap.
                             # But if shift is different? S_End is used.
                             # Assuming standard break 12-13 doesn't overlap with OT > 17:00.
                        
                        ot_before_str_val = minutes_to_hhmm(ot1_minutes)
                        
                        # --- OT After 22 --- INTEGER MINUTES CALCULATION
                        ot2_start = max(twenty_two, actual_checkin)
                        ot2_end = actual_checkout # No limit (unless next day limit?)
                        
                        ot2_minutes = 0
                        if ot2_end > ot2_start:
                             ot2_minutes = int(round((ot2_end - ot2_start).total_seconds() / 60))
                             
                        ot_after_str_val = minutes_to_hhmm(ot2_minutes)


                # A: Ng√†y
                cell = ws.cell(row=row_idx, column=1, value=att.date.strftime('%d/%m/%Y'))
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # B: Nh√¢n vi√™n
                cell = ws.cell(row=row_idx, column=2, value=employee_name)
                cell.alignment = Alignment(vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # C: M√£ nh√¢n vi√™n
                cell = ws.cell(row=row_idx, column=3, value=employee_code)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # D: Ph√≤ng ban
                cell = ws.cell(row=row_idx, column=4, value=department)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # E: Gi·ªù v√†o
                checkin_str = actual_checkin.strftime('%H:%M') if actual_checkin else "---"
                cell = ws.cell(row=row_idx, column=5, value=checkin_str)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # F: Gi·ªù ra
                checkout_str = actual_checkout.strftime('%H:%M') if actual_checkout else "---"
                cell = ws.cell(row=row_idx, column=6, value=checkout_str)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # G: Ngh·ªâ - FORMAT FROM INTEGER MINUTES
                break_str = minutes_to_hhmm(break_minutes)
                cell = ws.cell(row=row_idx, column=7, value=break_str)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # H: ƒê·ªëi ·ª©ng (comp time total)
                # Should use the actual comp time value from DB, not regular_hours!
                comp_minutes = (att.comp_time_regular_minutes or 0) + (att.comp_time_overtime_minutes or 0)
                comp_hours = comp_minutes / 60.0
                comp_str = f"{int(comp_hours)}:{int((comp_hours % 1) * 60):02d}"
                cell = ws.cell(row=row_idx, column=8, value=comp_str)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # I: T·ªïng gi·ªù l√†m - FORMAT FROM INTEGER MINUTES
                work_str = minutes_to_hhmm(work_minutes)
                cell = ws.cell(row=row_idx, column=9, value=work_str)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # J: Gi·ªù c√¥ng (regular work hours) - FORMAT FROM INTEGER MINUTES
                regular_str = minutes_to_hhmm(regular_minutes)
                cell = ws.cell(row=row_idx, column=10, value=regular_str)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # K: TƒÉng ca tr∆∞·ªõc 22h
                # Use recalculated value if available, else DB
                if 'ot_before_str_val' in locals() and is_late_early: # Fixed: use is_late_early flag
                     ot_before_str = ot_before_str_val
                else:
                     ot_before_str = att.overtime_before_22 if att.overtime_before_22 else "0:00"
                
                cell = ws.cell(row=row_idx, column=11, value=ot_before_str)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # L: TƒÉng ca sau 22h
                # Use recalculated value if available, else DB
                if 'ot_after_str_val' in locals() and is_late_early: # Fixed: use is_late_early flag
                     ot_after_str = ot_after_str_val
                else:
                     ot_after_str = att.overtime_after_22 if att.overtime_after_22 else "0:00"

                cell = ws.cell(row=row_idx, column=12, value=ot_after_str)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
                # M: Lo·∫°i ng√†y (based on day_type field if available)
                day_type_str = att.day_type if hasattr(att, 'day_type') and att.day_type else "Ng√†y th∆∞·ªùng"
                cell = ws.cell(row=row_idx, column=13, value=day_type_str)
                cell.alignment = Alignment(horizontal="center", vertical="center")
                if has_leave:
                    cell.fill = orange_fill
                
            except Exception as e:
                import traceback
                print(f"[ERROR] Error processing row {row_idx} (Attendance ID: {att.id}): {e}")
                traceback.print_exc()
                continue
        
        # Set column widths - Match attendance history format
        ws.column_dimensions['A'].width = 12  # Ng√†y
        ws.column_dimensions['B'].width = 25  # Nh√¢n vi√™n  
        ws.column_dimensions['C'].width = 15  # M√£ nh√¢n vi√™n
        ws.column_dimensions['D'].width = 20  # Ph√≤ng ban
        ws.column_dimensions['E'].width = 10  # Gi·ªù v√†o
        ws.column_dimensions['F'].width = 10  # Gi·ªù ra
        ws.column_dimensions['G'].width = 10  # Ngh·ªâ
        ws.column_dimensions['H'].width = 10  # ƒê·ªëi ·ª©ng
        ws.column_dimensions['I'].width = 12  # T·ªïng gi·ªù l√†m
        ws.column_dimensions['J'].width = 10  # Gi·ªù c√¥ng
        ws.column_dimensions['K'].width = 15  # TƒÉng ca tr∆∞·ªõc 22h
        ws.column_dimensions['L'].width = 15  # TƒÉng ca sau 22h
        ws.column_dimensions['M'].width = 15  # Lo·∫°i ng√†y
        
        # Auto-filter
        ws.auto_filter.ref = f"A1:M{len(attendance_records) + 1}"
        
        # Sheet 2 removed as per user request - file now contains only attendance data
        
        # Save to memory
        from io import BytesIO
        output = BytesIO()
        wb.save(output)
        output.seek(0)
        
        # Return file
        from flask import make_response
        from urllib.parse import quote
        filename = f"cham_cong_full_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        response = make_response(output.read())
        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        response.headers['Content-Disposition'] = f'attachment; filename*=UTF-8\'\'{quote(filename)}'

        return response
        
    except Exception as e:
        import traceback
        print(f"[ERROR] Excel Full export failed: {e}")
        print(traceback.format_exc())
        return jsonify({'error': str(e)}), 500


@app.route('/test-code-loaded', methods=['GET'])
def test_code_loaded():
    """Test route to verify code is loaded - NO LOGIN REQUIRED"""
    print("=" * 80)
    print("[TEST] TEST ROUTE CALLED - CODE IS LOADED SUCCESSFULLY!")
    print("=" * 80)
    return jsonify({
        'status': 'success',
        'message': 'Code ƒë√£ ƒë∆∞·ª£c load th√†nh c√¥ng! Updated at 2026-01-21 13:00',
        'approved_records': Attendance.query.filter(Attendance.status == 'approved').count()
    })





@app.route('/export-leave-cases-excel')
def export_leave_cases_excel():
    """T·∫°o file Excel t·ªïng h·ª£p m·ªçi tr∆∞·ªùng h·ª£p ngh·ªâ ƒë·ªÉ ki·ªÉm tra hi·ªÉn th·ªã.
    Kh√¥ng ghi DB, d√πng d·ªØ li·ªáu gi·∫£ l·∫≠p bao ph·ªß: ng√†y nguy√™n, ng√†y l·∫ª 0.5/1.5/2.5/3.5,
    k·∫øt h·ª£p nhi·ªÅu lo·∫°i ngh·ªâ, c√≥/kh√¥ng special_type, kho·∫£ng ng√†y nhi·ªÅu ng√†y.
    """
    try:
        from utils.excel_leave_processor import process_leave_requests_for_excel
        from dataclasses import dataclass
        from datetime import datetime, timedelta

        @dataclass
        class DummyLeave:
            employee_name: str
            employee_code: str
            team: str
            leave_reason: str
            leave_from_year: int
            leave_from_month: int
            leave_from_day: int
            leave_from_hour: int
            leave_from_minute: int
            leave_to_year: int
            leave_to_month: int
            leave_to_day: int
            leave_to_hour: int
            leave_to_minute: int
            annual_leave_days: float = 0.0
            unpaid_leave_days: float = 0.0
            special_leave_days: float = 0.0
            special_leave_type: str | None = None
            created_at: datetime = datetime.utcnow()
            substitute_name: str | None = None
            substitute_employee_id: str | None = None
            status: str = 'approved'

            # API t∆∞∆°ng th√≠ch models.LeaveRequest
            def get_leave_from_datetime(self):
                return datetime(self.leave_from_year, self.leave_from_month, self.leave_from_day,
                               self.leave_from_hour, self.leave_from_minute)

            def get_leave_to_datetime(self):
                return datetime(self.leave_to_year, self.leave_to_month, self.leave_to_day,
                               self.leave_to_hour, self.leave_to_minute)

            def get_reason_text(self):
                return self.leave_reason

        # T·∫°o danh s√°ch test cases bao ph·ªß c√°c t√¨nh hu·ªëng ch√≠nh
        base_date = datetime.utcnow().replace(hour=7, minute=30, second=0, microsecond=0)
        cases: list[DummyLeave] = [
            # 1) Ch·ªâ ph√©p nƒÉm 1, 2 ng√†y
            DummyLeave('Nguy·ªÖn VƒÉn A', 'A001', 'K·∫ø to√°n', 'Ngh·ªâ ph√©p nƒÉm 1 ng√†y',
                       base_date.year, base_date.month, base_date.day, 7, 30,
                       base_date.year, base_date.month, base_date.day, 16, 30,
                       annual_leave_days=1.0),
            DummyLeave('Nguy·ªÖn VƒÉn B', 'A002', 'K·∫ø to√°n', 'Ngh·ªâ ph√©p nƒÉm 2 ng√†y',
                       base_date.year, base_date.month, base_date.day, 7, 30,
                       (base_date + timedelta(days=1)).year, (base_date + timedelta(days=1)).month, (base_date + timedelta(days=1)).day, 16, 30,
                       annual_leave_days=2.0),
            # 2) Ch·ªâ kh√¥ng l∆∞∆°ng 1.5 ng√†y
            DummyLeave('Tr·∫ßn Th·ªã C', 'A003', 'H√†nh ch√≠nh', 'Ngh·ªâ kh√¥ng l∆∞∆°ng 1.5 ng√†y',
                       base_date.year, base_date.month, base_date.day, 7, 30,
                       base_date.year, base_date.month, base_date.day, 12, 0,
                       unpaid_leave_days=1.5),
            # 3) ƒê·∫∑c bi·ªát 1 ng√†y (k·∫øt h√¥n)
            DummyLeave('L√™ VƒÉn D', 'A004', 'Kho v·∫≠n', 'Ngh·ªâ ƒë·∫∑c bi·ªát (k·∫øt h√¥n)',
                       base_date.year, base_date.month, base_date.day, 7, 30,
                       base_date.year, base_date.month, base_date.day, 16, 30,
                       special_leave_days=1.0, special_leave_type='K·∫øt h√¥n'),
            # 4) K·∫øt h·ª£p 3 lo·∫°i m·ªói lo·∫°i 1 ng√†y (3 ng√†y li√™n ti·∫øp)
            DummyLeave('Ph·∫°m Th·ªã E', 'A005', 'Nh√¢n s·ª±', 'K·∫øt h·ª£p 3 lo·∫°i ngh·ªâ (m·ªói lo·∫°i 1 ng√†y)',
                       base_date.year, base_date.month, base_date.day, 7, 30,
                       (base_date + timedelta(days=2)).year, (base_date + timedelta(days=2)).month, (base_date + timedelta(days=2)).day, 16, 30,
                       annual_leave_days=1.0, unpaid_leave_days=1.0, special_leave_days=1.0, special_leave_type='Tang l·ªÖ'),
            # 5) T·ªïng 2.5 ng√†y: 1.0 ph√©p nƒÉm + 1.5 kh√¥ng l∆∞∆°ng
            DummyLeave('ƒê·ªó VƒÉn G', 'A006', 'S·∫£n xu·∫•t', 'Ph√©p nƒÉm 1.0 + Kh√¥ng l∆∞∆°ng 1.5',
                       base_date.year, base_date.month, base_date.day, 7, 30,
                       (base_date + timedelta(days=2)).year, (base_date + timedelta(days=2)).month, (base_date + timedelta(days=2)).day, 12, 0,
                       annual_leave_days=1.0, unpaid_leave_days=1.5),
            # 6) T·ªïng 3.5 ng√†y: 3.0 kh√¥ng l∆∞∆°ng + 0.5 ƒë·∫∑c bi·ªát
            DummyLeave('Ng√¥ Th·ªã H', 'A007', 'B√°n h√†ng', 'Kh√¥ng l∆∞∆°ng 3.0 + ƒê·∫∑c bi·ªát 0.5',
                       base_date.year, base_date.month, base_date.day, 7, 30,
                       (base_date + timedelta(days=3)).year, (base_date + timedelta(days=3)).month, (base_date + timedelta(days=3)).day, 12, 0,
                       unpaid_leave_days=3.0, special_leave_days=0.5, special_leave_type='Kh√°c'),
            # 7) T·ªïng 7.5 ng√†y: 3 annual + 3.5 unpaid + 1 special
            DummyLeave('B√πi Minh I', 'A008', 'K·ªπ thu·∫≠t', 'T·ªïng 7.5 ng√†y: 3 PN + 3.5 NKL + 1 ƒêB',
                       base_date.year, base_date.month, base_date.day, 7, 30,
                       (base_date + timedelta(days=7)).year, (base_date + timedelta(days=7)).month, (base_date + timedelta(days=7)).day, 12, 0,
                       annual_leave_days=3.0, unpaid_leave_days=3.5, special_leave_days=1.0, special_leave_type='Gia ƒë√¨nh'),
        ]

        # X·ª≠ l√Ω th√†nh daily rows
        daily_leaves = process_leave_requests_for_excel(cases)

        # Xu·∫•t Excel (d√πng c√πng format v·ªõi export ch√≠nh)
        wb = Workbook()
        ws = wb.active
        # ƒê·∫∑t ti√™u ƒë·ªÅ sheet ti·∫øng Vi·ªát (<=31 k√Ω t·ª±, kh√¥ng k√Ω t·ª± c·∫•m)
        ws.title = "L·ªãch s·ª≠ ngh·ªâ ph√©p"

        header_font = Font(bold=True, color="FFFFFF", size=12)
        header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
        header_alignment = Alignment(horizontal="center", vertical="center")

        headers = ["Nh√¢n vi√™n", "Ng√†y ngh·ªâ", "Th·ªùi gian ngh·ªâ", "L√Ω do", "Lo·∫°i ngh·ªâ", "S·ªë ng√†y", "Ng√†y t·∫°o"]
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = header_alignment

        for row, day_leave in enumerate(daily_leaves, 2):
            employee_info = f"{day_leave['employee_name']} ({day_leave['employee_code']})"
            ws.cell(row=row, column=1, value=employee_info)
            ws.cell(row=row, column=2, value=day_leave['date'].strftime('%d/%m/%Y'))
            ws.cell(row=row, column=3, value=f"{day_leave['start_time'].strftime('%H:%M')} - {day_leave['end_time'].strftime('%H:%M')}")
            ws.cell(row=row, column=4, value=str(day_leave['reason'] or ''))
            lt = day_leave['leave_type']
            lt_text = lt['name'] + (f" ({lt['special_type']})" if lt.get('special_type') else '')
            ws.cell(row=row, column=5, value=lt_text)
            ws.cell(row=row, column=6, value=day_leave.get('fractional_days', lt.get('days', 1.0)))
            ws.cell(row=row, column=7, value=_vn_datetime_format(day_leave['created_at'], '%d/%m/%Y %H:%M'))

        column_widths = [30, 15, 18, 50, 30, 12, 20]
        for col, width in enumerate(column_widths, 1):
            ws.column_dimensions[get_column_letter(col)].width = width

        for row in range(2, len(daily_leaves) + 2):
            ws.row_dimensions[row].height = 30

        from io import BytesIO
        output = BytesIO()
        wb.save(output)
        output.seek(0)

        vn_filename = f"B·ªô_test_c√°c_tr∆∞·ªùng_h·ª£p_ngh·ªâ_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        from urllib.parse import quote
        ascii_fallback = "bo_test_cac_truong_hop_nghi.xlsx"
        content_disposition = (
            f"attachment; filename=\"{ascii_fallback}\"; "
            f"filename*=UTF-8''{quote(vn_filename)}"
        )
        response = make_response(output.getvalue())
        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        response.headers['Content-Disposition'] = content_disposition
        response.headers['Content-Length'] = len(output.getvalue())
        # Th√™m header ƒë·ªÉ t·ª± ƒë·ªông t·∫£i xu·ªëng Downloads
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
    except Exception as e:
        print(f"[ERROR] Error exporting test cases Excel: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'L·ªói khi xu·∫•t test cases Excel: {str(e)}'}), 500
if __name__ == '__main__':
    with app.app_context():
        db.create_all()
        convert_overtime_to_hhmm()

    # --- B∆∞·ªõc 1: Ki·ªÉm tra license NGAY KHI KH·ªûI ƒê·ªòNG ---
    print("[LICENSE] ƒêang ki·ªÉm tra license tr∆∞·ªõc khi kh·ªüi ƒë·ªông server...", flush=True)
    is_valid, expired, status, msg = _check_license_once()

    if (not is_valid) or expired or (status not in ("active", "ƒëang ho·∫°t ƒë·ªông", "")):
        # License kh√¥ng h·ª£p l·ªá -> set flag ƒë·ªÉ ch·∫∑n truy c·∫≠p nh∆∞ng v·∫´n kh·ªüi ƒë·ªông server
        _license_is_valid = False
        try:
            # S·ª≠ d·ª•ng h√†m helper ƒë·ªÉ l·∫•y license key nh·∫•t qu√°n
            license_key = get_license_key()
            print(f"[LICENSE] License key ƒëang d√πng: {license_key}", flush=True)
        except Exception:
            pass

        final_msg = msg or "License kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n"
        contact_msg = (
            f"{final_msg}\n\n"
            "Vui l√≤ng li√™n h·ªá ADMIN ƒë·ªÉ gia h·∫°n:\n"
            "Nguy·ªÖn C√¥ng ƒê·∫°t - 0375097105."
        )
        print(f"[LICENSE] License KH√îNG H·ª¢P L·ªÜ / H·∫æT H·∫†N - Server v·∫´n kh·ªüi ƒë·ªông nh∆∞ng s·∫Ω ch·∫∑n t·∫•t c·∫£ truy c·∫≠p.", flush=True)
        print(f"[LICENSE] Chi ti·∫øt: {contact_msg}", flush=True)
        print(f"[LICENSE] H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông ki·ªÉm tra l·∫°i license m·ªói 60 gi√¢y.", flush=True)
    else:
        # License h·ª£p l·ªá
        _license_is_valid = True
        print("[LICENSE] License h·ª£p l·ªá, ti·∫øp t·ª•c kh·ªüi ƒë·ªông server...", flush=True)

    # --- B∆∞·ªõc 1.5: T·ª± ƒë·ªông kh·ªüi ƒë·ªông Ollama n·∫øu c·∫ßn (cho chatbot AI) ---
    try:
        _ensure_ollama_running()
    except Exception as e:
        print(f"[CHATBOT] ‚ö†Ô∏è  L·ªói khi kh·ªüi ƒë·ªông Ollama: {e}")

    # --- B∆∞·ªõc 2: Kh·ªüi ƒë·ªông c√°c d·ªãch v·ª• n·ªÅn (trong ƒë√≥ c√≥ license checker m·ªói 60 gi√¢y) ---
    try:
        start_all_background_services()
        print("üöÄ T·∫•t c·∫£ d·ªãch v·ª• n·ªÅn ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông:")
        print("   üõ°Ô∏è Backup: m·ªói 60 ph√∫t, gi·ªØ 3 b·∫£n + Telegram")
        print("   üîë Token Keep-Alive: m·ªói 30 ph√∫t")
        print("   üìÖ Yearly reset: ki·ªÉm tra m·ªói ng√†y, t·ª± reset v√†o 1/1 h·∫±ng nƒÉm")
        print("   üîê License check: verify online m·ªói 60 gi√¢y")
    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói kh·ªüi ƒë·ªông d·ªãch v·ª• n·ªÅn: {e}")
        # Fallback: kh·ªüi ƒë·ªông t·ª´ng d·ªãch v·ª• ri√™ng l·∫ª
        try:
            ensure_backup_scheduler_started(interval_minutes=60, backup_dir="backups", retention=3, send_to_telegram=True)
            print("üõ°Ô∏è Backup scheduler ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông ri√™ng l·∫ª")
        except Exception as e2:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông backup scheduler: {e2}")

        try:
            ensure_token_keepalive_started(interval_minutes=30)
            print("üîë Token Keep-Alive ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông ri√™ng l·∫ª")
        except Exception as e3:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông Token Keep-Alive: {e3}")

        try:
            ensure_license_check_started(interval_seconds=60)
            print("üîê License online checker ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông ri√™ng l·∫ª")
        except Exception as e4:
            print(f"[LICENSE] Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông license online checker: {e4}")

    # --- B∆∞·ªõc 3: Ch·ªâ ch·∫°y Flask server khi license h·ª£p l·ªá ---
    # FORCE DISABLE DEBUG MODE to prevent OSError: [Errno 22] Invalid argument
    # caused by Werkzeug debugger trying to print tracebacks to corrupted/closed stdout on Windows
    # Previously: debug_mode = os.environ.get('FLASK_DEBUG', 'False').lower() == 'true'
    debug_mode = False  # Debug disabled for production
    host = os.environ.get('FLASK_HOST', '0.0.0.0')
    port = int(os.environ.get('FLASK_PORT', 5000))

    # Tr√™n Windows, t·∫Øt reloader ƒë·ªÉ tr√°nh l·ªói threading v·ªõi selector.select()
    # L·ªói n√†y x·∫£y ra khi reloader c·ªë g·∫Øng reload app nh∆∞ng socket selector b·ªã l·ªói
    use_reloader = debug_mode and os.name != 'nt'  # Ch·ªâ d√πng reloader tr√™n Linux/Mac, t·∫Øt tr√™n Windows
    
    try:
        app.run(debug=debug_mode, host=host, port=port, use_reloader=use_reloader, threaded=True)
    except (OSError, ValueError) as e:
        # B·∫Øt l·ªói socket/threading tr√™n Windows khi reload
        if 'select' in str(e).lower() or 'selector' in str(e).lower():
            print(f"[WARNING] Flask reloader g·∫∑p l·ªói tr√™n Windows (kh√¥ng ·∫£nh h∆∞·ªüng ch·ª©c nƒÉng): {type(e).__name__}")
            # Th·ª≠ ch·∫°y l·∫°i kh√¥ng c√≥ reloader
            print("[INFO] Kh·ªüi ƒë·ªông l·∫°i Flask server kh√¥ng c√≥ reloader...")
            app.run(debug=False, host=host, port=port, use_reloader=False, threaded=True)
        else:
            raise   